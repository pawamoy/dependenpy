{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Dependenpy \u00a4 Show the inter-dependencies between modules of Python packages. dependenpy allows you to build a dependency matrix for a set of Python packages. To do this, it reads and searches the source code for import statements. Installation \u00a4 With pip : pip install dependenpy With pipx : python3.7 -m pip install --user pipx pipx install dependenpy Usage (as a library) \u00a4 from dependenpy import DSM # create DSM dsm = DSM ( 'django' ) # transform as matrix matrix = dsm . as_matrix ( depth = 2 ) # initialize with many packages dsm = DSM ( 'django' , 'meerkat' , 'appsettings' , 'dependenpy' , 'archan' ) with open ( 'output' , 'w' ) as output : dsm . print ( format = 'json' , indent = 2 , output = output ) # access packages and modules meerkat = dsm [ 'meerkat' ] # or dsm.get('meerkat') finder = dsm [ 'dependenpy.finder' ] # or even dsm['dependenpy']['finder'] # instances of DSM and Package all have print, as_matrix, etc. methods meerkat . print_matrix ( depth = 2 ) This package was originally design to work in a Django project. The Django package django-meerkat uses it to display the matrices with Highcharts. Usage (command-line) \u00a4 usage: dependenpy [-d DEPTH] [-f {csv,json,text}] [-g] [-G] [-h] [-i INDENT] [-l] [-m] [-o OUTPUT] [-t] [-v] [-z STRING] PACKAGES [PACKAGES ...] Command line tool for dependenpy Python package. positional arguments: PACKAGES The package list. Can be a comma-separated list. Each package must be either a valid path or a package in PYTHONPATH. optional arguments: -d DEPTH, --depth DEPTH Specify matrix or graph depth. Default: best guess. -f {csv,json,text}, --format {csv,json,text} Output format. Default: text. -g, --show-graph Show the graph (no text format). Default: false. -G, --greedy Explore subdirectories even if they do not contain an __init__.py file. Can make execution slower. Default: false. -h, --help Show this help message and exit. -i INDENT, --indent INDENT Specify output indentation. CSV will never be indented. Text will always have new-lines. JSON can be minified with a negative value. Default: best guess. -l, --show-dependencies-list Show the dependencies list. Default: false. -m, --show-matrix Show the matrix. Default: true unless -g, -l or -t. -o OUTPUT, --output OUTPUT Output to given file. Default: stdout. -t, --show-treemap Show the treemap (work in progress). Default: false. -v, --version Show the current version of the program and exit. -z ZERO, --zero ZERO Character to use for cells with value=0 (text matrix display only). Default: \"0\". Example: $ # running dependenpy on itself $ dependenpy dependenpy -z = Module \u2502 Id \u25020\u25021\u25022\u25023\u25024\u25025\u25026\u25027\u25028\u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u2524 dependenpy.__init__ \u2502 0 \u2502 \u2502 \u2502 \u25024\u2502 \u2502 \u2502 \u2502 \u25022\u2502 dependenpy.__main__ \u2502 1 \u2502 \u2502 \u25021\u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 dependenpy.cli \u2502 2 \u25021\u2502 \u2502 \u25021\u2502 \u25024\u2502 \u2502 \u2502 \u2502 dependenpy.dsm \u2502 3 \u2502 \u2502 \u2502 \u2502 \u25022\u25021\u25023\u2502 \u2502 \u2502 dependenpy.finder \u2502 4 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 dependenpy.helpers \u2502 5 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 dependenpy.node \u2502 6 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u25023\u2502 dependenpy.plugins \u2502 7 \u2502 \u2502 \u2502 \u25021\u2502 \u25021\u2502 \u2502 \u2502 \u2502 dependenpy.structures \u2502 8 \u2502 \u2502 \u2502 \u2502 \u2502 \u25021\u2502 \u2502 \u2502 \u2502","title":"Overview"},{"location":"#dependenpy","text":"Show the inter-dependencies between modules of Python packages. dependenpy allows you to build a dependency matrix for a set of Python packages. To do this, it reads and searches the source code for import statements.","title":"Dependenpy"},{"location":"#installation","text":"With pip : pip install dependenpy With pipx : python3.7 -m pip install --user pipx pipx install dependenpy","title":"Installation"},{"location":"#usage-as-a-library","text":"from dependenpy import DSM # create DSM dsm = DSM ( 'django' ) # transform as matrix matrix = dsm . as_matrix ( depth = 2 ) # initialize with many packages dsm = DSM ( 'django' , 'meerkat' , 'appsettings' , 'dependenpy' , 'archan' ) with open ( 'output' , 'w' ) as output : dsm . print ( format = 'json' , indent = 2 , output = output ) # access packages and modules meerkat = dsm [ 'meerkat' ] # or dsm.get('meerkat') finder = dsm [ 'dependenpy.finder' ] # or even dsm['dependenpy']['finder'] # instances of DSM and Package all have print, as_matrix, etc. methods meerkat . print_matrix ( depth = 2 ) This package was originally design to work in a Django project. The Django package django-meerkat uses it to display the matrices with Highcharts.","title":"Usage (as a library)"},{"location":"#usage-command-line","text":"usage: dependenpy [-d DEPTH] [-f {csv,json,text}] [-g] [-G] [-h] [-i INDENT] [-l] [-m] [-o OUTPUT] [-t] [-v] [-z STRING] PACKAGES [PACKAGES ...] Command line tool for dependenpy Python package. positional arguments: PACKAGES The package list. Can be a comma-separated list. Each package must be either a valid path or a package in PYTHONPATH. optional arguments: -d DEPTH, --depth DEPTH Specify matrix or graph depth. Default: best guess. -f {csv,json,text}, --format {csv,json,text} Output format. Default: text. -g, --show-graph Show the graph (no text format). Default: false. -G, --greedy Explore subdirectories even if they do not contain an __init__.py file. Can make execution slower. Default: false. -h, --help Show this help message and exit. -i INDENT, --indent INDENT Specify output indentation. CSV will never be indented. Text will always have new-lines. JSON can be minified with a negative value. Default: best guess. -l, --show-dependencies-list Show the dependencies list. Default: false. -m, --show-matrix Show the matrix. Default: true unless -g, -l or -t. -o OUTPUT, --output OUTPUT Output to given file. Default: stdout. -t, --show-treemap Show the treemap (work in progress). Default: false. -v, --version Show the current version of the program and exit. -z ZERO, --zero ZERO Character to use for cells with value=0 (text matrix display only). Default: \"0\". Example: $ # running dependenpy on itself $ dependenpy dependenpy -z = Module \u2502 Id \u25020\u25021\u25022\u25023\u25024\u25025\u25026\u25027\u25028\u2502 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u2524 dependenpy.__init__ \u2502 0 \u2502 \u2502 \u2502 \u25024\u2502 \u2502 \u2502 \u2502 \u25022\u2502 dependenpy.__main__ \u2502 1 \u2502 \u2502 \u25021\u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 dependenpy.cli \u2502 2 \u25021\u2502 \u2502 \u25021\u2502 \u25024\u2502 \u2502 \u2502 \u2502 dependenpy.dsm \u2502 3 \u2502 \u2502 \u2502 \u2502 \u25022\u25021\u25023\u2502 \u2502 \u2502 dependenpy.finder \u2502 4 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 dependenpy.helpers \u2502 5 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 dependenpy.node \u2502 6 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u25023\u2502 dependenpy.plugins \u2502 7 \u2502 \u2502 \u2502 \u25021\u2502 \u25021\u2502 \u2502 \u2502 \u2502 dependenpy.structures \u2502 8 \u2502 \u2502 \u2502 \u2502 \u2502 \u25021\u2502 \u2502 \u2502 \u2502","title":"Usage (command-line)"},{"location":"changelog/","text":"Changelog \u00a4 All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning . 3.3.2 - 2022-09-04 \u00a4 Compare with 3.3.1 Bug Fixes \u00a4 Add back missing colorama runtime dependency ( f3e274c by Vlad Dumitrescu). References: #57 Copy data when casting a matrix ( 13ec81a by Vlad Dumitrescu). References: #53 3.3.1 - 2022-06-13 \u00a4 Compare with 3.3.0 Bug Fixes \u00a4 Handle the case where all modules names are shorter than the header when printing a matrix ( 1d83b17 by Vlad Dumitrescu). PR #48 3.3.0 - 2020-09-04 \u00a4 Compare with 3.2.0 Code Refactoring \u00a4 Poetrize the project ( 811c3fb by Timoth\u00e9e Mazzucotelli). Features \u00a4 Add 'zero' argument to change character for 0 ( 1c13c00 by Timoth\u00e9e Mazzucotelli). Update archan provider for archan 3.0 ( 9249dc1 by Timoth\u00e9e Mazzucotelli). 3.2.0 - 2017-06-27 \u00a4 Compare with 3.1.0 Features \u00a4 Add graph option ( 1ebc8f6 ). Implement archan provider ( 66edb5b ). 3.1.0 - 2017-06-02 \u00a4 Compare with 3.0.0 Features \u00a4 Add -i, --indent option to specify indentation level. Changes \u00a4 Change -i, --enforce-init option to its contrary -g, --greedy . Options -l , -m and -t are now mutually exclusive. Bug fixes \u00a4 Fix imports order ( 9a9fcc3 ). Fix matrix build for depth=0 ( 955cc21 ). Misc \u00a4 Improve cli tool and print methods, 3.0.0 - 2017-05-22 \u00a4 Compare with 2.0.3 This version is a big refactoring. The code is way more object oriented, cleaner, shorter, simpler, smarter, more user friendly- in short: better. Additional features: command line entry point, runtime static imports are now caught (in functions or classes), as well as import statements (previously only from import). 2.0.3 - 2017-04-20 \u00a4 Compare with 2.0.2 Changes \u00a4 Change license from MPL 2.0 to ISC ( 35400bf ). Bug fixes \u00a4 Fix occasional UnicodeEncode when reading utf8 file ( 333e987 ). Handle bad characters in files when parsing with ast ( 200e014 ). 2.0.2 - 2016-10-06 \u00a4 Compare with 1.0.4 Split code in two projects: dependenpy and archan. Update to use Python 3. Various bug fixes, additions, improvements and refactor. 1.0.4 - 2015-03-05 \u00a4 Compare with 1.0.3 Documentation and tests improvements. 1.0.3 - 2015-02-26 \u00a4 Compare with 1.0.2 Bug fixes \u00a4 Add check for target_index not None ( d3e573f ). 1.0.2 - 2015-02-24 \u00a4 Compare with 1.0.1 Features \u00a4 Added CSV export ( ce8a911 ). Bug fixes \u00a4 Fix get_matrix if str instead of int, fix csv write row (extend return None) ( bb1289d ). 1.0.1 - 2015-02-23 \u00a4 Compare with 1.0 Bug fixes \u00a4 Fix hashable for dict ( 7d221db ). Fix path resolver ( 4e8a192 ). 1.0 - 2015-02-23 \u00a4 Compare with 0.2-beta Code refactoring \u00a4 4bd14d9 15ba1e5 12fa604 0.2-beta - 2015-02-20 \u00a4 Compare with first commit First release.","title":"Changelog"},{"location":"changelog/#changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog and this project adheres to Semantic Versioning .","title":"Changelog"},{"location":"changelog/#332-2022-09-04","text":"Compare with 3.3.1","title":"3.3.2 - 2022-09-04"},{"location":"changelog/#bug-fixes","text":"Add back missing colorama runtime dependency ( f3e274c by Vlad Dumitrescu). References: #57 Copy data when casting a matrix ( 13ec81a by Vlad Dumitrescu). References: #53","title":"Bug Fixes"},{"location":"changelog/#331-2022-06-13","text":"Compare with 3.3.0","title":"3.3.1 - 2022-06-13"},{"location":"changelog/#bug-fixes_1","text":"Handle the case where all modules names are shorter than the header when printing a matrix ( 1d83b17 by Vlad Dumitrescu). PR #48","title":"Bug Fixes"},{"location":"changelog/#330-2020-09-04","text":"Compare with 3.2.0","title":"3.3.0 - 2020-09-04"},{"location":"changelog/#code-refactoring","text":"Poetrize the project ( 811c3fb by Timoth\u00e9e Mazzucotelli).","title":"Code Refactoring"},{"location":"changelog/#features","text":"Add 'zero' argument to change character for 0 ( 1c13c00 by Timoth\u00e9e Mazzucotelli). Update archan provider for archan 3.0 ( 9249dc1 by Timoth\u00e9e Mazzucotelli).","title":"Features"},{"location":"changelog/#320-2017-06-27","text":"Compare with 3.1.0","title":"3.2.0 - 2017-06-27"},{"location":"changelog/#features_1","text":"Add graph option ( 1ebc8f6 ). Implement archan provider ( 66edb5b ).","title":"Features"},{"location":"changelog/#310-2017-06-02","text":"Compare with 3.0.0","title":"3.1.0 - 2017-06-02"},{"location":"changelog/#features_2","text":"Add -i, --indent option to specify indentation level.","title":"Features"},{"location":"changelog/#changes","text":"Change -i, --enforce-init option to its contrary -g, --greedy . Options -l , -m and -t are now mutually exclusive.","title":"Changes"},{"location":"changelog/#bug-fixes_2","text":"Fix imports order ( 9a9fcc3 ). Fix matrix build for depth=0 ( 955cc21 ).","title":"Bug fixes"},{"location":"changelog/#misc","text":"Improve cli tool and print methods,","title":"Misc"},{"location":"changelog/#300-2017-05-22","text":"Compare with 2.0.3 This version is a big refactoring. The code is way more object oriented, cleaner, shorter, simpler, smarter, more user friendly- in short: better. Additional features: command line entry point, runtime static imports are now caught (in functions or classes), as well as import statements (previously only from import).","title":"3.0.0 - 2017-05-22"},{"location":"changelog/#203-2017-04-20","text":"Compare with 2.0.2","title":"2.0.3 - 2017-04-20"},{"location":"changelog/#changes_1","text":"Change license from MPL 2.0 to ISC ( 35400bf ).","title":"Changes"},{"location":"changelog/#bug-fixes_3","text":"Fix occasional UnicodeEncode when reading utf8 file ( 333e987 ). Handle bad characters in files when parsing with ast ( 200e014 ).","title":"Bug fixes"},{"location":"changelog/#202-2016-10-06","text":"Compare with 1.0.4 Split code in two projects: dependenpy and archan. Update to use Python 3. Various bug fixes, additions, improvements and refactor.","title":"2.0.2 - 2016-10-06"},{"location":"changelog/#104-2015-03-05","text":"Compare with 1.0.3 Documentation and tests improvements.","title":"1.0.4 - 2015-03-05"},{"location":"changelog/#103-2015-02-26","text":"Compare with 1.0.2","title":"1.0.3 - 2015-02-26"},{"location":"changelog/#bug-fixes_4","text":"Add check for target_index not None ( d3e573f ).","title":"Bug fixes"},{"location":"changelog/#102-2015-02-24","text":"Compare with 1.0.1","title":"1.0.2 - 2015-02-24"},{"location":"changelog/#features_3","text":"Added CSV export ( ce8a911 ).","title":"Features"},{"location":"changelog/#bug-fixes_5","text":"Fix get_matrix if str instead of int, fix csv write row (extend return None) ( bb1289d ).","title":"Bug fixes"},{"location":"changelog/#101-2015-02-23","text":"Compare with 1.0","title":"1.0.1 - 2015-02-23"},{"location":"changelog/#bug-fixes_6","text":"Fix hashable for dict ( 7d221db ). Fix path resolver ( 4e8a192 ).","title":"Bug fixes"},{"location":"changelog/#10-2015-02-23","text":"Compare with 0.2-beta","title":"1.0 - 2015-02-23"},{"location":"changelog/#code-refactoring_1","text":"4bd14d9 15ba1e5 12fa604","title":"Code refactoring"},{"location":"changelog/#02-beta-2015-02-20","text":"Compare with first commit First release.","title":"0.2-beta - 2015-02-20"},{"location":"code_of_conduct/","text":"Contributor Covenant Code of Conduct \u00a4 Our Pledge \u00a4 In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards \u00a4 Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities \u00a4 Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope \u00a4 This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement \u00a4 Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at pawamoy@pm.me . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution \u00a4 This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Code of Conduct"},{"location":"code_of_conduct/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"code_of_conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"code_of_conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"code_of_conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"code_of_conduct/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"code_of_conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at pawamoy@pm.me . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"code_of_conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4","title":"Attribution"},{"location":"contributing/","text":"Contributing \u00a4 Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. Environment setup \u00a4 Nothing easier! Fork and clone the repository, then: cd dependenpy make setup Note If it fails for some reason, you'll need to install PDM manually. You can install it with: python3 -m pip install --user pipx pipx install pdm Now you can try running make setup again, or simply pdm install . You now have the dependencies installed. You can run the application with pdm run dependenpy [ARGS...] . Run make help to see all the available actions! Tasks \u00a4 This project uses duty to run tasks. A Makefile is also provided. The Makefile will try to run certain tasks on multiple Python versions. If for some reason you don't want to run the task on multiple Python versions, you can do one of the following: export PYTHON_VERSIONS= : this will run the task with only the current Python version run the task directly with pdm run duty TASK The Makefile detects if a virtual environment is activated, so make will work the same with the virtualenv activated or not. Development \u00a4 As usual: create a new branch: git checkout -b feature-or-bugfix-name edit the code and/or the documentation Before committing: run make format to auto-format the code run make check to check everything (fix any warning) run make test to run the tests (fix any issue) if you updated the documentation or the project dependencies: run make docs-serve go to http://localhost:8000 and check that everything looks good follow our commit message convention If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review. Don't bother updating the changelog, we will take care of this. Commit message convention \u00a4 Commits messages must follow the Angular style : <type>[(scope)]: Subject [Body] Scope and body are optional. Type can be: build : About packaging, building wheels, etc. chore : About packaging or repo/files management. ci : About Continuous Integration. docs : About documentation. feat : New feature. fix : Bug fix. perf : About performance. refactor : Changes which are not features nor bug fixes. style : A change in code style/format. tests : About tests. Subject (and body) must be valid Markdown. If you write a body, please add issues references at the end: Body. References: #10, #11. Fixes #15. Pull requests guidelines \u00a4 Link to any related issue in the Pull Request message. During review, we recommend using fixups: # SHA is the SHA of the commit you want to fix git commit --fixup = SHA Once all the changes are approved, you can squash your commits: git rebase -i --autosquash master And force-push: git push -f If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.","title":"Contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.","title":"Contributing"},{"location":"contributing/#environment-setup","text":"Nothing easier! Fork and clone the repository, then: cd dependenpy make setup Note If it fails for some reason, you'll need to install PDM manually. You can install it with: python3 -m pip install --user pipx pipx install pdm Now you can try running make setup again, or simply pdm install . You now have the dependencies installed. You can run the application with pdm run dependenpy [ARGS...] . Run make help to see all the available actions!","title":"Environment setup"},{"location":"contributing/#tasks","text":"This project uses duty to run tasks. A Makefile is also provided. The Makefile will try to run certain tasks on multiple Python versions. If for some reason you don't want to run the task on multiple Python versions, you can do one of the following: export PYTHON_VERSIONS= : this will run the task with only the current Python version run the task directly with pdm run duty TASK The Makefile detects if a virtual environment is activated, so make will work the same with the virtualenv activated or not.","title":"Tasks"},{"location":"contributing/#development","text":"As usual: create a new branch: git checkout -b feature-or-bugfix-name edit the code and/or the documentation Before committing: run make format to auto-format the code run make check to check everything (fix any warning) run make test to run the tests (fix any issue) if you updated the documentation or the project dependencies: run make docs-serve go to http://localhost:8000 and check that everything looks good follow our commit message convention If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review. Don't bother updating the changelog, we will take care of this.","title":"Development"},{"location":"contributing/#commit-message-convention","text":"Commits messages must follow the Angular style : <type>[(scope)]: Subject [Body] Scope and body are optional. Type can be: build : About packaging, building wheels, etc. chore : About packaging or repo/files management. ci : About Continuous Integration. docs : About documentation. feat : New feature. fix : Bug fix. perf : About performance. refactor : Changes which are not features nor bug fixes. style : A change in code style/format. tests : About tests. Subject (and body) must be valid Markdown. If you write a body, please add issues references at the end: Body. References: #10, #11. Fixes #15.","title":"Commit message convention"},{"location":"contributing/#pull-requests-guidelines","text":"Link to any related issue in the Pull Request message. During review, we recommend using fixups: # SHA is the SHA of the commit you want to fix git commit --fixup = SHA Once all the changes are approved, you can squash your commits: git rebase -i --autosquash master And force-push: git push -f If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.","title":"Pull requests guidelines"},{"location":"credits/","text":"These projects were used to build dependenpy . Thank you! python | pdm | copier-pdm Runtime dependencies \u00a4 Project Summary Version (accepted) Version (last resolved) License colorama Cross-platform colored terminal text. >=0.4.5 0.4.5 BSD Development dependencies \u00a4 Project Summary Version (accepted) Version (last resolved) License ansimarkup Produce colored terminal text with an xml-like markup ~=1.4 1.5.0 Revised BSD License astor Read/rewrite/write Python ASTs >=0.8 0.8.1 BSD-3-Clause atomicwrites Atomic file writes. >=1.0; sys_platform == \"win32\" 1.4.0 ? attrs Classes Without Boilerplate >=19.2.0 21.4.0 MIT autoflake Removes unused imports and unused variables >=1.4 1.4 Expat License bandit Security oriented static analyser for python code. >=1.7.3 1.7.4 Apache-2.0 license black The uncompromising code formatter. >=21.10b0 22.3.0 MIT cached-property A decorator for caching properties in classes. ~=1.5; python_version < \"3.8\" 1.5.2 ? certifi Python package for providing Mozilla's CA Bundle. >=2017.4.17 2022.5.18.1 MPL-2.0 charset-normalizer The Real First Universal Charset Detector. Open, modern and actively maintained alternative to Chardet. ~=2.0.0 2.0.12 MIT click Composable command line interface toolkit >=8.0.0 8.1.3 BSD-3-Clause colorama Cross-platform colored terminal text. ; platform_system == \"Windows\" 0.4.5 BSD coverage Code coverage measurement for Python [toml]>=5.2.1 6.4.1 Apache 2.0 darglint A utility for ensuring Google-style docstrings stay up to date with the source code. >=1.8 1.8.1 MIT dparse A parser for Python dependency files >=0.5.1 0.5.1 MIT license duty A simple task runner. >=0.7 0.7.0 ISC execnet execnet: rapid multi-Python deployment >=1.1 1.9.0 MIT failprint Run a command, print its output only if it fails. ~=0.8 0.8.0 ISC flake8 the modular source code checker: pep8 pyflakes and co <4 3.9.2 MIT flake8-bandit Automated security testing with bandit and flake8. >=2.1 3.0.0 MIT flake8-black flake8 plugin to call black as a code style validator >=0.2 0.3.3 MIT flake8-bugbear A plugin for flake8 finding likely bugs and design problems in your program. Contains warnings that don't belong in pyflakes and pycodestyle. >=21.9 22.4.25 MIT flake8-builtins Check for python builtins being used as variables or parameters. >=1.5 1.5.3 GPL version 2 flake8-comprehensions A flake8 plugin to help you write better list/set/dict comprehensions. >=3.7 3.10.0 MIT flake8-docstrings Extension for flake8 which uses pydocstyle to check docstrings >=1.6 1.6.0 MIT License flake8-plugin-utils The package provides base classes and utils for flake8 plugin writing <2.0.0,>=1.3.2 1.3.2 MIT flake8-polyfill Polyfill package for Flake8 plugins 1.0.2 MIT flake8-pytest-style A flake8 plugin checking common style issues or inconsistencies with pytest-based tests. >=1.5 1.6.0 MIT flake8-string-format string format checker, plugin for flake8 >=0.3 0.3.0 MIT License flake8-tidy-imports A flake8 plugin that helps you write tidier imports. >=4.5 4.8.0 MIT flake8-variables-names A flake8 extension that helps to make more readable variables names >=0.0 0.0.5 MIT ghp-import Copy your docs directly to the gh-pages branch. >=1.0 2.1.0 Apache Software License git-changelog Automatic Changelog generator using Jinja2 templates. >=0.4 0.5.0 ISC gitdb Git Object Database <5,>=4.0.1 4.0.9 BSD License gitpython GitPython is a python library used to interact with Git repositories >=1.0.1 3.1.27 BSD griffe Signatures for entire Python programs. Extract the structure, the frame, the skeleton of your project, to generate API documentation or find breaking changes in your API. >=0.11.1 0.20.0 ISC License (ISCL) idna Internationalized Domain Names in Applications (IDNA) <4,>=2.5 3.3 BSD-3-Clause importlib-metadata Read metadata from Python packages ; python_version < \"3.8\" 4.11.4 Apache Software License iniconfig iniconfig: brain-dead simple config-ini parsing 1.1.1 MIT License isort A Python utility / library to sort Python imports. >=5.10 5.10.1 MIT jinja2 A very fast and expressive template engine. <4,>=2.11 3.1.2 BSD-3-Clause markdown Python implementation of Markdown. <4.0,>=3.3 3.3.7 BSD License markdown-callouts Markdown extension: a classier syntax for admonitions >=0.2 0.2.0 MIT markdown-exec Utilities to execute code blocks in Markdown files. >=0.5 0.7.0 ISC markupsafe Safely add untrusted strings to HTML/XML markup. >=2.0 2.1.1 BSD-3-Clause mccabe McCabe checker, plugin for flake8 <0.7.0,>=0.6.0 0.6.1 Expat license mergedeep A deep merge function for \ud83d\udc0d. >=1.3.4 1.3.4 MIT License mkdocs Project documentation with Markdown. >=1.3 1.3.0 BSD mkdocs-coverage MkDocs plugin to integrate your coverage HTML report into your site. >=0.2 0.2.5 ISC License (ISCL) mkdocs-gen-files MkDocs plugin to programmatically generate documentation pages during the build >=0.3 0.3.4 MIT mkdocs-literate-nav MkDocs plugin to specify the navigation in Markdown instead of YAML >=0.4 0.4.1 MIT mkdocs-material Documentation that simply works >=7.3 8.3.4 MIT mkdocs-material-extensions Extension pack for Python Markdown. >=1.0.3 1.0.3 MIT License mkdocs-section-index MkDocs plugin to allow clickable sections that lead to an index page >=0.3 0.3.4 MIT mkdocstrings Automatic documentation from sources, for MkDocs. [python]>=0.18 0.19.0 ISC License (ISCL) mkdocstrings-python A Python handler for mkdocstrings. >=0.5.2 0.7.1 ISC mypy Optional static typing for Python >=0.910 0.961 MIT License mypy-extensions Experimental type system extensions for programs checked with the mypy typechecker. >=0.4.3 0.4.3 MIT License packaging Core utilities for Python packages >=20.5 21.3 BSD-2-Clause or Apache-2.0 pathspec Utility library for gitignore style pattern matching of file paths. >=0.9.0 0.9.0 MPL 2.0 pbr Python Build Reasonableness !=2.1.0,>=2.0.0 5.9.0 Apache Software License pep8-naming Check PEP-8 naming conventions, plugin for flake8 >=0.12 0.13.0 Expat license platformdirs A small Python module for determining appropriate platform-specific dirs, e.g. a \"user data dir\". >=2 2.5.2 MIT License pluggy plugin and hook calling mechanisms for python <2.0,>=0.12 1.0.0 MIT ptyprocess Run a subprocess in a pseudo terminal ~=0.6; sys_platform != \"win32\" 0.7.0 ISC License (ISCL) py library with cross-python path, ini-parsing, io, code, log facilities >=1.8.2 1.11.0 MIT license pycodestyle Python style guide checker <2.8.0,>=2.7.0 2.7.0 Expat license pydocstyle Python docstring style checker >=2.1 6.1.1 MIT pyflakes passive checker of Python programs >=1.1.0 2.3.1 MIT pygments Pygments is a syntax highlighting package written in Python. >=2.12 2.12.0 BSD License pymdown-extensions Extension pack for Python Markdown. >=9 9.5 MIT License pyparsing pyparsing module - Classes and methods to define and execute parsing grammars !=3.0.5,>=2.0.2 3.0.9 MIT License pytest pytest: simple powerful testing with Python >=6.2 7.1.2 MIT pytest-cov Pytest plugin for measuring coverage. >=3.0 3.0.0 MIT pytest-forked run tests in isolated forked subprocesses 1.4.0 MIT pytest-randomly Pytest plugin to randomly order tests and control random.seed. >=3.10 3.12.0 MIT pytest-xdist pytest xdist plugin for distributed testing and loop-on-failing modes >=2.4 2.5.0 MIT python-dateutil Extensions to the standard Python datetime module >=2.8.1 2.8.2 Dual License pyyaml YAML parser and emitter for Python >=3.10 6.0 MIT pyyaml-env-tag A custom YAML tag for referencing environment variables in YAML files. >=0.1 0.1 MIT License requests Python HTTP for Humans. 2.28.0 Apache 2.0 ruamel.yaml ruamel.yaml is a YAML parser/emitter that supports roundtrip preservation of comments, seq/map flow style, and map key order >=0.17.21 0.17.21 MIT license ruamel.yaml.clib C version of reader, parser and emitter for ruamel.yaml derived from libyaml >=0.2.6; platform_python_implementation == \"CPython\" and python_version < \"3.11\" 0.2.6 MIT safety Checks installed dependencies for known vulnerabilities and licenses. >=2 2.1.1 MIT license semver Python helper for Semantic Versioning (http://semver.org/) ~=2.13 2.13.0 BSD setuptools Easily download, build, install, upgrade, and uninstall Python packages >=19.3 62.4.0 MIT License six Python 2 and 3 compatibility utilities >=1.5 1.16.0 MIT smmap A pure Python implementation of a sliding window memory map manager <6,>=3.0.1 5.0.0 BSD snowballstemmer This package provides 29 stemmers for 28 languages generated from Snowball algorithms. 2.2.0 BSD-3-Clause stevedore Manage dynamic plugins for Python applications >=1.20.0 3.5.0 Apache Software License toml Python Library for Tom's Obvious, Minimal Language >=0.10 0.10.2 MIT tomli A lil' TOML parser >=1.1.0; python_version < \"3.11\" 2.0.1 MIT License typed-ast a fork of Python 2 and 3 ast modules with type comment support >=1.4.2; python_version < \"3.8\" and implementation_name == \"cpython\" 1.5.4 ? types-markdown Typing stubs for Markdown >=3.3 3.3.28 Apache-2.0 license types-toml Typing stubs for toml >=0.10 0.10.7 Apache-2.0 license typing-extensions Backported and Experimental Type Hints for Python 3.7+ >=3.10.0.0; python_version < \"3.10\" 4.2.0 Python Software Foundation License urllib3 HTTP library with thread-safe connection pooling, file post, and more. <1.27,>=1.21.1 1.26.9 MIT watchdog Filesystem events monitoring >=2.0 2.1.9 Apache License 2.0 wps-light The strictest and most opinionated python linter ever (lighter fork). >=0.15 0.16.1 MIT zipp Backport of pathlib-compatible object wrapper for zip files >=0.5 3.8.0 MIT License More credits from the author","title":"Credits"},{"location":"license/","text":"ISC License Copyright (c) 2020, Timoth\u00e9e Mazzucotelli Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted, provided that the above copyright notice and this permission notice appear in all copies. THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.","title":"License"},{"location":"usage/","text":"Usage \u00a4 Importing classes \u00a4 You can directly import the following classes from dependenpy : DSM , Package , Module , Dependency , Matrix and TreeMap . If you need to import other classes, please take a look at the structure of the code. Example: from dependenpy import DSM , Matrix Creation of objects \u00a4 For basic usage, you only have to instantiate a DSM object, and sometimes Matrix and TreeMap . But if you need to do more complicated stuff, you might also want to build instances of Package , Module or Dependency . Create a DSM \u00a4 To create a DSM object, just pass it a list of packages that can be either found on the disk (absolute or relative paths), or in the Python path (like in sys.path ). from dependenpy import DSM django = DSM ( 'django' ) flask = DSM ( 'flask' ) both = DSM ( 'django' , 'flask' ) Three keyword arguments can be given to DSM : build_tree : Boolean build_dependencies : Boolean enforce_init : Boolean The three of them defaults to true. Turning build_tree to false will delay the build of the Python package tree (the exploration of files on the file system). You can later call dsm.build_tree() to build the tree. Turning build_dependencies to false will delay the build of the dependencies (the parsing of the source code to determine the inter-dependencies). You can later call dsm.build_dependencies() to build the dependencies. Note that you won't be able to build the dependencies before the tree has been built. Using true for both build_tree and build_dependencies is recommended since it is done pretty quickly, even for big projects like Django. Turning enforce_init to false will make the exploration of sub-directories complete: by default, a sub-directory is not explored if it does not contain an __init__.py file. It makes the building of the tree faster. But in some cases, you might want to still explore the sub-directory even without __init__.py . In that case, use enforce_init=False . Note that depending on the tree, the build might take longer. Create a Package \u00a4 To create a Package object, initialize it with a name and a path. These two arguments are the only one required. Name should be the name of the Python package (the name of the directory), and path should be the path to the directory on the file system. Example: from dependenpy import Package absolute_package = Package ( 'django' , '/my/virtualenv/lib/python3.5/site-packages/django' ) relative_package = Package ( 'program' , 'src/program' ) Additionally, you can pass 6 more keyword arguments: the same three from DSM ( build_tree , build_dependencies and enforce_init ), and the three following: dsm : parent DSM (instance of DSM). package : parent package (instance of Package). limit_to : list of strings to limit the exploration to a subset of directories. These three arguments default to None . Both dsm and package arguments are useful to build a tree. Argument limit_to can be used this way: from dependenpy import Package django_auth = Package ( 'django' , 'path/to/django' , limit_to = [ 'contrib.auth' ]) Of course, you could also have build a the django_auth Package by directly specify the name and path of the sub-directory, but using limit_to allows you to build the full tree, starting at the root (Django's directory). from dependenpy import Package django_auth = Package ( 'auth' , 'path/to/django/contrib/auth' ) Create a Module \u00a4 To create a Module object, initialize it with a name and a path. These two arguments are the only one required. Name should be the name of the Python module (the file without the .py extension), and path should be the path to the file on the file system. As for Package , dsm and package arguments can be passed when creating a module. Example: from dependenpy import Module dsm_module = Module ( 'dsm' , 'path/to/dependenpy/dsm.py' ) Create a Dependency \u00a4 A dependency is a simple object that require: source : the Module instance importing the item, lineno : the line number at which the import occurred, target : the Package or Module instance from which the item is imported and an optional what argument which defaults to None: the name of the imported item. Create a Matrix \u00a4 From an instance of DSM or Package called node : matrix = node . as_matrix ( depth = 2 ) From a list of nodes (DSMs, packages or modules): matrix = Matrix ( * node_list , depth = 2 ) An instance of Matrix has a data attribute, which is a two-dimensions array of integers, and a keys attribute which is the list of names, in the same order as rows in data. Create a TreeMap \u00a4 From an instance of DSM or Package called node : treemap = node . as_treemap ( depth = 2 ) From a list of nodes (DSMs, packages or modules): matrix = TreeMap ( * node_list , depth = 2 ) An instance of TreeMap has a data attribute, which is a two-dimensions array of integers or treemaps, a keys attribute which is the list of names in the same order as rows in data, and a value attribute which is the total number of dependencies in the treemap. Create a Graph \u00a4 From an instance of DSM or Package called node : graph = node . as_graph ( depth = 2 ) From a list of nodes (DSMs, packages or modules): graph = Graph ( * node_list , depth = 2 ) An instance of Graph has a vertices attribute, which is a list of Vertex instances, and a edges attribute which is list of Edge instances. See the documentation of Vertex and Edge for more information. Accessing elements \u00a4 Accessing elements in a DSM or a Package is very easy. Just like for a dictionary, you can use the [] notation to search for a sub-package or a sub-module. You can also use the get method, which is equivalent to the brackets accessor, but will return None if the element is not found whereas brackets accessor will raise a KeyError . Example: from dependenpy import DSM dsm = DSM ( 'django' ) # full DSM object, containing Django django = dsm [ 'django' ] # Django Package object You can use dots in the element name to go further in just one instruction: django_auth = django [ 'contrib.auth' ] django_forms_models = dsm . get ( 'django.forms.models' ) Of course, accesses can be chained: django_db_models_utils = dsm [ 'django' ] . get ( 'db' )[ 'models' ][ 'utils' ] Printing contents \u00a4 Contents of DSMs, packages, modules, matrices, treemaps and graphs can be printed with their print method. The contents printed are the dependencies. With some exception, each one of them can output contents in three different formats: text (by default) CSV JSON (Currently, treemaps are not implemented, and graphs can only be printed in JSON or CSV.) To choose one of these format, just pass the format argument, which accepts values 'text' , 'csv' and 'json' . Please note that these values can be replaced by constants imported from dependenpy.helpers module: from dependenpy import DSM from dependenpy.helpers import TEXT , CSV , JSON dsm = DSM ( 'django' ) dsm . print ( format = JSON ) Depending on the chosen format, additional keyword arguments can be passed to the print method: text format: indent , indentation value (integer) CSV format: header , True or False, to display the headers (columns names) JSON format: every arguments accepted by json.dumps , and in the case of a Module instance, absolute Boolean to switch between output of absolute and relative paths. For DSM and Package instances, shortcuts to print a matrix, a treemap or a graph are available with print_matrix , print_treemap and print_graph methods. These methods will first create the related object and then call the object's own print method.","title":"Usage"},{"location":"usage/#usage","text":"","title":"Usage"},{"location":"usage/#importing-classes","text":"You can directly import the following classes from dependenpy : DSM , Package , Module , Dependency , Matrix and TreeMap . If you need to import other classes, please take a look at the structure of the code. Example: from dependenpy import DSM , Matrix","title":"Importing classes"},{"location":"usage/#creation-of-objects","text":"For basic usage, you only have to instantiate a DSM object, and sometimes Matrix and TreeMap . But if you need to do more complicated stuff, you might also want to build instances of Package , Module or Dependency .","title":"Creation of objects"},{"location":"usage/#create-a-dsm","text":"To create a DSM object, just pass it a list of packages that can be either found on the disk (absolute or relative paths), or in the Python path (like in sys.path ). from dependenpy import DSM django = DSM ( 'django' ) flask = DSM ( 'flask' ) both = DSM ( 'django' , 'flask' ) Three keyword arguments can be given to DSM : build_tree : Boolean build_dependencies : Boolean enforce_init : Boolean The three of them defaults to true. Turning build_tree to false will delay the build of the Python package tree (the exploration of files on the file system). You can later call dsm.build_tree() to build the tree. Turning build_dependencies to false will delay the build of the dependencies (the parsing of the source code to determine the inter-dependencies). You can later call dsm.build_dependencies() to build the dependencies. Note that you won't be able to build the dependencies before the tree has been built. Using true for both build_tree and build_dependencies is recommended since it is done pretty quickly, even for big projects like Django. Turning enforce_init to false will make the exploration of sub-directories complete: by default, a sub-directory is not explored if it does not contain an __init__.py file. It makes the building of the tree faster. But in some cases, you might want to still explore the sub-directory even without __init__.py . In that case, use enforce_init=False . Note that depending on the tree, the build might take longer.","title":"Create a DSM"},{"location":"usage/#create-a-package","text":"To create a Package object, initialize it with a name and a path. These two arguments are the only one required. Name should be the name of the Python package (the name of the directory), and path should be the path to the directory on the file system. Example: from dependenpy import Package absolute_package = Package ( 'django' , '/my/virtualenv/lib/python3.5/site-packages/django' ) relative_package = Package ( 'program' , 'src/program' ) Additionally, you can pass 6 more keyword arguments: the same three from DSM ( build_tree , build_dependencies and enforce_init ), and the three following: dsm : parent DSM (instance of DSM). package : parent package (instance of Package). limit_to : list of strings to limit the exploration to a subset of directories. These three arguments default to None . Both dsm and package arguments are useful to build a tree. Argument limit_to can be used this way: from dependenpy import Package django_auth = Package ( 'django' , 'path/to/django' , limit_to = [ 'contrib.auth' ]) Of course, you could also have build a the django_auth Package by directly specify the name and path of the sub-directory, but using limit_to allows you to build the full tree, starting at the root (Django's directory). from dependenpy import Package django_auth = Package ( 'auth' , 'path/to/django/contrib/auth' )","title":"Create a Package"},{"location":"usage/#create-a-module","text":"To create a Module object, initialize it with a name and a path. These two arguments are the only one required. Name should be the name of the Python module (the file without the .py extension), and path should be the path to the file on the file system. As for Package , dsm and package arguments can be passed when creating a module. Example: from dependenpy import Module dsm_module = Module ( 'dsm' , 'path/to/dependenpy/dsm.py' )","title":"Create a Module"},{"location":"usage/#create-a-dependency","text":"A dependency is a simple object that require: source : the Module instance importing the item, lineno : the line number at which the import occurred, target : the Package or Module instance from which the item is imported and an optional what argument which defaults to None: the name of the imported item.","title":"Create a Dependency"},{"location":"usage/#create-a-matrix","text":"From an instance of DSM or Package called node : matrix = node . as_matrix ( depth = 2 ) From a list of nodes (DSMs, packages or modules): matrix = Matrix ( * node_list , depth = 2 ) An instance of Matrix has a data attribute, which is a two-dimensions array of integers, and a keys attribute which is the list of names, in the same order as rows in data.","title":"Create a Matrix"},{"location":"usage/#create-a-treemap","text":"From an instance of DSM or Package called node : treemap = node . as_treemap ( depth = 2 ) From a list of nodes (DSMs, packages or modules): matrix = TreeMap ( * node_list , depth = 2 ) An instance of TreeMap has a data attribute, which is a two-dimensions array of integers or treemaps, a keys attribute which is the list of names in the same order as rows in data, and a value attribute which is the total number of dependencies in the treemap.","title":"Create a TreeMap"},{"location":"usage/#create-a-graph","text":"From an instance of DSM or Package called node : graph = node . as_graph ( depth = 2 ) From a list of nodes (DSMs, packages or modules): graph = Graph ( * node_list , depth = 2 ) An instance of Graph has a vertices attribute, which is a list of Vertex instances, and a edges attribute which is list of Edge instances. See the documentation of Vertex and Edge for more information.","title":"Create a Graph"},{"location":"usage/#accessing-elements","text":"Accessing elements in a DSM or a Package is very easy. Just like for a dictionary, you can use the [] notation to search for a sub-package or a sub-module. You can also use the get method, which is equivalent to the brackets accessor, but will return None if the element is not found whereas brackets accessor will raise a KeyError . Example: from dependenpy import DSM dsm = DSM ( 'django' ) # full DSM object, containing Django django = dsm [ 'django' ] # Django Package object You can use dots in the element name to go further in just one instruction: django_auth = django [ 'contrib.auth' ] django_forms_models = dsm . get ( 'django.forms.models' ) Of course, accesses can be chained: django_db_models_utils = dsm [ 'django' ] . get ( 'db' )[ 'models' ][ 'utils' ]","title":"Accessing elements"},{"location":"usage/#printing-contents","text":"Contents of DSMs, packages, modules, matrices, treemaps and graphs can be printed with their print method. The contents printed are the dependencies. With some exception, each one of them can output contents in three different formats: text (by default) CSV JSON (Currently, treemaps are not implemented, and graphs can only be printed in JSON or CSV.) To choose one of these format, just pass the format argument, which accepts values 'text' , 'csv' and 'json' . Please note that these values can be replaced by constants imported from dependenpy.helpers module: from dependenpy import DSM from dependenpy.helpers import TEXT , CSV , JSON dsm = DSM ( 'django' ) dsm . print ( format = JSON ) Depending on the chosen format, additional keyword arguments can be passed to the print method: text format: indent , indentation value (integer) CSV format: header , True or False, to display the headers (columns names) JSON format: every arguments accepted by json.dumps , and in the case of a Module instance, absolute Boolean to switch between output of absolute and relative paths. For DSM and Package instances, shortcuts to print a matrix, a treemap or a graph are available with print_matrix , print_treemap and print_graph methods. These methods will first create the related object and then call the object's own print method.","title":"Printing contents"},{"location":"reference/SUMMARY/","text":"dependenpy cli dsm finder helpers node plugins structures","title":"SUMMARY"},{"location":"reference/dependenpy/","text":"Dependenpy package. Show the inter-dependencies between modules of Python packages. With dependenpy you will be able to analyze the internal dependencies in your Python code, i.e. which module needs which other module. You will then be able to build a dependency matrix and use it for other purposes. If you read this message, you probably want to learn about the library and not the command-line tool: please refer to the README.md included in this package to get the link to the official documentation. DSM \u00a4 Bases: RootNode , NodeMixin , PrintMixin DSM-capable class. Technically speaking, a DSM instance is not a real DSM but more a tree representing the Python packages structure. However, it has the necessary methods to build a real DSM in the form of a square matrix, a dictionary or a tree-map. Source code in dependenpy/dsm.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 class DSM ( RootNode , NodeMixin , PrintMixin ): \"\"\" DSM-capable class. Technically speaking, a DSM instance is not a real DSM but more a tree representing the Python packages structure. However, it has the necessary methods to build a real DSM in the form of a square matrix, a dictionary or a tree-map. \"\"\" def __init__ ( self , * packages : str , build_tree : bool = True , build_dependencies : bool = True , enforce_init : bool = True ): \"\"\" Initialization method. Args: *packages: list of packages to search for. build_tree: auto-build the tree or not. build_dependencies: auto-build the dependencies or not. enforce_init: if True, only treat directories if they contain an `__init__.py` file. \"\"\" self . base_packages = packages self . finder = Finder () self . specs = [] self . not_found = [] self . enforce_init = enforce_init specs = [] for package in packages : spec = self . finder . find ( package , enforce_init = enforce_init ) if spec : specs . append ( spec ) else : self . not_found . append ( package ) if not specs : print ( \"** dependenpy: DSM empty.\" , file = sys . stderr ) self . specs = PackageSpec . combine ( specs ) for module in self . not_found : print ( f \"** dependenpy: Not found: { module } .\" , file = sys . stderr ) super () . __init__ ( build_tree ) if build_tree and build_dependencies : self . build_dependencies () def __str__ ( self ): packages_names = \", \" . join ([ package . name for package in self . packages ]) return f \"Dependency DSM for packages: [ { packages_names } ]\" @property def isdsm ( self ) -> bool : \"\"\" Inherited from NodeMixin. Always True. Returns: Whether this object is a DSM. \"\"\" return True def build_tree ( self ): \"\"\"Build the Python packages tree.\"\"\" for spec in self . specs : if spec . ismodule : self . modules . append ( Module ( spec . name , spec . path , dsm = self )) else : self . packages . append ( Package ( spec . name , spec . path , dsm = self , limit_to = spec . limit_to , build_tree = True , build_dependencies = False , enforce_init = self . enforce_init , ) ) __init__ ( * packages , build_tree = True , build_dependencies = True , enforce_init = True ) \u00a4 Initialization method. Parameters: Name Type Description Default *packages str list of packages to search for. () build_tree bool auto-build the tree or not. True build_dependencies bool auto-build the dependencies or not. True enforce_init bool if True, only treat directories if they contain an __init__.py file. True Source code in dependenpy/dsm.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def __init__ ( self , * packages : str , build_tree : bool = True , build_dependencies : bool = True , enforce_init : bool = True ): \"\"\" Initialization method. Args: *packages: list of packages to search for. build_tree: auto-build the tree or not. build_dependencies: auto-build the dependencies or not. enforce_init: if True, only treat directories if they contain an `__init__.py` file. \"\"\" self . base_packages = packages self . finder = Finder () self . specs = [] self . not_found = [] self . enforce_init = enforce_init specs = [] for package in packages : spec = self . finder . find ( package , enforce_init = enforce_init ) if spec : specs . append ( spec ) else : self . not_found . append ( package ) if not specs : print ( \"** dependenpy: DSM empty.\" , file = sys . stderr ) self . specs = PackageSpec . combine ( specs ) for module in self . not_found : print ( f \"** dependenpy: Not found: { module } .\" , file = sys . stderr ) super () . __init__ ( build_tree ) if build_tree and build_dependencies : self . build_dependencies () build_tree () \u00a4 Build the Python packages tree. Source code in dependenpy/dsm.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def build_tree ( self ): \"\"\"Build the Python packages tree.\"\"\" for spec in self . specs : if spec . ismodule : self . modules . append ( Module ( spec . name , spec . path , dsm = self )) else : self . packages . append ( Package ( spec . name , spec . path , dsm = self , limit_to = spec . limit_to , build_tree = True , build_dependencies = False , enforce_init = self . enforce_init , ) ) isdsm () property \u00a4 Inherited from NodeMixin. Always True. Returns: Type Description bool Whether this object is a DSM. Source code in dependenpy/dsm.py 80 81 82 83 84 85 86 87 88 @property def isdsm ( self ) -> bool : \"\"\" Inherited from NodeMixin. Always True. Returns: Whether this object is a DSM. \"\"\" return True Dependency \u00a4 Bases: object Dependency class. Represent a dependency from a module to another. Source code in dependenpy/dsm.py 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 class Dependency ( object ): \"\"\" Dependency class. Represent a dependency from a module to another. \"\"\" def __init__ ( self , source , lineno , target , what = None ): \"\"\" Initialization method. Args: source (Module): source Module. lineno (int): number of line at which import statement occurs. target (str/Module/Package): the target node. what (str): what is imported (optional). \"\"\" self . source = source self . lineno = lineno self . target = target self . what = what def __str__ ( self ): what = f \" { self . what or '' } from \" target = self . target if self . external else self . target . absolute_name () return f \" { self . source . name } imports { what }{ target } (line { self . lineno } )\" @property def external ( self ) -> bool : \"\"\" Property to tell if the dependency's target is a valid node. Returns: Whether the dependency's target is a valid node. \"\"\" return isinstance ( self . target , str ) __init__ ( source , lineno , target , what = None ) \u00a4 Initialization method. Parameters: Name Type Description Default source Module source Module. required lineno int number of line at which import statement occurs. required target str/Module/Package the target node. required what str what is imported (optional). None Source code in dependenpy/dsm.py 426 427 428 429 430 431 432 433 434 435 436 437 438 439 def __init__ ( self , source , lineno , target , what = None ): \"\"\" Initialization method. Args: source (Module): source Module. lineno (int): number of line at which import statement occurs. target (str/Module/Package): the target node. what (str): what is imported (optional). \"\"\" self . source = source self . lineno = lineno self . target = target self . what = what external () property \u00a4 Property to tell if the dependency's target is a valid node. Returns: Type Description bool Whether the dependency's target is a valid node. Source code in dependenpy/dsm.py 446 447 448 449 450 451 452 453 454 @property def external ( self ) -> bool : \"\"\" Property to tell if the dependency's target is a valid node. Returns: Whether the dependency's target is a valid node. \"\"\" return isinstance ( self . target , str ) Matrix \u00a4 Bases: PrintMixin Matrix class. A class to build a matrix given a list of nodes. After instantiation, it has two attributes: data, a 2-dimensions array, and keys, the names of the entities in the corresponding order. Source code in dependenpy/structures.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 class Matrix ( PrintMixin ): \"\"\" Matrix class. A class to build a matrix given a list of nodes. After instantiation, it has two attributes: data, a 2-dimensions array, and keys, the names of the entities in the corresponding order. \"\"\" def __init__ ( self , * nodes : DSM | Package | Module , depth : int = 0 ): # noqa: WPS231 \"\"\" Initialization method. Args: *nodes: The nodes on which to build the matrix. depth: The depth of the matrix. This depth is always absolute, meaning that building a matrix with a sub-package \"A.B.C\" and a depth of 1 will return a matrix of size 1, containing A only. To see the matrix for the sub-modules and sub-packages in C, you will have to give depth=4. \"\"\" modules : list [ Module ] = [] for node in nodes : if node . ismodule : modules . append ( node ) # type: ignore[arg-type] elif node . ispackage or node . isdsm : modules . extend ( node . submodules ) # type: ignore[union-attr] if depth < 1 : keys = modules else : keys = [] for module in modules : if module . depth <= depth : keys . append ( module ) continue package = module . package while package . depth > depth and package . package and package not in nodes : package = package . package if package not in keys : keys . append ( package ) size = len ( keys ) data = [[ 0 ] * size for _ in range ( size )] # noqa: WPS435 keys = sorted ( keys , key = lambda key : key . absolute_name ()) if depth < 1 : for index , key in enumerate ( keys ): # noqa: WPS440 key . index = index # type: ignore[attr-defined] for index , key in enumerate ( keys ): # noqa: WPS440 for dep in key . dependencies : if dep . external : continue if dep . target . ismodule and dep . target in keys : data [ index ][ dep . target . index ] += 1 elif dep . target . ispackage : init = dep . target . get ( \"__init__\" ) if init is not None and init in keys : data [ index ][ init . index ] += 1 else : for row , row_key in enumerate ( keys ): for col , col_key in enumerate ( keys ): data [ row ][ col ] = row_key . cardinal ( to = col_key ) self . size = size self . keys = [ key . absolute_name () for key in keys ] # noqa: WPS441 self . data = data @staticmethod # noqa: WPS602 def cast ( keys : list [ str ], data : list [ list [ int ]]) -> Matrix : # noqa: WPS602 \"\"\" Cast a set of keys and an array to a Matrix object. Arguments: keys: The matrix keys. data: The matrix data. Returns: A new matrix. \"\"\" matrix = Matrix () matrix . keys = copy . deepcopy ( keys ) matrix . data = copy . deepcopy ( data ) return matrix @property def total ( self ) -> int : \"\"\" Return the total number of dependencies within this matrix. Returns: The total number of dependencies. \"\"\" return sum ( cell for line in self . data for cell in line ) def _to_csv ( self , ** kwargs ): text = [ \"module,\" , \",\" . join ( self . keys )] for index , key in enumerate ( self . keys ): line = \",\" . join ( map ( str , self . data [ index ])) text . append ( f \" { key } , { line } \" ) return \" \\n \" . join ( text ) def _to_json ( self , ** kwargs ): return json . dumps ({ \"keys\" : self . keys , \"data\" : self . data }, ** kwargs ) def _to_text ( self , ** kwargs ): if not self . keys or not self . data : return \"\" zero = kwargs . pop ( \"zero\" , \"0\" ) max_key_length = max ( len ( key ) for key in self . keys + [ \"Module\" ]) max_dep_length = max ([ len ( str ( col )) for line in self . data for col in line ] + [ len ( zero )]) key_col_length = len ( str ( len ( self . keys ))) key_line_length = max ( key_col_length , 2 ) column_length = max ( key_col_length , max_dep_length ) bold = Style . BRIGHT reset = Style . RESET_ALL # first line left headers text = [ f \" \\n { bold }{ 'Module' : > { max_key_length }}{ reset } \u2502 { bold }{ 'Id' : > { key_line_length }}{ reset } \u2502\" ] # first line column headers for index , _ in enumerate ( self . keys ): text . append ( f \" { bold }{ index : ^ { column_length }}{ reset } \u2502\" ) text . append ( \" \\n \" ) # line of dashes text . append ( f \" { '\u2500' * max_key_length } \u2500\u253c\u2500 { '\u2500' * key_line_length } \u2500\u253c\" ) for _ in range ( len ( self . keys ) - 1 ): text . append ( f \" { '\u2500' * column_length } \u253c\" ) text . append ( f \" { '\u2500' * column_length } \u2524\" ) text . append ( \" \\n \" ) # lines for index , key in enumerate ( self . keys ): # noqa: WPS440 text . append ( f \" { key : > { max_key_length }} \u2502 { bold }{ index : > { key_line_length }}{ reset } \u2502\" ) for value in self . data [ index ]: text . append (( f \" { value if value else zero : > { column_length }} \u2502\" )) text . append ( \" \\n \" ) text . append ( \" \\n \" ) return \"\" . join ( text ) __init__ ( * nodes , depth = 0 ) \u00a4 Initialization method. Parameters: Name Type Description Default *nodes DSM | Package | Module The nodes on which to build the matrix. () depth int The depth of the matrix. This depth is always absolute, meaning that building a matrix with a sub-package \"A.B.C\" and a depth of 1 will return a matrix of size 1, containing A only. To see the matrix for the sub-modules and sub-packages in C, you will have to give depth=4. 0 Source code in dependenpy/structures.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def __init__ ( self , * nodes : DSM | Package | Module , depth : int = 0 ): # noqa: WPS231 \"\"\" Initialization method. Args: *nodes: The nodes on which to build the matrix. depth: The depth of the matrix. This depth is always absolute, meaning that building a matrix with a sub-package \"A.B.C\" and a depth of 1 will return a matrix of size 1, containing A only. To see the matrix for the sub-modules and sub-packages in C, you will have to give depth=4. \"\"\" modules : list [ Module ] = [] for node in nodes : if node . ismodule : modules . append ( node ) # type: ignore[arg-type] elif node . ispackage or node . isdsm : modules . extend ( node . submodules ) # type: ignore[union-attr] if depth < 1 : keys = modules else : keys = [] for module in modules : if module . depth <= depth : keys . append ( module ) continue package = module . package while package . depth > depth and package . package and package not in nodes : package = package . package if package not in keys : keys . append ( package ) size = len ( keys ) data = [[ 0 ] * size for _ in range ( size )] # noqa: WPS435 keys = sorted ( keys , key = lambda key : key . absolute_name ()) if depth < 1 : for index , key in enumerate ( keys ): # noqa: WPS440 key . index = index # type: ignore[attr-defined] for index , key in enumerate ( keys ): # noqa: WPS440 for dep in key . dependencies : if dep . external : continue if dep . target . ismodule and dep . target in keys : data [ index ][ dep . target . index ] += 1 elif dep . target . ispackage : init = dep . target . get ( \"__init__\" ) if init is not None and init in keys : data [ index ][ init . index ] += 1 else : for row , row_key in enumerate ( keys ): for col , col_key in enumerate ( keys ): data [ row ][ col ] = row_key . cardinal ( to = col_key ) self . size = size self . keys = [ key . absolute_name () for key in keys ] # noqa: WPS441 self . data = data cast ( keys , data ) staticmethod \u00a4 Cast a set of keys and an array to a Matrix object. Parameters: Name Type Description Default keys list [ str ] The matrix keys. required data list [ list [ int ]] The matrix data. required Returns: Type Description Matrix A new matrix. Source code in dependenpy/structures.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 @staticmethod # noqa: WPS602 def cast ( keys : list [ str ], data : list [ list [ int ]]) -> Matrix : # noqa: WPS602 \"\"\" Cast a set of keys and an array to a Matrix object. Arguments: keys: The matrix keys. data: The matrix data. Returns: A new matrix. \"\"\" matrix = Matrix () matrix . keys = copy . deepcopy ( keys ) matrix . data = copy . deepcopy ( data ) return matrix total () property \u00a4 Return the total number of dependencies within this matrix. Returns: Type Description int The total number of dependencies. Source code in dependenpy/structures.py 102 103 104 105 106 107 108 109 110 @property def total ( self ) -> int : \"\"\" Return the total number of dependencies within this matrix. Returns: The total number of dependencies. \"\"\" return sum ( cell for line in self . data for cell in line ) Module \u00a4 Bases: LeafNode , NodeMixin , PrintMixin Module class. This class represents a Python module (a Python file). Source code in dependenpy/dsm.py 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 class Module ( LeafNode , NodeMixin , PrintMixin ): # noqa: WPS338 \"\"\" Module class. This class represents a Python module (a Python file). \"\"\" RECURSIVE_NODES = ( ast . ClassDef , ast . FunctionDef , ast . If , ast . IfExp , ast . Try , ast . With , ast . ExceptHandler ) def __init__ ( self , name , path , dsm = None , package = None ): \"\"\" Initialization method. Args: name (str): name of the module. path (str): path to the module. dsm (DSM): parent DSM. package (Package): parent Package. \"\"\" super () . __init__ () self . name = name self . path = path self . package = package self . dsm = dsm self . dependencies = [] def __contains__ ( self , item ) -> bool : \"\"\" Whether given item is contained inside this module. Args: item (Package/Module): a package or module. Returns: True if self is item or item is self's package and self if an `__init__` module. \"\"\" if self is item : return True elif self . package is item and self . name == \"__init__\" : return True return False @property def ismodule ( self ) -> bool : \"\"\" Inherited from NodeMixin. Always True. Returns: Whether this object is a module. \"\"\" return True def as_dict ( self , absolute : bool = False ) -> dict : \"\"\" Return the dependencies as a dictionary. Arguments: absolute: Whether to use the absolute name. Returns: dict: dictionary of dependencies. \"\"\" return { \"name\" : self . absolute_name () if absolute else self . name , \"path\" : self . path , \"dependencies\" : [ { # 'source': d.source.absolute_name(), # redundant \"target\" : dep . target if dep . external else dep . target . absolute_name (), \"lineno\" : dep . lineno , \"what\" : dep . what , \"external\" : dep . external , } for dep in self . dependencies ], } def _to_text ( self , ** kwargs ): indent = kwargs . pop ( \"indent\" , 2 ) base_indent = kwargs . pop ( \"base_indent\" , None ) if base_indent is None : base_indent = indent indent = 0 text = [ \" \" * indent + self . name + \" \\n \" ] new_indent = indent + base_indent for dep in self . dependencies : external = \"! \" if dep . external else \"\" text . append ( \" \" * new_indent + external + str ( dep ) + \" \\n \" ) return \"\" . join ( text ) def _to_csv ( self , ** kwargs ): header = kwargs . pop ( \"header\" , True ) text = [ \"module,path,target,lineno,what,external \\n \" if header else \"\" ] name = self . absolute_name () for dep in self . dependencies : target = dep . target if dep . external else dep . target . absolute_name () text . append ( f \" { name } , { self . path } , { target } , { dep . lineno } , { dep . what or '' } , { dep . external } \\n \" ) return \"\" . join ( text ) def _to_json ( self , ** kwargs ): absolute = kwargs . pop ( \"absolute\" , False ) return json . dumps ( self . as_dict ( absolute = absolute ), ** kwargs ) def build_dependencies ( self ): \"\"\" Build the dependencies for this module. Parse the code with ast, find all the import statements, convert them into Dependency objects. \"\"\" highest = self . dsm or self . root if self is highest : highest = LeafNode () for import_ in self . parse_code (): target = highest . get_target ( import_ [ \"target\" ]) if target : what = import_ [ \"target\" ] . split ( \".\" )[ - 1 ] if what != target . name : import_ [ \"what\" ] = what import_ [ \"target\" ] = target self . dependencies . append ( Dependency ( source = self , ** import_ )) def parse_code ( self ) -> list [ dict ]: \"\"\" Read the source code and return all the import statements. Returns: list of dict: the import statements. \"\"\" code = Path ( self . path ) . read_text ( encoding = \"utf-8\" ) try : body = ast . parse ( code ) . body except SyntaxError : code = code . encode ( \"utf-8\" ) # type: ignore[assignment] try : # noqa: WPS505 body = ast . parse ( code ) . body except SyntaxError : return [] return self . get_imports ( body ) def get_imports ( self , ast_body ) -> list [ dict ]: # noqa: WPS231,WPS615 \"\"\" Return all the import statements given an AST body (AST nodes). Args: ast_body (compiled code's body): the body to filter. Returns: The import statements. \"\"\" imports : list [ dict ] = [] for node in ast_body : if isinstance ( node , ast . Import ): imports . extend ({ \"target\" : name . name , \"lineno\" : node . lineno } for name in node . names ) elif isinstance ( node , ast . ImportFrom ): for name in node . names : abs_name = self . absolute_name ( self . depth - node . level ) + \".\" if node . level > 0 else \"\" node_module = node . module + \".\" if node . module else \"\" name = abs_name + node_module + name . name # type: ignore[assignment] imports . append ({ \"target\" : name , \"lineno\" : node . lineno }) elif isinstance ( node , Module . RECURSIVE_NODES ): imports . extend ( self . get_imports ( node . body )) if isinstance ( node , ast . Try ): imports . extend ( self . get_imports ( node . finalbody )) return imports def cardinal ( self , to ) -> int : \"\"\" Return the number of dependencies of this module to the given node. Args: to (Package/Module): the target node. Returns: Number of dependencies. \"\"\" return len ([ dep for dep in self . dependencies if not dep . external and dep . target in to ]) __contains__ ( item ) \u00a4 Whether given item is contained inside this module. Parameters: Name Type Description Default item Package/Module a package or module. required Returns: Type Description bool True if self is item or item is self's package and self if an __init__ module. Source code in dependenpy/dsm.py 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 def __contains__ ( self , item ) -> bool : \"\"\" Whether given item is contained inside this module. Args: item (Package/Module): a package or module. Returns: True if self is item or item is self's package and self if an `__init__` module. \"\"\" if self is item : return True elif self . package is item and self . name == \"__init__\" : return True return False __init__ ( name , path , dsm = None , package = None ) \u00a4 Initialization method. Parameters: Name Type Description Default name str name of the module. required path str path to the module. required dsm DSM parent DSM. None package Package parent Package. None Source code in dependenpy/dsm.py 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 def __init__ ( self , name , path , dsm = None , package = None ): \"\"\" Initialization method. Args: name (str): name of the module. path (str): path to the module. dsm (DSM): parent DSM. package (Package): parent Package. \"\"\" super () . __init__ () self . name = name self . path = path self . package = package self . dsm = dsm self . dependencies = [] as_dict ( absolute = False ) \u00a4 Return the dependencies as a dictionary. Parameters: Name Type Description Default absolute bool Whether to use the absolute name. False Returns: Name Type Description dict dict dictionary of dependencies. Source code in dependenpy/dsm.py 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 def as_dict ( self , absolute : bool = False ) -> dict : \"\"\" Return the dependencies as a dictionary. Arguments: absolute: Whether to use the absolute name. Returns: dict: dictionary of dependencies. \"\"\" return { \"name\" : self . absolute_name () if absolute else self . name , \"path\" : self . path , \"dependencies\" : [ { # 'source': d.source.absolute_name(), # redundant \"target\" : dep . target if dep . external else dep . target . absolute_name (), \"lineno\" : dep . lineno , \"what\" : dep . what , \"external\" : dep . external , } for dep in self . dependencies ], } build_dependencies () \u00a4 Build the dependencies for this module. Parse the code with ast, find all the import statements, convert them into Dependency objects. Source code in dependenpy/dsm.py 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 def build_dependencies ( self ): \"\"\" Build the dependencies for this module. Parse the code with ast, find all the import statements, convert them into Dependency objects. \"\"\" highest = self . dsm or self . root if self is highest : highest = LeafNode () for import_ in self . parse_code (): target = highest . get_target ( import_ [ \"target\" ]) if target : what = import_ [ \"target\" ] . split ( \".\" )[ - 1 ] if what != target . name : import_ [ \"what\" ] = what import_ [ \"target\" ] = target self . dependencies . append ( Dependency ( source = self , ** import_ )) cardinal ( to ) \u00a4 Return the number of dependencies of this module to the given node. Parameters: Name Type Description Default to Package/Module the target node. required Returns: Type Description int Number of dependencies. Source code in dependenpy/dsm.py 406 407 408 409 410 411 412 413 414 415 416 def cardinal ( self , to ) -> int : \"\"\" Return the number of dependencies of this module to the given node. Args: to (Package/Module): the target node. Returns: Number of dependencies. \"\"\" return len ([ dep for dep in self . dependencies if not dep . external and dep . target in to ]) get_imports ( ast_body ) \u00a4 Return all the import statements given an AST body (AST nodes). Parameters: Name Type Description Default ast_body compiled code's body the body to filter. required Returns: Type Description list [ dict ] The import statements. Source code in dependenpy/dsm.py 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 def get_imports ( self , ast_body ) -> list [ dict ]: # noqa: WPS231,WPS615 \"\"\" Return all the import statements given an AST body (AST nodes). Args: ast_body (compiled code's body): the body to filter. Returns: The import statements. \"\"\" imports : list [ dict ] = [] for node in ast_body : if isinstance ( node , ast . Import ): imports . extend ({ \"target\" : name . name , \"lineno\" : node . lineno } for name in node . names ) elif isinstance ( node , ast . ImportFrom ): for name in node . names : abs_name = self . absolute_name ( self . depth - node . level ) + \".\" if node . level > 0 else \"\" node_module = node . module + \".\" if node . module else \"\" name = abs_name + node_module + name . name # type: ignore[assignment] imports . append ({ \"target\" : name , \"lineno\" : node . lineno }) elif isinstance ( node , Module . RECURSIVE_NODES ): imports . extend ( self . get_imports ( node . body )) if isinstance ( node , ast . Try ): imports . extend ( self . get_imports ( node . finalbody )) return imports ismodule () property \u00a4 Inherited from NodeMixin. Always True. Returns: Type Description bool Whether this object is a module. Source code in dependenpy/dsm.py 282 283 284 285 286 287 288 289 290 @property def ismodule ( self ) -> bool : \"\"\" Inherited from NodeMixin. Always True. Returns: Whether this object is a module. \"\"\" return True parse_code () \u00a4 Read the source code and return all the import statements. Returns: Type Description list [ dict ] list of dict: the import statements. Source code in dependenpy/dsm.py 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 def parse_code ( self ) -> list [ dict ]: \"\"\" Read the source code and return all the import statements. Returns: list of dict: the import statements. \"\"\" code = Path ( self . path ) . read_text ( encoding = \"utf-8\" ) try : body = ast . parse ( code ) . body except SyntaxError : code = code . encode ( \"utf-8\" ) # type: ignore[assignment] try : # noqa: WPS505 body = ast . parse ( code ) . body except SyntaxError : return [] return self . get_imports ( body ) Package \u00a4 Bases: RootNode , LeafNode , NodeMixin , PrintMixin Package class. This class represent Python packages as nodes in a tree. Source code in dependenpy/dsm.py 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 class Package ( RootNode , LeafNode , NodeMixin , PrintMixin ): # noqa: WPS215 \"\"\" Package class. This class represent Python packages as nodes in a tree. \"\"\" def __init__ ( self , name : str , path : str , dsm : DSM = None , package : \"Package\" = None , limit_to : List [ str ] = None , build_tree : bool = True , build_dependencies : bool = True , enforce_init : bool = True , ): \"\"\" Initialization method. Args: name: name of the package. path: path to the package. dsm: parent DSM. package: parent package. limit_to: list of string to limit the recursive tree-building to what is specified. build_tree: auto-build the tree or not. build_dependencies: auto-build the dependencies or not. enforce_init: if True, only treat directories if they contain an `__init__.py` file. \"\"\" self . name = name self . path = path self . package = package self . dsm = dsm self . limit_to = limit_to or [] self . enforce_init = enforce_init RootNode . __init__ ( self , build_tree ) # noqa: WPS609 LeafNode . __init__ ( self ) # noqa: WPS609 if build_tree and build_dependencies : self . build_dependencies () @property def ispackage ( self ) -> bool : \"\"\" Inherited from NodeMixin. Always True. Returns: Whether this object is a package. \"\"\" return True @property def issubpackage ( self ) -> bool : \"\"\" Property to tell if this node is a sub-package. Returns: This package has a parent. \"\"\" return self . package is not None @property def isroot ( self ) -> bool : \"\"\" Property to tell if this node is a root node. Returns: This package has no parent. \"\"\" return self . package is None def split_limits_heads ( self ) -> tuple [ list [ str ], list [ str ]]: \"\"\" Return first parts of dot-separated strings, and rest of strings. Returns: The heads and rest of the strings. \"\"\" heads = [] new_limit_to = [] for limit in self . limit_to : if \".\" in limit : name , limit = limit . split ( \".\" , 1 ) # noqa: WPS440 heads . append ( name ) new_limit_to . append ( limit ) else : heads . append ( limit ) return heads , new_limit_to def build_tree ( self ): # noqa: WPS231 \"\"\"Build the tree for this package.\"\"\" for module in listdir ( self . path ): abs_m = join ( self . path , module ) if isfile ( abs_m ) and module . endswith ( \".py\" ): name = splitext ( module )[ 0 ] if not self . limit_to or name in self . limit_to : self . modules . append ( Module ( name , abs_m , self . dsm , self )) elif isdir ( abs_m ): if isfile ( join ( abs_m , \"__init__.py\" )) or not self . enforce_init : heads , new_limit_to = self . split_limits_heads () if not heads or module in heads : self . packages . append ( Package ( module , abs_m , self . dsm , self , new_limit_to , build_tree = True , build_dependencies = False , enforce_init = self . enforce_init , ) ) def cardinal ( self , to ) -> int : \"\"\" Return the number of dependencies of this package to the given node. Args: to (Package/Module): target node. Returns: Number of dependencies. \"\"\" return sum ( module . cardinal ( to ) for module in self . submodules ) __init__ ( name , path , dsm = None , package = None , limit_to = None , build_tree = True , build_dependencies = True , enforce_init = True ) \u00a4 Initialization method. Parameters: Name Type Description Default name str name of the package. required path str path to the package. required dsm DSM parent DSM. None package 'Package' parent package. None limit_to List [ str ] list of string to limit the recursive tree-building to what is specified. None build_tree bool auto-build the tree or not. True build_dependencies bool auto-build the dependencies or not. True enforce_init bool if True, only treat directories if they contain an __init__.py file. True Source code in dependenpy/dsm.py 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 def __init__ ( self , name : str , path : str , dsm : DSM = None , package : \"Package\" = None , limit_to : List [ str ] = None , build_tree : bool = True , build_dependencies : bool = True , enforce_init : bool = True , ): \"\"\" Initialization method. Args: name: name of the package. path: path to the package. dsm: parent DSM. package: parent package. limit_to: list of string to limit the recursive tree-building to what is specified. build_tree: auto-build the tree or not. build_dependencies: auto-build the dependencies or not. enforce_init: if True, only treat directories if they contain an `__init__.py` file. \"\"\" self . name = name self . path = path self . package = package self . dsm = dsm self . limit_to = limit_to or [] self . enforce_init = enforce_init RootNode . __init__ ( self , build_tree ) # noqa: WPS609 LeafNode . __init__ ( self ) # noqa: WPS609 if build_tree and build_dependencies : self . build_dependencies () build_tree () \u00a4 Build the tree for this package. Source code in dependenpy/dsm.py 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 def build_tree ( self ): # noqa: WPS231 \"\"\"Build the tree for this package.\"\"\" for module in listdir ( self . path ): abs_m = join ( self . path , module ) if isfile ( abs_m ) and module . endswith ( \".py\" ): name = splitext ( module )[ 0 ] if not self . limit_to or name in self . limit_to : self . modules . append ( Module ( name , abs_m , self . dsm , self )) elif isdir ( abs_m ): if isfile ( join ( abs_m , \"__init__.py\" )) or not self . enforce_init : heads , new_limit_to = self . split_limits_heads () if not heads or module in heads : self . packages . append ( Package ( module , abs_m , self . dsm , self , new_limit_to , build_tree = True , build_dependencies = False , enforce_init = self . enforce_init , ) ) cardinal ( to ) \u00a4 Return the number of dependencies of this package to the given node. Parameters: Name Type Description Default to Package/Module target node. required Returns: Type Description int Number of dependencies. Source code in dependenpy/dsm.py 226 227 228 229 230 231 232 233 234 235 236 def cardinal ( self , to ) -> int : \"\"\" Return the number of dependencies of this package to the given node. Args: to (Package/Module): target node. Returns: Number of dependencies. \"\"\" return sum ( module . cardinal ( to ) for module in self . submodules ) ispackage () property \u00a4 Inherited from NodeMixin. Always True. Returns: Type Description bool Whether this object is a package. Source code in dependenpy/dsm.py 153 154 155 156 157 158 159 160 161 @property def ispackage ( self ) -> bool : \"\"\" Inherited from NodeMixin. Always True. Returns: Whether this object is a package. \"\"\" return True isroot () property \u00a4 Property to tell if this node is a root node. Returns: Type Description bool This package has no parent. Source code in dependenpy/dsm.py 173 174 175 176 177 178 179 180 181 @property def isroot ( self ) -> bool : \"\"\" Property to tell if this node is a root node. Returns: This package has no parent. \"\"\" return self . package is None issubpackage () property \u00a4 Property to tell if this node is a sub-package. Returns: Type Description bool This package has a parent. Source code in dependenpy/dsm.py 163 164 165 166 167 168 169 170 171 @property def issubpackage ( self ) -> bool : \"\"\" Property to tell if this node is a sub-package. Returns: This package has a parent. \"\"\" return self . package is not None split_limits_heads () \u00a4 Return first parts of dot-separated strings, and rest of strings. Returns: Type Description tuple [ list [ str ], list [ str ]] The heads and rest of the strings. Source code in dependenpy/dsm.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 def split_limits_heads ( self ) -> tuple [ list [ str ], list [ str ]]: \"\"\" Return first parts of dot-separated strings, and rest of strings. Returns: The heads and rest of the strings. \"\"\" heads = [] new_limit_to = [] for limit in self . limit_to : if \".\" in limit : name , limit = limit . split ( \".\" , 1 ) # noqa: WPS440 heads . append ( name ) new_limit_to . append ( limit ) else : heads . append ( limit ) return heads , new_limit_to TreeMap \u00a4 Bases: PrintMixin TreeMap class. Source code in dependenpy/structures.py 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 class TreeMap ( PrintMixin ): \"\"\"TreeMap class.\"\"\" def __init__ ( self , * nodes : Any , value : int = - 1 ): \"\"\" Initialization method. Arguments: *nodes: the nodes from which to build the treemap. value: the value of the current area. \"\"\" # if nodes: # matrix_lower_level = Matrix(*nodes, depth=2) # matrix_current_level = Matrix(*nodes, depth=1) # if value == -1: # value = sum(c for row in matrix_current_level.data for c in row) # splits = [0] # key_comp = matrix_lower_level.keys[0].split('.')[0] # i = 1 # for key in matrix_lower_level.keys[1:]: # key = key.split('.')[0] # if key != key_comp: # splits.append(i) # key_comp = key # i += 1 # splits.append(i) # # self.data = [] # for i in range(len(splits) - 1): # self.data.append([]) # rows = matrix_lower_level.data[splits[i]:splits[i+1]] # for j in range(len(splits) - 1): # self.data[i].append([row[splits[j]:splits[j+1]] for row in rows]) self . value = value def _to_csv ( self , ** kwargs ): return \"\" def _to_json ( self , ** kwargs ): return \"\" def _to_text ( self , ** kwargs ): return \"\" __init__ ( * nodes , value =- 1 ) \u00a4 Initialization method. Parameters: Name Type Description Default *nodes Any the nodes from which to build the treemap. () value int the value of the current area. -1 Source code in dependenpy/structures.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 def __init__ ( self , * nodes : Any , value : int = - 1 ): \"\"\" Initialization method. Arguments: *nodes: the nodes from which to build the treemap. value: the value of the current area. \"\"\" # if nodes: # matrix_lower_level = Matrix(*nodes, depth=2) # matrix_current_level = Matrix(*nodes, depth=1) # if value == -1: # value = sum(c for row in matrix_current_level.data for c in row) # splits = [0] # key_comp = matrix_lower_level.keys[0].split('.')[0] # i = 1 # for key in matrix_lower_level.keys[1:]: # key = key.split('.')[0] # if key != key_comp: # splits.append(i) # key_comp = key # i += 1 # splits.append(i) # # self.data = [] # for i in range(len(splits) - 1): # self.data.append([]) # rows = matrix_lower_level.data[splits[i]:splits[i+1]] # for j in range(len(splits) - 1): # self.data[i].append([row[splits[j]:splits[j+1]] for row in rows]) self . value = value","title":"dependenpy"},{"location":"reference/dependenpy/#dependenpy.DSM","text":"Bases: RootNode , NodeMixin , PrintMixin DSM-capable class. Technically speaking, a DSM instance is not a real DSM but more a tree representing the Python packages structure. However, it has the necessary methods to build a real DSM in the form of a square matrix, a dictionary or a tree-map. Source code in dependenpy/dsm.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 class DSM ( RootNode , NodeMixin , PrintMixin ): \"\"\" DSM-capable class. Technically speaking, a DSM instance is not a real DSM but more a tree representing the Python packages structure. However, it has the necessary methods to build a real DSM in the form of a square matrix, a dictionary or a tree-map. \"\"\" def __init__ ( self , * packages : str , build_tree : bool = True , build_dependencies : bool = True , enforce_init : bool = True ): \"\"\" Initialization method. Args: *packages: list of packages to search for. build_tree: auto-build the tree or not. build_dependencies: auto-build the dependencies or not. enforce_init: if True, only treat directories if they contain an `__init__.py` file. \"\"\" self . base_packages = packages self . finder = Finder () self . specs = [] self . not_found = [] self . enforce_init = enforce_init specs = [] for package in packages : spec = self . finder . find ( package , enforce_init = enforce_init ) if spec : specs . append ( spec ) else : self . not_found . append ( package ) if not specs : print ( \"** dependenpy: DSM empty.\" , file = sys . stderr ) self . specs = PackageSpec . combine ( specs ) for module in self . not_found : print ( f \"** dependenpy: Not found: { module } .\" , file = sys . stderr ) super () . __init__ ( build_tree ) if build_tree and build_dependencies : self . build_dependencies () def __str__ ( self ): packages_names = \", \" . join ([ package . name for package in self . packages ]) return f \"Dependency DSM for packages: [ { packages_names } ]\" @property def isdsm ( self ) -> bool : \"\"\" Inherited from NodeMixin. Always True. Returns: Whether this object is a DSM. \"\"\" return True def build_tree ( self ): \"\"\"Build the Python packages tree.\"\"\" for spec in self . specs : if spec . ismodule : self . modules . append ( Module ( spec . name , spec . path , dsm = self )) else : self . packages . append ( Package ( spec . name , spec . path , dsm = self , limit_to = spec . limit_to , build_tree = True , build_dependencies = False , enforce_init = self . enforce_init , ) )","title":"DSM"},{"location":"reference/dependenpy/#dependenpy.dsm.DSM.__init__","text":"Initialization method. Parameters: Name Type Description Default *packages str list of packages to search for. () build_tree bool auto-build the tree or not. True build_dependencies bool auto-build the dependencies or not. True enforce_init bool if True, only treat directories if they contain an __init__.py file. True Source code in dependenpy/dsm.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def __init__ ( self , * packages : str , build_tree : bool = True , build_dependencies : bool = True , enforce_init : bool = True ): \"\"\" Initialization method. Args: *packages: list of packages to search for. build_tree: auto-build the tree or not. build_dependencies: auto-build the dependencies or not. enforce_init: if True, only treat directories if they contain an `__init__.py` file. \"\"\" self . base_packages = packages self . finder = Finder () self . specs = [] self . not_found = [] self . enforce_init = enforce_init specs = [] for package in packages : spec = self . finder . find ( package , enforce_init = enforce_init ) if spec : specs . append ( spec ) else : self . not_found . append ( package ) if not specs : print ( \"** dependenpy: DSM empty.\" , file = sys . stderr ) self . specs = PackageSpec . combine ( specs ) for module in self . not_found : print ( f \"** dependenpy: Not found: { module } .\" , file = sys . stderr ) super () . __init__ ( build_tree ) if build_tree and build_dependencies : self . build_dependencies ()","title":"__init__()"},{"location":"reference/dependenpy/#dependenpy.dsm.DSM.build_tree","text":"Build the Python packages tree. Source code in dependenpy/dsm.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def build_tree ( self ): \"\"\"Build the Python packages tree.\"\"\" for spec in self . specs : if spec . ismodule : self . modules . append ( Module ( spec . name , spec . path , dsm = self )) else : self . packages . append ( Package ( spec . name , spec . path , dsm = self , limit_to = spec . limit_to , build_tree = True , build_dependencies = False , enforce_init = self . enforce_init , ) )","title":"build_tree()"},{"location":"reference/dependenpy/#dependenpy.dsm.DSM.isdsm","text":"Inherited from NodeMixin. Always True. Returns: Type Description bool Whether this object is a DSM. Source code in dependenpy/dsm.py 80 81 82 83 84 85 86 87 88 @property def isdsm ( self ) -> bool : \"\"\" Inherited from NodeMixin. Always True. Returns: Whether this object is a DSM. \"\"\" return True","title":"isdsm()"},{"location":"reference/dependenpy/#dependenpy.Dependency","text":"Bases: object Dependency class. Represent a dependency from a module to another. Source code in dependenpy/dsm.py 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 class Dependency ( object ): \"\"\" Dependency class. Represent a dependency from a module to another. \"\"\" def __init__ ( self , source , lineno , target , what = None ): \"\"\" Initialization method. Args: source (Module): source Module. lineno (int): number of line at which import statement occurs. target (str/Module/Package): the target node. what (str): what is imported (optional). \"\"\" self . source = source self . lineno = lineno self . target = target self . what = what def __str__ ( self ): what = f \" { self . what or '' } from \" target = self . target if self . external else self . target . absolute_name () return f \" { self . source . name } imports { what }{ target } (line { self . lineno } )\" @property def external ( self ) -> bool : \"\"\" Property to tell if the dependency's target is a valid node. Returns: Whether the dependency's target is a valid node. \"\"\" return isinstance ( self . target , str )","title":"Dependency"},{"location":"reference/dependenpy/#dependenpy.dsm.Dependency.__init__","text":"Initialization method. Parameters: Name Type Description Default source Module source Module. required lineno int number of line at which import statement occurs. required target str/Module/Package the target node. required what str what is imported (optional). None Source code in dependenpy/dsm.py 426 427 428 429 430 431 432 433 434 435 436 437 438 439 def __init__ ( self , source , lineno , target , what = None ): \"\"\" Initialization method. Args: source (Module): source Module. lineno (int): number of line at which import statement occurs. target (str/Module/Package): the target node. what (str): what is imported (optional). \"\"\" self . source = source self . lineno = lineno self . target = target self . what = what","title":"__init__()"},{"location":"reference/dependenpy/#dependenpy.dsm.Dependency.external","text":"Property to tell if the dependency's target is a valid node. Returns: Type Description bool Whether the dependency's target is a valid node. Source code in dependenpy/dsm.py 446 447 448 449 450 451 452 453 454 @property def external ( self ) -> bool : \"\"\" Property to tell if the dependency's target is a valid node. Returns: Whether the dependency's target is a valid node. \"\"\" return isinstance ( self . target , str )","title":"external()"},{"location":"reference/dependenpy/#dependenpy.Matrix","text":"Bases: PrintMixin Matrix class. A class to build a matrix given a list of nodes. After instantiation, it has two attributes: data, a 2-dimensions array, and keys, the names of the entities in the corresponding order. Source code in dependenpy/structures.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 class Matrix ( PrintMixin ): \"\"\" Matrix class. A class to build a matrix given a list of nodes. After instantiation, it has two attributes: data, a 2-dimensions array, and keys, the names of the entities in the corresponding order. \"\"\" def __init__ ( self , * nodes : DSM | Package | Module , depth : int = 0 ): # noqa: WPS231 \"\"\" Initialization method. Args: *nodes: The nodes on which to build the matrix. depth: The depth of the matrix. This depth is always absolute, meaning that building a matrix with a sub-package \"A.B.C\" and a depth of 1 will return a matrix of size 1, containing A only. To see the matrix for the sub-modules and sub-packages in C, you will have to give depth=4. \"\"\" modules : list [ Module ] = [] for node in nodes : if node . ismodule : modules . append ( node ) # type: ignore[arg-type] elif node . ispackage or node . isdsm : modules . extend ( node . submodules ) # type: ignore[union-attr] if depth < 1 : keys = modules else : keys = [] for module in modules : if module . depth <= depth : keys . append ( module ) continue package = module . package while package . depth > depth and package . package and package not in nodes : package = package . package if package not in keys : keys . append ( package ) size = len ( keys ) data = [[ 0 ] * size for _ in range ( size )] # noqa: WPS435 keys = sorted ( keys , key = lambda key : key . absolute_name ()) if depth < 1 : for index , key in enumerate ( keys ): # noqa: WPS440 key . index = index # type: ignore[attr-defined] for index , key in enumerate ( keys ): # noqa: WPS440 for dep in key . dependencies : if dep . external : continue if dep . target . ismodule and dep . target in keys : data [ index ][ dep . target . index ] += 1 elif dep . target . ispackage : init = dep . target . get ( \"__init__\" ) if init is not None and init in keys : data [ index ][ init . index ] += 1 else : for row , row_key in enumerate ( keys ): for col , col_key in enumerate ( keys ): data [ row ][ col ] = row_key . cardinal ( to = col_key ) self . size = size self . keys = [ key . absolute_name () for key in keys ] # noqa: WPS441 self . data = data @staticmethod # noqa: WPS602 def cast ( keys : list [ str ], data : list [ list [ int ]]) -> Matrix : # noqa: WPS602 \"\"\" Cast a set of keys and an array to a Matrix object. Arguments: keys: The matrix keys. data: The matrix data. Returns: A new matrix. \"\"\" matrix = Matrix () matrix . keys = copy . deepcopy ( keys ) matrix . data = copy . deepcopy ( data ) return matrix @property def total ( self ) -> int : \"\"\" Return the total number of dependencies within this matrix. Returns: The total number of dependencies. \"\"\" return sum ( cell for line in self . data for cell in line ) def _to_csv ( self , ** kwargs ): text = [ \"module,\" , \",\" . join ( self . keys )] for index , key in enumerate ( self . keys ): line = \",\" . join ( map ( str , self . data [ index ])) text . append ( f \" { key } , { line } \" ) return \" \\n \" . join ( text ) def _to_json ( self , ** kwargs ): return json . dumps ({ \"keys\" : self . keys , \"data\" : self . data }, ** kwargs ) def _to_text ( self , ** kwargs ): if not self . keys or not self . data : return \"\" zero = kwargs . pop ( \"zero\" , \"0\" ) max_key_length = max ( len ( key ) for key in self . keys + [ \"Module\" ]) max_dep_length = max ([ len ( str ( col )) for line in self . data for col in line ] + [ len ( zero )]) key_col_length = len ( str ( len ( self . keys ))) key_line_length = max ( key_col_length , 2 ) column_length = max ( key_col_length , max_dep_length ) bold = Style . BRIGHT reset = Style . RESET_ALL # first line left headers text = [ f \" \\n { bold }{ 'Module' : > { max_key_length }}{ reset } \u2502 { bold }{ 'Id' : > { key_line_length }}{ reset } \u2502\" ] # first line column headers for index , _ in enumerate ( self . keys ): text . append ( f \" { bold }{ index : ^ { column_length }}{ reset } \u2502\" ) text . append ( \" \\n \" ) # line of dashes text . append ( f \" { '\u2500' * max_key_length } \u2500\u253c\u2500 { '\u2500' * key_line_length } \u2500\u253c\" ) for _ in range ( len ( self . keys ) - 1 ): text . append ( f \" { '\u2500' * column_length } \u253c\" ) text . append ( f \" { '\u2500' * column_length } \u2524\" ) text . append ( \" \\n \" ) # lines for index , key in enumerate ( self . keys ): # noqa: WPS440 text . append ( f \" { key : > { max_key_length }} \u2502 { bold }{ index : > { key_line_length }}{ reset } \u2502\" ) for value in self . data [ index ]: text . append (( f \" { value if value else zero : > { column_length }} \u2502\" )) text . append ( \" \\n \" ) text . append ( \" \\n \" ) return \"\" . join ( text )","title":"Matrix"},{"location":"reference/dependenpy/#dependenpy.structures.Matrix.__init__","text":"Initialization method. Parameters: Name Type Description Default *nodes DSM | Package | Module The nodes on which to build the matrix. () depth int The depth of the matrix. This depth is always absolute, meaning that building a matrix with a sub-package \"A.B.C\" and a depth of 1 will return a matrix of size 1, containing A only. To see the matrix for the sub-modules and sub-packages in C, you will have to give depth=4. 0 Source code in dependenpy/structures.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def __init__ ( self , * nodes : DSM | Package | Module , depth : int = 0 ): # noqa: WPS231 \"\"\" Initialization method. Args: *nodes: The nodes on which to build the matrix. depth: The depth of the matrix. This depth is always absolute, meaning that building a matrix with a sub-package \"A.B.C\" and a depth of 1 will return a matrix of size 1, containing A only. To see the matrix for the sub-modules and sub-packages in C, you will have to give depth=4. \"\"\" modules : list [ Module ] = [] for node in nodes : if node . ismodule : modules . append ( node ) # type: ignore[arg-type] elif node . ispackage or node . isdsm : modules . extend ( node . submodules ) # type: ignore[union-attr] if depth < 1 : keys = modules else : keys = [] for module in modules : if module . depth <= depth : keys . append ( module ) continue package = module . package while package . depth > depth and package . package and package not in nodes : package = package . package if package not in keys : keys . append ( package ) size = len ( keys ) data = [[ 0 ] * size for _ in range ( size )] # noqa: WPS435 keys = sorted ( keys , key = lambda key : key . absolute_name ()) if depth < 1 : for index , key in enumerate ( keys ): # noqa: WPS440 key . index = index # type: ignore[attr-defined] for index , key in enumerate ( keys ): # noqa: WPS440 for dep in key . dependencies : if dep . external : continue if dep . target . ismodule and dep . target in keys : data [ index ][ dep . target . index ] += 1 elif dep . target . ispackage : init = dep . target . get ( \"__init__\" ) if init is not None and init in keys : data [ index ][ init . index ] += 1 else : for row , row_key in enumerate ( keys ): for col , col_key in enumerate ( keys ): data [ row ][ col ] = row_key . cardinal ( to = col_key ) self . size = size self . keys = [ key . absolute_name () for key in keys ] # noqa: WPS441 self . data = data","title":"__init__()"},{"location":"reference/dependenpy/#dependenpy.structures.Matrix.cast","text":"Cast a set of keys and an array to a Matrix object. Parameters: Name Type Description Default keys list [ str ] The matrix keys. required data list [ list [ int ]] The matrix data. required Returns: Type Description Matrix A new matrix. Source code in dependenpy/structures.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 @staticmethod # noqa: WPS602 def cast ( keys : list [ str ], data : list [ list [ int ]]) -> Matrix : # noqa: WPS602 \"\"\" Cast a set of keys and an array to a Matrix object. Arguments: keys: The matrix keys. data: The matrix data. Returns: A new matrix. \"\"\" matrix = Matrix () matrix . keys = copy . deepcopy ( keys ) matrix . data = copy . deepcopy ( data ) return matrix","title":"cast()"},{"location":"reference/dependenpy/#dependenpy.structures.Matrix.total","text":"Return the total number of dependencies within this matrix. Returns: Type Description int The total number of dependencies. Source code in dependenpy/structures.py 102 103 104 105 106 107 108 109 110 @property def total ( self ) -> int : \"\"\" Return the total number of dependencies within this matrix. Returns: The total number of dependencies. \"\"\" return sum ( cell for line in self . data for cell in line )","title":"total()"},{"location":"reference/dependenpy/#dependenpy.Module","text":"Bases: LeafNode , NodeMixin , PrintMixin Module class. This class represents a Python module (a Python file). Source code in dependenpy/dsm.py 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 class Module ( LeafNode , NodeMixin , PrintMixin ): # noqa: WPS338 \"\"\" Module class. This class represents a Python module (a Python file). \"\"\" RECURSIVE_NODES = ( ast . ClassDef , ast . FunctionDef , ast . If , ast . IfExp , ast . Try , ast . With , ast . ExceptHandler ) def __init__ ( self , name , path , dsm = None , package = None ): \"\"\" Initialization method. Args: name (str): name of the module. path (str): path to the module. dsm (DSM): parent DSM. package (Package): parent Package. \"\"\" super () . __init__ () self . name = name self . path = path self . package = package self . dsm = dsm self . dependencies = [] def __contains__ ( self , item ) -> bool : \"\"\" Whether given item is contained inside this module. Args: item (Package/Module): a package or module. Returns: True if self is item or item is self's package and self if an `__init__` module. \"\"\" if self is item : return True elif self . package is item and self . name == \"__init__\" : return True return False @property def ismodule ( self ) -> bool : \"\"\" Inherited from NodeMixin. Always True. Returns: Whether this object is a module. \"\"\" return True def as_dict ( self , absolute : bool = False ) -> dict : \"\"\" Return the dependencies as a dictionary. Arguments: absolute: Whether to use the absolute name. Returns: dict: dictionary of dependencies. \"\"\" return { \"name\" : self . absolute_name () if absolute else self . name , \"path\" : self . path , \"dependencies\" : [ { # 'source': d.source.absolute_name(), # redundant \"target\" : dep . target if dep . external else dep . target . absolute_name (), \"lineno\" : dep . lineno , \"what\" : dep . what , \"external\" : dep . external , } for dep in self . dependencies ], } def _to_text ( self , ** kwargs ): indent = kwargs . pop ( \"indent\" , 2 ) base_indent = kwargs . pop ( \"base_indent\" , None ) if base_indent is None : base_indent = indent indent = 0 text = [ \" \" * indent + self . name + \" \\n \" ] new_indent = indent + base_indent for dep in self . dependencies : external = \"! \" if dep . external else \"\" text . append ( \" \" * new_indent + external + str ( dep ) + \" \\n \" ) return \"\" . join ( text ) def _to_csv ( self , ** kwargs ): header = kwargs . pop ( \"header\" , True ) text = [ \"module,path,target,lineno,what,external \\n \" if header else \"\" ] name = self . absolute_name () for dep in self . dependencies : target = dep . target if dep . external else dep . target . absolute_name () text . append ( f \" { name } , { self . path } , { target } , { dep . lineno } , { dep . what or '' } , { dep . external } \\n \" ) return \"\" . join ( text ) def _to_json ( self , ** kwargs ): absolute = kwargs . pop ( \"absolute\" , False ) return json . dumps ( self . as_dict ( absolute = absolute ), ** kwargs ) def build_dependencies ( self ): \"\"\" Build the dependencies for this module. Parse the code with ast, find all the import statements, convert them into Dependency objects. \"\"\" highest = self . dsm or self . root if self is highest : highest = LeafNode () for import_ in self . parse_code (): target = highest . get_target ( import_ [ \"target\" ]) if target : what = import_ [ \"target\" ] . split ( \".\" )[ - 1 ] if what != target . name : import_ [ \"what\" ] = what import_ [ \"target\" ] = target self . dependencies . append ( Dependency ( source = self , ** import_ )) def parse_code ( self ) -> list [ dict ]: \"\"\" Read the source code and return all the import statements. Returns: list of dict: the import statements. \"\"\" code = Path ( self . path ) . read_text ( encoding = \"utf-8\" ) try : body = ast . parse ( code ) . body except SyntaxError : code = code . encode ( \"utf-8\" ) # type: ignore[assignment] try : # noqa: WPS505 body = ast . parse ( code ) . body except SyntaxError : return [] return self . get_imports ( body ) def get_imports ( self , ast_body ) -> list [ dict ]: # noqa: WPS231,WPS615 \"\"\" Return all the import statements given an AST body (AST nodes). Args: ast_body (compiled code's body): the body to filter. Returns: The import statements. \"\"\" imports : list [ dict ] = [] for node in ast_body : if isinstance ( node , ast . Import ): imports . extend ({ \"target\" : name . name , \"lineno\" : node . lineno } for name in node . names ) elif isinstance ( node , ast . ImportFrom ): for name in node . names : abs_name = self . absolute_name ( self . depth - node . level ) + \".\" if node . level > 0 else \"\" node_module = node . module + \".\" if node . module else \"\" name = abs_name + node_module + name . name # type: ignore[assignment] imports . append ({ \"target\" : name , \"lineno\" : node . lineno }) elif isinstance ( node , Module . RECURSIVE_NODES ): imports . extend ( self . get_imports ( node . body )) if isinstance ( node , ast . Try ): imports . extend ( self . get_imports ( node . finalbody )) return imports def cardinal ( self , to ) -> int : \"\"\" Return the number of dependencies of this module to the given node. Args: to (Package/Module): the target node. Returns: Number of dependencies. \"\"\" return len ([ dep for dep in self . dependencies if not dep . external and dep . target in to ])","title":"Module"},{"location":"reference/dependenpy/#dependenpy.dsm.Module.__contains__","text":"Whether given item is contained inside this module. Parameters: Name Type Description Default item Package/Module a package or module. required Returns: Type Description bool True if self is item or item is self's package and self if an __init__ module. Source code in dependenpy/dsm.py 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 def __contains__ ( self , item ) -> bool : \"\"\" Whether given item is contained inside this module. Args: item (Package/Module): a package or module. Returns: True if self is item or item is self's package and self if an `__init__` module. \"\"\" if self is item : return True elif self . package is item and self . name == \"__init__\" : return True return False","title":"__contains__()"},{"location":"reference/dependenpy/#dependenpy.dsm.Module.__init__","text":"Initialization method. Parameters: Name Type Description Default name str name of the module. required path str path to the module. required dsm DSM parent DSM. None package Package parent Package. None Source code in dependenpy/dsm.py 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 def __init__ ( self , name , path , dsm = None , package = None ): \"\"\" Initialization method. Args: name (str): name of the module. path (str): path to the module. dsm (DSM): parent DSM. package (Package): parent Package. \"\"\" super () . __init__ () self . name = name self . path = path self . package = package self . dsm = dsm self . dependencies = []","title":"__init__()"},{"location":"reference/dependenpy/#dependenpy.dsm.Module.as_dict","text":"Return the dependencies as a dictionary. Parameters: Name Type Description Default absolute bool Whether to use the absolute name. False Returns: Name Type Description dict dict dictionary of dependencies. Source code in dependenpy/dsm.py 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 def as_dict ( self , absolute : bool = False ) -> dict : \"\"\" Return the dependencies as a dictionary. Arguments: absolute: Whether to use the absolute name. Returns: dict: dictionary of dependencies. \"\"\" return { \"name\" : self . absolute_name () if absolute else self . name , \"path\" : self . path , \"dependencies\" : [ { # 'source': d.source.absolute_name(), # redundant \"target\" : dep . target if dep . external else dep . target . absolute_name (), \"lineno\" : dep . lineno , \"what\" : dep . what , \"external\" : dep . external , } for dep in self . dependencies ], }","title":"as_dict()"},{"location":"reference/dependenpy/#dependenpy.dsm.Module.build_dependencies","text":"Build the dependencies for this module. Parse the code with ast, find all the import statements, convert them into Dependency objects. Source code in dependenpy/dsm.py 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 def build_dependencies ( self ): \"\"\" Build the dependencies for this module. Parse the code with ast, find all the import statements, convert them into Dependency objects. \"\"\" highest = self . dsm or self . root if self is highest : highest = LeafNode () for import_ in self . parse_code (): target = highest . get_target ( import_ [ \"target\" ]) if target : what = import_ [ \"target\" ] . split ( \".\" )[ - 1 ] if what != target . name : import_ [ \"what\" ] = what import_ [ \"target\" ] = target self . dependencies . append ( Dependency ( source = self , ** import_ ))","title":"build_dependencies()"},{"location":"reference/dependenpy/#dependenpy.dsm.Module.cardinal","text":"Return the number of dependencies of this module to the given node. Parameters: Name Type Description Default to Package/Module the target node. required Returns: Type Description int Number of dependencies. Source code in dependenpy/dsm.py 406 407 408 409 410 411 412 413 414 415 416 def cardinal ( self , to ) -> int : \"\"\" Return the number of dependencies of this module to the given node. Args: to (Package/Module): the target node. Returns: Number of dependencies. \"\"\" return len ([ dep for dep in self . dependencies if not dep . external and dep . target in to ])","title":"cardinal()"},{"location":"reference/dependenpy/#dependenpy.dsm.Module.get_imports","text":"Return all the import statements given an AST body (AST nodes). Parameters: Name Type Description Default ast_body compiled code's body the body to filter. required Returns: Type Description list [ dict ] The import statements. Source code in dependenpy/dsm.py 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 def get_imports ( self , ast_body ) -> list [ dict ]: # noqa: WPS231,WPS615 \"\"\" Return all the import statements given an AST body (AST nodes). Args: ast_body (compiled code's body): the body to filter. Returns: The import statements. \"\"\" imports : list [ dict ] = [] for node in ast_body : if isinstance ( node , ast . Import ): imports . extend ({ \"target\" : name . name , \"lineno\" : node . lineno } for name in node . names ) elif isinstance ( node , ast . ImportFrom ): for name in node . names : abs_name = self . absolute_name ( self . depth - node . level ) + \".\" if node . level > 0 else \"\" node_module = node . module + \".\" if node . module else \"\" name = abs_name + node_module + name . name # type: ignore[assignment] imports . append ({ \"target\" : name , \"lineno\" : node . lineno }) elif isinstance ( node , Module . RECURSIVE_NODES ): imports . extend ( self . get_imports ( node . body )) if isinstance ( node , ast . Try ): imports . extend ( self . get_imports ( node . finalbody )) return imports","title":"get_imports()"},{"location":"reference/dependenpy/#dependenpy.dsm.Module.ismodule","text":"Inherited from NodeMixin. Always True. Returns: Type Description bool Whether this object is a module. Source code in dependenpy/dsm.py 282 283 284 285 286 287 288 289 290 @property def ismodule ( self ) -> bool : \"\"\" Inherited from NodeMixin. Always True. Returns: Whether this object is a module. \"\"\" return True","title":"ismodule()"},{"location":"reference/dependenpy/#dependenpy.dsm.Module.parse_code","text":"Read the source code and return all the import statements. Returns: Type Description list [ dict ] list of dict: the import statements. Source code in dependenpy/dsm.py 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 def parse_code ( self ) -> list [ dict ]: \"\"\" Read the source code and return all the import statements. Returns: list of dict: the import statements. \"\"\" code = Path ( self . path ) . read_text ( encoding = \"utf-8\" ) try : body = ast . parse ( code ) . body except SyntaxError : code = code . encode ( \"utf-8\" ) # type: ignore[assignment] try : # noqa: WPS505 body = ast . parse ( code ) . body except SyntaxError : return [] return self . get_imports ( body )","title":"parse_code()"},{"location":"reference/dependenpy/#dependenpy.Package","text":"Bases: RootNode , LeafNode , NodeMixin , PrintMixin Package class. This class represent Python packages as nodes in a tree. Source code in dependenpy/dsm.py 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 class Package ( RootNode , LeafNode , NodeMixin , PrintMixin ): # noqa: WPS215 \"\"\" Package class. This class represent Python packages as nodes in a tree. \"\"\" def __init__ ( self , name : str , path : str , dsm : DSM = None , package : \"Package\" = None , limit_to : List [ str ] = None , build_tree : bool = True , build_dependencies : bool = True , enforce_init : bool = True , ): \"\"\" Initialization method. Args: name: name of the package. path: path to the package. dsm: parent DSM. package: parent package. limit_to: list of string to limit the recursive tree-building to what is specified. build_tree: auto-build the tree or not. build_dependencies: auto-build the dependencies or not. enforce_init: if True, only treat directories if they contain an `__init__.py` file. \"\"\" self . name = name self . path = path self . package = package self . dsm = dsm self . limit_to = limit_to or [] self . enforce_init = enforce_init RootNode . __init__ ( self , build_tree ) # noqa: WPS609 LeafNode . __init__ ( self ) # noqa: WPS609 if build_tree and build_dependencies : self . build_dependencies () @property def ispackage ( self ) -> bool : \"\"\" Inherited from NodeMixin. Always True. Returns: Whether this object is a package. \"\"\" return True @property def issubpackage ( self ) -> bool : \"\"\" Property to tell if this node is a sub-package. Returns: This package has a parent. \"\"\" return self . package is not None @property def isroot ( self ) -> bool : \"\"\" Property to tell if this node is a root node. Returns: This package has no parent. \"\"\" return self . package is None def split_limits_heads ( self ) -> tuple [ list [ str ], list [ str ]]: \"\"\" Return first parts of dot-separated strings, and rest of strings. Returns: The heads and rest of the strings. \"\"\" heads = [] new_limit_to = [] for limit in self . limit_to : if \".\" in limit : name , limit = limit . split ( \".\" , 1 ) # noqa: WPS440 heads . append ( name ) new_limit_to . append ( limit ) else : heads . append ( limit ) return heads , new_limit_to def build_tree ( self ): # noqa: WPS231 \"\"\"Build the tree for this package.\"\"\" for module in listdir ( self . path ): abs_m = join ( self . path , module ) if isfile ( abs_m ) and module . endswith ( \".py\" ): name = splitext ( module )[ 0 ] if not self . limit_to or name in self . limit_to : self . modules . append ( Module ( name , abs_m , self . dsm , self )) elif isdir ( abs_m ): if isfile ( join ( abs_m , \"__init__.py\" )) or not self . enforce_init : heads , new_limit_to = self . split_limits_heads () if not heads or module in heads : self . packages . append ( Package ( module , abs_m , self . dsm , self , new_limit_to , build_tree = True , build_dependencies = False , enforce_init = self . enforce_init , ) ) def cardinal ( self , to ) -> int : \"\"\" Return the number of dependencies of this package to the given node. Args: to (Package/Module): target node. Returns: Number of dependencies. \"\"\" return sum ( module . cardinal ( to ) for module in self . submodules )","title":"Package"},{"location":"reference/dependenpy/#dependenpy.dsm.Package.__init__","text":"Initialization method. Parameters: Name Type Description Default name str name of the package. required path str path to the package. required dsm DSM parent DSM. None package 'Package' parent package. None limit_to List [ str ] list of string to limit the recursive tree-building to what is specified. None build_tree bool auto-build the tree or not. True build_dependencies bool auto-build the dependencies or not. True enforce_init bool if True, only treat directories if they contain an __init__.py file. True Source code in dependenpy/dsm.py 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 def __init__ ( self , name : str , path : str , dsm : DSM = None , package : \"Package\" = None , limit_to : List [ str ] = None , build_tree : bool = True , build_dependencies : bool = True , enforce_init : bool = True , ): \"\"\" Initialization method. Args: name: name of the package. path: path to the package. dsm: parent DSM. package: parent package. limit_to: list of string to limit the recursive tree-building to what is specified. build_tree: auto-build the tree or not. build_dependencies: auto-build the dependencies or not. enforce_init: if True, only treat directories if they contain an `__init__.py` file. \"\"\" self . name = name self . path = path self . package = package self . dsm = dsm self . limit_to = limit_to or [] self . enforce_init = enforce_init RootNode . __init__ ( self , build_tree ) # noqa: WPS609 LeafNode . __init__ ( self ) # noqa: WPS609 if build_tree and build_dependencies : self . build_dependencies ()","title":"__init__()"},{"location":"reference/dependenpy/#dependenpy.dsm.Package.build_tree","text":"Build the tree for this package. Source code in dependenpy/dsm.py 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 def build_tree ( self ): # noqa: WPS231 \"\"\"Build the tree for this package.\"\"\" for module in listdir ( self . path ): abs_m = join ( self . path , module ) if isfile ( abs_m ) and module . endswith ( \".py\" ): name = splitext ( module )[ 0 ] if not self . limit_to or name in self . limit_to : self . modules . append ( Module ( name , abs_m , self . dsm , self )) elif isdir ( abs_m ): if isfile ( join ( abs_m , \"__init__.py\" )) or not self . enforce_init : heads , new_limit_to = self . split_limits_heads () if not heads or module in heads : self . packages . append ( Package ( module , abs_m , self . dsm , self , new_limit_to , build_tree = True , build_dependencies = False , enforce_init = self . enforce_init , ) )","title":"build_tree()"},{"location":"reference/dependenpy/#dependenpy.dsm.Package.cardinal","text":"Return the number of dependencies of this package to the given node. Parameters: Name Type Description Default to Package/Module target node. required Returns: Type Description int Number of dependencies. Source code in dependenpy/dsm.py 226 227 228 229 230 231 232 233 234 235 236 def cardinal ( self , to ) -> int : \"\"\" Return the number of dependencies of this package to the given node. Args: to (Package/Module): target node. Returns: Number of dependencies. \"\"\" return sum ( module . cardinal ( to ) for module in self . submodules )","title":"cardinal()"},{"location":"reference/dependenpy/#dependenpy.dsm.Package.ispackage","text":"Inherited from NodeMixin. Always True. Returns: Type Description bool Whether this object is a package. Source code in dependenpy/dsm.py 153 154 155 156 157 158 159 160 161 @property def ispackage ( self ) -> bool : \"\"\" Inherited from NodeMixin. Always True. Returns: Whether this object is a package. \"\"\" return True","title":"ispackage()"},{"location":"reference/dependenpy/#dependenpy.dsm.Package.isroot","text":"Property to tell if this node is a root node. Returns: Type Description bool This package has no parent. Source code in dependenpy/dsm.py 173 174 175 176 177 178 179 180 181 @property def isroot ( self ) -> bool : \"\"\" Property to tell if this node is a root node. Returns: This package has no parent. \"\"\" return self . package is None","title":"isroot()"},{"location":"reference/dependenpy/#dependenpy.dsm.Package.issubpackage","text":"Property to tell if this node is a sub-package. Returns: Type Description bool This package has a parent. Source code in dependenpy/dsm.py 163 164 165 166 167 168 169 170 171 @property def issubpackage ( self ) -> bool : \"\"\" Property to tell if this node is a sub-package. Returns: This package has a parent. \"\"\" return self . package is not None","title":"issubpackage()"},{"location":"reference/dependenpy/#dependenpy.dsm.Package.split_limits_heads","text":"Return first parts of dot-separated strings, and rest of strings. Returns: Type Description tuple [ list [ str ], list [ str ]] The heads and rest of the strings. Source code in dependenpy/dsm.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 def split_limits_heads ( self ) -> tuple [ list [ str ], list [ str ]]: \"\"\" Return first parts of dot-separated strings, and rest of strings. Returns: The heads and rest of the strings. \"\"\" heads = [] new_limit_to = [] for limit in self . limit_to : if \".\" in limit : name , limit = limit . split ( \".\" , 1 ) # noqa: WPS440 heads . append ( name ) new_limit_to . append ( limit ) else : heads . append ( limit ) return heads , new_limit_to","title":"split_limits_heads()"},{"location":"reference/dependenpy/#dependenpy.TreeMap","text":"Bases: PrintMixin TreeMap class. Source code in dependenpy/structures.py 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 class TreeMap ( PrintMixin ): \"\"\"TreeMap class.\"\"\" def __init__ ( self , * nodes : Any , value : int = - 1 ): \"\"\" Initialization method. Arguments: *nodes: the nodes from which to build the treemap. value: the value of the current area. \"\"\" # if nodes: # matrix_lower_level = Matrix(*nodes, depth=2) # matrix_current_level = Matrix(*nodes, depth=1) # if value == -1: # value = sum(c for row in matrix_current_level.data for c in row) # splits = [0] # key_comp = matrix_lower_level.keys[0].split('.')[0] # i = 1 # for key in matrix_lower_level.keys[1:]: # key = key.split('.')[0] # if key != key_comp: # splits.append(i) # key_comp = key # i += 1 # splits.append(i) # # self.data = [] # for i in range(len(splits) - 1): # self.data.append([]) # rows = matrix_lower_level.data[splits[i]:splits[i+1]] # for j in range(len(splits) - 1): # self.data[i].append([row[splits[j]:splits[j+1]] for row in rows]) self . value = value def _to_csv ( self , ** kwargs ): return \"\" def _to_json ( self , ** kwargs ): return \"\" def _to_text ( self , ** kwargs ): return \"\"","title":"TreeMap"},{"location":"reference/dependenpy/#dependenpy.structures.TreeMap.__init__","text":"Initialization method. Parameters: Name Type Description Default *nodes Any the nodes from which to build the treemap. () value int the value of the current area. -1 Source code in dependenpy/structures.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 def __init__ ( self , * nodes : Any , value : int = - 1 ): \"\"\" Initialization method. Arguments: *nodes: the nodes from which to build the treemap. value: the value of the current area. \"\"\" # if nodes: # matrix_lower_level = Matrix(*nodes, depth=2) # matrix_current_level = Matrix(*nodes, depth=1) # if value == -1: # value = sum(c for row in matrix_current_level.data for c in row) # splits = [0] # key_comp = matrix_lower_level.keys[0].split('.')[0] # i = 1 # for key in matrix_lower_level.keys[1:]: # key = key.split('.')[0] # if key != key_comp: # splits.append(i) # key_comp = key # i += 1 # splits.append(i) # # self.data = [] # for i in range(len(splits) - 1): # self.data.append([]) # rows = matrix_lower_level.data[splits[i]:splits[i+1]] # for j in range(len(splits) - 1): # self.data[i].append([row[splits[j]:splits[j+1]] for row in rows]) self . value = value","title":"__init__()"},{"location":"reference/dependenpy/cli/","text":"Module that contains the command line application. get_parser () \u00a4 Return the CLI argument parser. Returns: Type Description argparse . ArgumentParser An argparse parser. Source code in dependenpy/cli.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 def get_parser () -> argparse . ArgumentParser : \"\"\" Return the CLI argument parser. Returns: An argparse parser. \"\"\" parser = argparse . ArgumentParser ( prog = \"dependenpy\" , add_help = False , description = \"Command line tool for dependenpy Python package.\" ) mxg = parser . add_mutually_exclusive_group ( required = False ) parser . add_argument ( \"packages\" , metavar = \"PACKAGES\" , nargs = argparse . ONE_OR_MORE , help = \"The package list. Can be a comma-separated list. Each package \" \"must be either a valid path or a package in PYTHONPATH.\" , ) parser . add_argument ( \"-d\" , \"--depth\" , default = None , type = int , dest = \"depth\" , help = \"Specify matrix or graph depth. Default: best guess.\" , ) parser . add_argument ( \"-f\" , \"--format\" , choices = FORMAT , default = \"text\" , dest = \"format\" , help = \"Output format. Default: text.\" ) mxg . add_argument ( \"-g\" , \"--show-graph\" , action = \"store_true\" , dest = \"graph\" , default = False , help = \"Show the graph (no text format). Default: false.\" , ) parser . add_argument ( \"-G\" , \"--greedy\" , action = \"store_true\" , dest = \"greedy\" , default = False , help = \"Explore subdirectories even if they do not contain an \" \"__init__.py file. Can make execution slower. Default: false.\" , ) parser . add_argument ( \"-h\" , \"--help\" , action = \"help\" , default = argparse . SUPPRESS , help = \"Show this help message and exit.\" ) parser . add_argument ( \"-i\" , \"--indent\" , default = None , type = int , dest = \"indent\" , help = \"Specify output indentation. CSV will never be indented. \" \"Text will always have new-lines. JSON can be minified with \" \"a negative value. Default: best guess.\" , ) mxg . add_argument ( \"-l\" , \"--show-dependencies-list\" , action = \"store_true\" , dest = \"dependencies\" , default = False , help = \"Show the dependencies list. Default: false.\" , ) mxg . add_argument ( \"-m\" , \"--show-matrix\" , action = \"store_true\" , dest = \"matrix\" , default = False , help = \"Show the matrix. Default: true unless -g, -l or -t.\" , ) parser . add_argument ( \"-o\" , \"--output\" , action = \"store\" , dest = \"output\" , default = sys . stdout , help = \"Output to given file. Default: stdout.\" , ) mxg . add_argument ( \"-t\" , \"--show-treemap\" , action = \"store_true\" , dest = \"treemap\" , default = False , help = \"Show the treemap (work in progress). Default: false.\" , ) parser . add_argument ( \"-v\" , \"--version\" , action = \"version\" , version = f \"dependenpy { __version__ } \" , help = \"Show the current version of the program and exit.\" , ) parser . add_argument ( \"-z\" , \"--zero\" , dest = \"zero\" , default = \"0\" , help = \"Character to use for cells with value=0 (text matrix display only).\" , ) return parser main ( args = None ) \u00a4 Run the main program. This function is executed when you type dependenpy or python -m dependenpy . Parameters: Name Type Description Default args Optional [ List [ str ]] Arguments passed from the command line. None Returns: Type Description int An exit code. 0 (OK), 1 (dsm empty) or 2 (error). Source code in dependenpy/cli.py 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 def main ( args : Optional [ List [ str ]] = None ) -> int : # noqa: WPS231 \"\"\" Run the main program. This function is executed when you type `dependenpy` or `python -m dependenpy`. Arguments: args: Arguments passed from the command line. Returns: An exit code. 0 (OK), 1 (dsm empty) or 2 (error). \"\"\" parser = get_parser () opts = parser . parse_args ( args = args ) if not ( opts . matrix or opts . dependencies or opts . treemap or opts . graph ): opts . matrix = True dsm = DSM ( * _get_packages ( opts ), build_tree = True , build_dependencies = True , enforce_init = not opts . greedy ) if dsm . empty : return 1 # init colorama init () try : _run ( opts , dsm ) except BrokenPipeError : # avoid traceback return 2 return 0","title":"cli"},{"location":"reference/dependenpy/cli/#dependenpy.cli.get_parser","text":"Return the CLI argument parser. Returns: Type Description argparse . ArgumentParser An argparse parser. Source code in dependenpy/cli.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 def get_parser () -> argparse . ArgumentParser : \"\"\" Return the CLI argument parser. Returns: An argparse parser. \"\"\" parser = argparse . ArgumentParser ( prog = \"dependenpy\" , add_help = False , description = \"Command line tool for dependenpy Python package.\" ) mxg = parser . add_mutually_exclusive_group ( required = False ) parser . add_argument ( \"packages\" , metavar = \"PACKAGES\" , nargs = argparse . ONE_OR_MORE , help = \"The package list. Can be a comma-separated list. Each package \" \"must be either a valid path or a package in PYTHONPATH.\" , ) parser . add_argument ( \"-d\" , \"--depth\" , default = None , type = int , dest = \"depth\" , help = \"Specify matrix or graph depth. Default: best guess.\" , ) parser . add_argument ( \"-f\" , \"--format\" , choices = FORMAT , default = \"text\" , dest = \"format\" , help = \"Output format. Default: text.\" ) mxg . add_argument ( \"-g\" , \"--show-graph\" , action = \"store_true\" , dest = \"graph\" , default = False , help = \"Show the graph (no text format). Default: false.\" , ) parser . add_argument ( \"-G\" , \"--greedy\" , action = \"store_true\" , dest = \"greedy\" , default = False , help = \"Explore subdirectories even if they do not contain an \" \"__init__.py file. Can make execution slower. Default: false.\" , ) parser . add_argument ( \"-h\" , \"--help\" , action = \"help\" , default = argparse . SUPPRESS , help = \"Show this help message and exit.\" ) parser . add_argument ( \"-i\" , \"--indent\" , default = None , type = int , dest = \"indent\" , help = \"Specify output indentation. CSV will never be indented. \" \"Text will always have new-lines. JSON can be minified with \" \"a negative value. Default: best guess.\" , ) mxg . add_argument ( \"-l\" , \"--show-dependencies-list\" , action = \"store_true\" , dest = \"dependencies\" , default = False , help = \"Show the dependencies list. Default: false.\" , ) mxg . add_argument ( \"-m\" , \"--show-matrix\" , action = \"store_true\" , dest = \"matrix\" , default = False , help = \"Show the matrix. Default: true unless -g, -l or -t.\" , ) parser . add_argument ( \"-o\" , \"--output\" , action = \"store\" , dest = \"output\" , default = sys . stdout , help = \"Output to given file. Default: stdout.\" , ) mxg . add_argument ( \"-t\" , \"--show-treemap\" , action = \"store_true\" , dest = \"treemap\" , default = False , help = \"Show the treemap (work in progress). Default: false.\" , ) parser . add_argument ( \"-v\" , \"--version\" , action = \"version\" , version = f \"dependenpy { __version__ } \" , help = \"Show the current version of the program and exit.\" , ) parser . add_argument ( \"-z\" , \"--zero\" , dest = \"zero\" , default = \"0\" , help = \"Character to use for cells with value=0 (text matrix display only).\" , ) return parser","title":"get_parser()"},{"location":"reference/dependenpy/cli/#dependenpy.cli.main","text":"Run the main program. This function is executed when you type dependenpy or python -m dependenpy . Parameters: Name Type Description Default args Optional [ List [ str ]] Arguments passed from the command line. None Returns: Type Description int An exit code. 0 (OK), 1 (dsm empty) or 2 (error). Source code in dependenpy/cli.py 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 def main ( args : Optional [ List [ str ]] = None ) -> int : # noqa: WPS231 \"\"\" Run the main program. This function is executed when you type `dependenpy` or `python -m dependenpy`. Arguments: args: Arguments passed from the command line. Returns: An exit code. 0 (OK), 1 (dsm empty) or 2 (error). \"\"\" parser = get_parser () opts = parser . parse_args ( args = args ) if not ( opts . matrix or opts . dependencies or opts . treemap or opts . graph ): opts . matrix = True dsm = DSM ( * _get_packages ( opts ), build_tree = True , build_dependencies = True , enforce_init = not opts . greedy ) if dsm . empty : return 1 # init colorama init () try : _run ( opts , dsm ) except BrokenPipeError : # avoid traceback return 2 return 0","title":"main()"},{"location":"reference/dependenpy/dsm/","text":"dependenpy dsm module. This is the core module of dependenpy. It contains the following classes: DSM : to create a DSM-capable object for a list of packages, Package : which represents a Python package, Module : which represents a Python module, Dependency : which represents a dependency between two modules. DSM \u00a4 Bases: RootNode , NodeMixin , PrintMixin DSM-capable class. Technically speaking, a DSM instance is not a real DSM but more a tree representing the Python packages structure. However, it has the necessary methods to build a real DSM in the form of a square matrix, a dictionary or a tree-map. Source code in dependenpy/dsm.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 class DSM ( RootNode , NodeMixin , PrintMixin ): \"\"\" DSM-capable class. Technically speaking, a DSM instance is not a real DSM but more a tree representing the Python packages structure. However, it has the necessary methods to build a real DSM in the form of a square matrix, a dictionary or a tree-map. \"\"\" def __init__ ( self , * packages : str , build_tree : bool = True , build_dependencies : bool = True , enforce_init : bool = True ): \"\"\" Initialization method. Args: *packages: list of packages to search for. build_tree: auto-build the tree or not. build_dependencies: auto-build the dependencies or not. enforce_init: if True, only treat directories if they contain an `__init__.py` file. \"\"\" self . base_packages = packages self . finder = Finder () self . specs = [] self . not_found = [] self . enforce_init = enforce_init specs = [] for package in packages : spec = self . finder . find ( package , enforce_init = enforce_init ) if spec : specs . append ( spec ) else : self . not_found . append ( package ) if not specs : print ( \"** dependenpy: DSM empty.\" , file = sys . stderr ) self . specs = PackageSpec . combine ( specs ) for module in self . not_found : print ( f \"** dependenpy: Not found: { module } .\" , file = sys . stderr ) super () . __init__ ( build_tree ) if build_tree and build_dependencies : self . build_dependencies () def __str__ ( self ): packages_names = \", \" . join ([ package . name for package in self . packages ]) return f \"Dependency DSM for packages: [ { packages_names } ]\" @property def isdsm ( self ) -> bool : \"\"\" Inherited from NodeMixin. Always True. Returns: Whether this object is a DSM. \"\"\" return True def build_tree ( self ): \"\"\"Build the Python packages tree.\"\"\" for spec in self . specs : if spec . ismodule : self . modules . append ( Module ( spec . name , spec . path , dsm = self )) else : self . packages . append ( Package ( spec . name , spec . path , dsm = self , limit_to = spec . limit_to , build_tree = True , build_dependencies = False , enforce_init = self . enforce_init , ) ) __init__ ( * packages , build_tree = True , build_dependencies = True , enforce_init = True ) \u00a4 Initialization method. Parameters: Name Type Description Default *packages str list of packages to search for. () build_tree bool auto-build the tree or not. True build_dependencies bool auto-build the dependencies or not. True enforce_init bool if True, only treat directories if they contain an __init__.py file. True Source code in dependenpy/dsm.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def __init__ ( self , * packages : str , build_tree : bool = True , build_dependencies : bool = True , enforce_init : bool = True ): \"\"\" Initialization method. Args: *packages: list of packages to search for. build_tree: auto-build the tree or not. build_dependencies: auto-build the dependencies or not. enforce_init: if True, only treat directories if they contain an `__init__.py` file. \"\"\" self . base_packages = packages self . finder = Finder () self . specs = [] self . not_found = [] self . enforce_init = enforce_init specs = [] for package in packages : spec = self . finder . find ( package , enforce_init = enforce_init ) if spec : specs . append ( spec ) else : self . not_found . append ( package ) if not specs : print ( \"** dependenpy: DSM empty.\" , file = sys . stderr ) self . specs = PackageSpec . combine ( specs ) for module in self . not_found : print ( f \"** dependenpy: Not found: { module } .\" , file = sys . stderr ) super () . __init__ ( build_tree ) if build_tree and build_dependencies : self . build_dependencies () build_tree () \u00a4 Build the Python packages tree. Source code in dependenpy/dsm.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def build_tree ( self ): \"\"\"Build the Python packages tree.\"\"\" for spec in self . specs : if spec . ismodule : self . modules . append ( Module ( spec . name , spec . path , dsm = self )) else : self . packages . append ( Package ( spec . name , spec . path , dsm = self , limit_to = spec . limit_to , build_tree = True , build_dependencies = False , enforce_init = self . enforce_init , ) ) isdsm () property \u00a4 Inherited from NodeMixin. Always True. Returns: Type Description bool Whether this object is a DSM. Source code in dependenpy/dsm.py 80 81 82 83 84 85 86 87 88 @property def isdsm ( self ) -> bool : \"\"\" Inherited from NodeMixin. Always True. Returns: Whether this object is a DSM. \"\"\" return True Dependency \u00a4 Bases: object Dependency class. Represent a dependency from a module to another. Source code in dependenpy/dsm.py 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 class Dependency ( object ): \"\"\" Dependency class. Represent a dependency from a module to another. \"\"\" def __init__ ( self , source , lineno , target , what = None ): \"\"\" Initialization method. Args: source (Module): source Module. lineno (int): number of line at which import statement occurs. target (str/Module/Package): the target node. what (str): what is imported (optional). \"\"\" self . source = source self . lineno = lineno self . target = target self . what = what def __str__ ( self ): what = f \" { self . what or '' } from \" target = self . target if self . external else self . target . absolute_name () return f \" { self . source . name } imports { what }{ target } (line { self . lineno } )\" @property def external ( self ) -> bool : \"\"\" Property to tell if the dependency's target is a valid node. Returns: Whether the dependency's target is a valid node. \"\"\" return isinstance ( self . target , str ) __init__ ( source , lineno , target , what = None ) \u00a4 Initialization method. Parameters: Name Type Description Default source Module source Module. required lineno int number of line at which import statement occurs. required target str/Module/Package the target node. required what str what is imported (optional). None Source code in dependenpy/dsm.py 426 427 428 429 430 431 432 433 434 435 436 437 438 439 def __init__ ( self , source , lineno , target , what = None ): \"\"\" Initialization method. Args: source (Module): source Module. lineno (int): number of line at which import statement occurs. target (str/Module/Package): the target node. what (str): what is imported (optional). \"\"\" self . source = source self . lineno = lineno self . target = target self . what = what external () property \u00a4 Property to tell if the dependency's target is a valid node. Returns: Type Description bool Whether the dependency's target is a valid node. Source code in dependenpy/dsm.py 446 447 448 449 450 451 452 453 454 @property def external ( self ) -> bool : \"\"\" Property to tell if the dependency's target is a valid node. Returns: Whether the dependency's target is a valid node. \"\"\" return isinstance ( self . target , str ) Module \u00a4 Bases: LeafNode , NodeMixin , PrintMixin Module class. This class represents a Python module (a Python file). Source code in dependenpy/dsm.py 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 class Module ( LeafNode , NodeMixin , PrintMixin ): # noqa: WPS338 \"\"\" Module class. This class represents a Python module (a Python file). \"\"\" RECURSIVE_NODES = ( ast . ClassDef , ast . FunctionDef , ast . If , ast . IfExp , ast . Try , ast . With , ast . ExceptHandler ) def __init__ ( self , name , path , dsm = None , package = None ): \"\"\" Initialization method. Args: name (str): name of the module. path (str): path to the module. dsm (DSM): parent DSM. package (Package): parent Package. \"\"\" super () . __init__ () self . name = name self . path = path self . package = package self . dsm = dsm self . dependencies = [] def __contains__ ( self , item ) -> bool : \"\"\" Whether given item is contained inside this module. Args: item (Package/Module): a package or module. Returns: True if self is item or item is self's package and self if an `__init__` module. \"\"\" if self is item : return True elif self . package is item and self . name == \"__init__\" : return True return False @property def ismodule ( self ) -> bool : \"\"\" Inherited from NodeMixin. Always True. Returns: Whether this object is a module. \"\"\" return True def as_dict ( self , absolute : bool = False ) -> dict : \"\"\" Return the dependencies as a dictionary. Arguments: absolute: Whether to use the absolute name. Returns: dict: dictionary of dependencies. \"\"\" return { \"name\" : self . absolute_name () if absolute else self . name , \"path\" : self . path , \"dependencies\" : [ { # 'source': d.source.absolute_name(), # redundant \"target\" : dep . target if dep . external else dep . target . absolute_name (), \"lineno\" : dep . lineno , \"what\" : dep . what , \"external\" : dep . external , } for dep in self . dependencies ], } def _to_text ( self , ** kwargs ): indent = kwargs . pop ( \"indent\" , 2 ) base_indent = kwargs . pop ( \"base_indent\" , None ) if base_indent is None : base_indent = indent indent = 0 text = [ \" \" * indent + self . name + \" \\n \" ] new_indent = indent + base_indent for dep in self . dependencies : external = \"! \" if dep . external else \"\" text . append ( \" \" * new_indent + external + str ( dep ) + \" \\n \" ) return \"\" . join ( text ) def _to_csv ( self , ** kwargs ): header = kwargs . pop ( \"header\" , True ) text = [ \"module,path,target,lineno,what,external \\n \" if header else \"\" ] name = self . absolute_name () for dep in self . dependencies : target = dep . target if dep . external else dep . target . absolute_name () text . append ( f \" { name } , { self . path } , { target } , { dep . lineno } , { dep . what or '' } , { dep . external } \\n \" ) return \"\" . join ( text ) def _to_json ( self , ** kwargs ): absolute = kwargs . pop ( \"absolute\" , False ) return json . dumps ( self . as_dict ( absolute = absolute ), ** kwargs ) def build_dependencies ( self ): \"\"\" Build the dependencies for this module. Parse the code with ast, find all the import statements, convert them into Dependency objects. \"\"\" highest = self . dsm or self . root if self is highest : highest = LeafNode () for import_ in self . parse_code (): target = highest . get_target ( import_ [ \"target\" ]) if target : what = import_ [ \"target\" ] . split ( \".\" )[ - 1 ] if what != target . name : import_ [ \"what\" ] = what import_ [ \"target\" ] = target self . dependencies . append ( Dependency ( source = self , ** import_ )) def parse_code ( self ) -> list [ dict ]: \"\"\" Read the source code and return all the import statements. Returns: list of dict: the import statements. \"\"\" code = Path ( self . path ) . read_text ( encoding = \"utf-8\" ) try : body = ast . parse ( code ) . body except SyntaxError : code = code . encode ( \"utf-8\" ) # type: ignore[assignment] try : # noqa: WPS505 body = ast . parse ( code ) . body except SyntaxError : return [] return self . get_imports ( body ) def get_imports ( self , ast_body ) -> list [ dict ]: # noqa: WPS231,WPS615 \"\"\" Return all the import statements given an AST body (AST nodes). Args: ast_body (compiled code's body): the body to filter. Returns: The import statements. \"\"\" imports : list [ dict ] = [] for node in ast_body : if isinstance ( node , ast . Import ): imports . extend ({ \"target\" : name . name , \"lineno\" : node . lineno } for name in node . names ) elif isinstance ( node , ast . ImportFrom ): for name in node . names : abs_name = self . absolute_name ( self . depth - node . level ) + \".\" if node . level > 0 else \"\" node_module = node . module + \".\" if node . module else \"\" name = abs_name + node_module + name . name # type: ignore[assignment] imports . append ({ \"target\" : name , \"lineno\" : node . lineno }) elif isinstance ( node , Module . RECURSIVE_NODES ): imports . extend ( self . get_imports ( node . body )) if isinstance ( node , ast . Try ): imports . extend ( self . get_imports ( node . finalbody )) return imports def cardinal ( self , to ) -> int : \"\"\" Return the number of dependencies of this module to the given node. Args: to (Package/Module): the target node. Returns: Number of dependencies. \"\"\" return len ([ dep for dep in self . dependencies if not dep . external and dep . target in to ]) __contains__ ( item ) \u00a4 Whether given item is contained inside this module. Parameters: Name Type Description Default item Package/Module a package or module. required Returns: Type Description bool True if self is item or item is self's package and self if an __init__ module. Source code in dependenpy/dsm.py 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 def __contains__ ( self , item ) -> bool : \"\"\" Whether given item is contained inside this module. Args: item (Package/Module): a package or module. Returns: True if self is item or item is self's package and self if an `__init__` module. \"\"\" if self is item : return True elif self . package is item and self . name == \"__init__\" : return True return False __init__ ( name , path , dsm = None , package = None ) \u00a4 Initialization method. Parameters: Name Type Description Default name str name of the module. required path str path to the module. required dsm DSM parent DSM. None package Package parent Package. None Source code in dependenpy/dsm.py 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 def __init__ ( self , name , path , dsm = None , package = None ): \"\"\" Initialization method. Args: name (str): name of the module. path (str): path to the module. dsm (DSM): parent DSM. package (Package): parent Package. \"\"\" super () . __init__ () self . name = name self . path = path self . package = package self . dsm = dsm self . dependencies = [] as_dict ( absolute = False ) \u00a4 Return the dependencies as a dictionary. Parameters: Name Type Description Default absolute bool Whether to use the absolute name. False Returns: Name Type Description dict dict dictionary of dependencies. Source code in dependenpy/dsm.py 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 def as_dict ( self , absolute : bool = False ) -> dict : \"\"\" Return the dependencies as a dictionary. Arguments: absolute: Whether to use the absolute name. Returns: dict: dictionary of dependencies. \"\"\" return { \"name\" : self . absolute_name () if absolute else self . name , \"path\" : self . path , \"dependencies\" : [ { # 'source': d.source.absolute_name(), # redundant \"target\" : dep . target if dep . external else dep . target . absolute_name (), \"lineno\" : dep . lineno , \"what\" : dep . what , \"external\" : dep . external , } for dep in self . dependencies ], } build_dependencies () \u00a4 Build the dependencies for this module. Parse the code with ast, find all the import statements, convert them into Dependency objects. Source code in dependenpy/dsm.py 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 def build_dependencies ( self ): \"\"\" Build the dependencies for this module. Parse the code with ast, find all the import statements, convert them into Dependency objects. \"\"\" highest = self . dsm or self . root if self is highest : highest = LeafNode () for import_ in self . parse_code (): target = highest . get_target ( import_ [ \"target\" ]) if target : what = import_ [ \"target\" ] . split ( \".\" )[ - 1 ] if what != target . name : import_ [ \"what\" ] = what import_ [ \"target\" ] = target self . dependencies . append ( Dependency ( source = self , ** import_ )) cardinal ( to ) \u00a4 Return the number of dependencies of this module to the given node. Parameters: Name Type Description Default to Package/Module the target node. required Returns: Type Description int Number of dependencies. Source code in dependenpy/dsm.py 406 407 408 409 410 411 412 413 414 415 416 def cardinal ( self , to ) -> int : \"\"\" Return the number of dependencies of this module to the given node. Args: to (Package/Module): the target node. Returns: Number of dependencies. \"\"\" return len ([ dep for dep in self . dependencies if not dep . external and dep . target in to ]) get_imports ( ast_body ) \u00a4 Return all the import statements given an AST body (AST nodes). Parameters: Name Type Description Default ast_body compiled code's body the body to filter. required Returns: Type Description list [ dict ] The import statements. Source code in dependenpy/dsm.py 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 def get_imports ( self , ast_body ) -> list [ dict ]: # noqa: WPS231,WPS615 \"\"\" Return all the import statements given an AST body (AST nodes). Args: ast_body (compiled code's body): the body to filter. Returns: The import statements. \"\"\" imports : list [ dict ] = [] for node in ast_body : if isinstance ( node , ast . Import ): imports . extend ({ \"target\" : name . name , \"lineno\" : node . lineno } for name in node . names ) elif isinstance ( node , ast . ImportFrom ): for name in node . names : abs_name = self . absolute_name ( self . depth - node . level ) + \".\" if node . level > 0 else \"\" node_module = node . module + \".\" if node . module else \"\" name = abs_name + node_module + name . name # type: ignore[assignment] imports . append ({ \"target\" : name , \"lineno\" : node . lineno }) elif isinstance ( node , Module . RECURSIVE_NODES ): imports . extend ( self . get_imports ( node . body )) if isinstance ( node , ast . Try ): imports . extend ( self . get_imports ( node . finalbody )) return imports ismodule () property \u00a4 Inherited from NodeMixin. Always True. Returns: Type Description bool Whether this object is a module. Source code in dependenpy/dsm.py 282 283 284 285 286 287 288 289 290 @property def ismodule ( self ) -> bool : \"\"\" Inherited from NodeMixin. Always True. Returns: Whether this object is a module. \"\"\" return True parse_code () \u00a4 Read the source code and return all the import statements. Returns: Type Description list [ dict ] list of dict: the import statements. Source code in dependenpy/dsm.py 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 def parse_code ( self ) -> list [ dict ]: \"\"\" Read the source code and return all the import statements. Returns: list of dict: the import statements. \"\"\" code = Path ( self . path ) . read_text ( encoding = \"utf-8\" ) try : body = ast . parse ( code ) . body except SyntaxError : code = code . encode ( \"utf-8\" ) # type: ignore[assignment] try : # noqa: WPS505 body = ast . parse ( code ) . body except SyntaxError : return [] return self . get_imports ( body ) Package \u00a4 Bases: RootNode , LeafNode , NodeMixin , PrintMixin Package class. This class represent Python packages as nodes in a tree. Source code in dependenpy/dsm.py 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 class Package ( RootNode , LeafNode , NodeMixin , PrintMixin ): # noqa: WPS215 \"\"\" Package class. This class represent Python packages as nodes in a tree. \"\"\" def __init__ ( self , name : str , path : str , dsm : DSM = None , package : \"Package\" = None , limit_to : List [ str ] = None , build_tree : bool = True , build_dependencies : bool = True , enforce_init : bool = True , ): \"\"\" Initialization method. Args: name: name of the package. path: path to the package. dsm: parent DSM. package: parent package. limit_to: list of string to limit the recursive tree-building to what is specified. build_tree: auto-build the tree or not. build_dependencies: auto-build the dependencies or not. enforce_init: if True, only treat directories if they contain an `__init__.py` file. \"\"\" self . name = name self . path = path self . package = package self . dsm = dsm self . limit_to = limit_to or [] self . enforce_init = enforce_init RootNode . __init__ ( self , build_tree ) # noqa: WPS609 LeafNode . __init__ ( self ) # noqa: WPS609 if build_tree and build_dependencies : self . build_dependencies () @property def ispackage ( self ) -> bool : \"\"\" Inherited from NodeMixin. Always True. Returns: Whether this object is a package. \"\"\" return True @property def issubpackage ( self ) -> bool : \"\"\" Property to tell if this node is a sub-package. Returns: This package has a parent. \"\"\" return self . package is not None @property def isroot ( self ) -> bool : \"\"\" Property to tell if this node is a root node. Returns: This package has no parent. \"\"\" return self . package is None def split_limits_heads ( self ) -> tuple [ list [ str ], list [ str ]]: \"\"\" Return first parts of dot-separated strings, and rest of strings. Returns: The heads and rest of the strings. \"\"\" heads = [] new_limit_to = [] for limit in self . limit_to : if \".\" in limit : name , limit = limit . split ( \".\" , 1 ) # noqa: WPS440 heads . append ( name ) new_limit_to . append ( limit ) else : heads . append ( limit ) return heads , new_limit_to def build_tree ( self ): # noqa: WPS231 \"\"\"Build the tree for this package.\"\"\" for module in listdir ( self . path ): abs_m = join ( self . path , module ) if isfile ( abs_m ) and module . endswith ( \".py\" ): name = splitext ( module )[ 0 ] if not self . limit_to or name in self . limit_to : self . modules . append ( Module ( name , abs_m , self . dsm , self )) elif isdir ( abs_m ): if isfile ( join ( abs_m , \"__init__.py\" )) or not self . enforce_init : heads , new_limit_to = self . split_limits_heads () if not heads or module in heads : self . packages . append ( Package ( module , abs_m , self . dsm , self , new_limit_to , build_tree = True , build_dependencies = False , enforce_init = self . enforce_init , ) ) def cardinal ( self , to ) -> int : \"\"\" Return the number of dependencies of this package to the given node. Args: to (Package/Module): target node. Returns: Number of dependencies. \"\"\" return sum ( module . cardinal ( to ) for module in self . submodules ) __init__ ( name , path , dsm = None , package = None , limit_to = None , build_tree = True , build_dependencies = True , enforce_init = True ) \u00a4 Initialization method. Parameters: Name Type Description Default name str name of the package. required path str path to the package. required dsm DSM parent DSM. None package 'Package' parent package. None limit_to List [ str ] list of string to limit the recursive tree-building to what is specified. None build_tree bool auto-build the tree or not. True build_dependencies bool auto-build the dependencies or not. True enforce_init bool if True, only treat directories if they contain an __init__.py file. True Source code in dependenpy/dsm.py 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 def __init__ ( self , name : str , path : str , dsm : DSM = None , package : \"Package\" = None , limit_to : List [ str ] = None , build_tree : bool = True , build_dependencies : bool = True , enforce_init : bool = True , ): \"\"\" Initialization method. Args: name: name of the package. path: path to the package. dsm: parent DSM. package: parent package. limit_to: list of string to limit the recursive tree-building to what is specified. build_tree: auto-build the tree or not. build_dependencies: auto-build the dependencies or not. enforce_init: if True, only treat directories if they contain an `__init__.py` file. \"\"\" self . name = name self . path = path self . package = package self . dsm = dsm self . limit_to = limit_to or [] self . enforce_init = enforce_init RootNode . __init__ ( self , build_tree ) # noqa: WPS609 LeafNode . __init__ ( self ) # noqa: WPS609 if build_tree and build_dependencies : self . build_dependencies () build_tree () \u00a4 Build the tree for this package. Source code in dependenpy/dsm.py 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 def build_tree ( self ): # noqa: WPS231 \"\"\"Build the tree for this package.\"\"\" for module in listdir ( self . path ): abs_m = join ( self . path , module ) if isfile ( abs_m ) and module . endswith ( \".py\" ): name = splitext ( module )[ 0 ] if not self . limit_to or name in self . limit_to : self . modules . append ( Module ( name , abs_m , self . dsm , self )) elif isdir ( abs_m ): if isfile ( join ( abs_m , \"__init__.py\" )) or not self . enforce_init : heads , new_limit_to = self . split_limits_heads () if not heads or module in heads : self . packages . append ( Package ( module , abs_m , self . dsm , self , new_limit_to , build_tree = True , build_dependencies = False , enforce_init = self . enforce_init , ) ) cardinal ( to ) \u00a4 Return the number of dependencies of this package to the given node. Parameters: Name Type Description Default to Package/Module target node. required Returns: Type Description int Number of dependencies. Source code in dependenpy/dsm.py 226 227 228 229 230 231 232 233 234 235 236 def cardinal ( self , to ) -> int : \"\"\" Return the number of dependencies of this package to the given node. Args: to (Package/Module): target node. Returns: Number of dependencies. \"\"\" return sum ( module . cardinal ( to ) for module in self . submodules ) ispackage () property \u00a4 Inherited from NodeMixin. Always True. Returns: Type Description bool Whether this object is a package. Source code in dependenpy/dsm.py 153 154 155 156 157 158 159 160 161 @property def ispackage ( self ) -> bool : \"\"\" Inherited from NodeMixin. Always True. Returns: Whether this object is a package. \"\"\" return True isroot () property \u00a4 Property to tell if this node is a root node. Returns: Type Description bool This package has no parent. Source code in dependenpy/dsm.py 173 174 175 176 177 178 179 180 181 @property def isroot ( self ) -> bool : \"\"\" Property to tell if this node is a root node. Returns: This package has no parent. \"\"\" return self . package is None issubpackage () property \u00a4 Property to tell if this node is a sub-package. Returns: Type Description bool This package has a parent. Source code in dependenpy/dsm.py 163 164 165 166 167 168 169 170 171 @property def issubpackage ( self ) -> bool : \"\"\" Property to tell if this node is a sub-package. Returns: This package has a parent. \"\"\" return self . package is not None split_limits_heads () \u00a4 Return first parts of dot-separated strings, and rest of strings. Returns: Type Description tuple [ list [ str ], list [ str ]] The heads and rest of the strings. Source code in dependenpy/dsm.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 def split_limits_heads ( self ) -> tuple [ list [ str ], list [ str ]]: \"\"\" Return first parts of dot-separated strings, and rest of strings. Returns: The heads and rest of the strings. \"\"\" heads = [] new_limit_to = [] for limit in self . limit_to : if \".\" in limit : name , limit = limit . split ( \".\" , 1 ) # noqa: WPS440 heads . append ( name ) new_limit_to . append ( limit ) else : heads . append ( limit ) return heads , new_limit_to","title":"dsm"},{"location":"reference/dependenpy/dsm/#dependenpy.dsm.DSM","text":"Bases: RootNode , NodeMixin , PrintMixin DSM-capable class. Technically speaking, a DSM instance is not a real DSM but more a tree representing the Python packages structure. However, it has the necessary methods to build a real DSM in the form of a square matrix, a dictionary or a tree-map. Source code in dependenpy/dsm.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 class DSM ( RootNode , NodeMixin , PrintMixin ): \"\"\" DSM-capable class. Technically speaking, a DSM instance is not a real DSM but more a tree representing the Python packages structure. However, it has the necessary methods to build a real DSM in the form of a square matrix, a dictionary or a tree-map. \"\"\" def __init__ ( self , * packages : str , build_tree : bool = True , build_dependencies : bool = True , enforce_init : bool = True ): \"\"\" Initialization method. Args: *packages: list of packages to search for. build_tree: auto-build the tree or not. build_dependencies: auto-build the dependencies or not. enforce_init: if True, only treat directories if they contain an `__init__.py` file. \"\"\" self . base_packages = packages self . finder = Finder () self . specs = [] self . not_found = [] self . enforce_init = enforce_init specs = [] for package in packages : spec = self . finder . find ( package , enforce_init = enforce_init ) if spec : specs . append ( spec ) else : self . not_found . append ( package ) if not specs : print ( \"** dependenpy: DSM empty.\" , file = sys . stderr ) self . specs = PackageSpec . combine ( specs ) for module in self . not_found : print ( f \"** dependenpy: Not found: { module } .\" , file = sys . stderr ) super () . __init__ ( build_tree ) if build_tree and build_dependencies : self . build_dependencies () def __str__ ( self ): packages_names = \", \" . join ([ package . name for package in self . packages ]) return f \"Dependency DSM for packages: [ { packages_names } ]\" @property def isdsm ( self ) -> bool : \"\"\" Inherited from NodeMixin. Always True. Returns: Whether this object is a DSM. \"\"\" return True def build_tree ( self ): \"\"\"Build the Python packages tree.\"\"\" for spec in self . specs : if spec . ismodule : self . modules . append ( Module ( spec . name , spec . path , dsm = self )) else : self . packages . append ( Package ( spec . name , spec . path , dsm = self , limit_to = spec . limit_to , build_tree = True , build_dependencies = False , enforce_init = self . enforce_init , ) )","title":"DSM"},{"location":"reference/dependenpy/dsm/#dependenpy.dsm.DSM.__init__","text":"Initialization method. Parameters: Name Type Description Default *packages str list of packages to search for. () build_tree bool auto-build the tree or not. True build_dependencies bool auto-build the dependencies or not. True enforce_init bool if True, only treat directories if they contain an __init__.py file. True Source code in dependenpy/dsm.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 def __init__ ( self , * packages : str , build_tree : bool = True , build_dependencies : bool = True , enforce_init : bool = True ): \"\"\" Initialization method. Args: *packages: list of packages to search for. build_tree: auto-build the tree or not. build_dependencies: auto-build the dependencies or not. enforce_init: if True, only treat directories if they contain an `__init__.py` file. \"\"\" self . base_packages = packages self . finder = Finder () self . specs = [] self . not_found = [] self . enforce_init = enforce_init specs = [] for package in packages : spec = self . finder . find ( package , enforce_init = enforce_init ) if spec : specs . append ( spec ) else : self . not_found . append ( package ) if not specs : print ( \"** dependenpy: DSM empty.\" , file = sys . stderr ) self . specs = PackageSpec . combine ( specs ) for module in self . not_found : print ( f \"** dependenpy: Not found: { module } .\" , file = sys . stderr ) super () . __init__ ( build_tree ) if build_tree and build_dependencies : self . build_dependencies ()","title":"__init__()"},{"location":"reference/dependenpy/dsm/#dependenpy.dsm.DSM.build_tree","text":"Build the Python packages tree. Source code in dependenpy/dsm.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 def build_tree ( self ): \"\"\"Build the Python packages tree.\"\"\" for spec in self . specs : if spec . ismodule : self . modules . append ( Module ( spec . name , spec . path , dsm = self )) else : self . packages . append ( Package ( spec . name , spec . path , dsm = self , limit_to = spec . limit_to , build_tree = True , build_dependencies = False , enforce_init = self . enforce_init , ) )","title":"build_tree()"},{"location":"reference/dependenpy/dsm/#dependenpy.dsm.DSM.isdsm","text":"Inherited from NodeMixin. Always True. Returns: Type Description bool Whether this object is a DSM. Source code in dependenpy/dsm.py 80 81 82 83 84 85 86 87 88 @property def isdsm ( self ) -> bool : \"\"\" Inherited from NodeMixin. Always True. Returns: Whether this object is a DSM. \"\"\" return True","title":"isdsm()"},{"location":"reference/dependenpy/dsm/#dependenpy.dsm.Dependency","text":"Bases: object Dependency class. Represent a dependency from a module to another. Source code in dependenpy/dsm.py 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 class Dependency ( object ): \"\"\" Dependency class. Represent a dependency from a module to another. \"\"\" def __init__ ( self , source , lineno , target , what = None ): \"\"\" Initialization method. Args: source (Module): source Module. lineno (int): number of line at which import statement occurs. target (str/Module/Package): the target node. what (str): what is imported (optional). \"\"\" self . source = source self . lineno = lineno self . target = target self . what = what def __str__ ( self ): what = f \" { self . what or '' } from \" target = self . target if self . external else self . target . absolute_name () return f \" { self . source . name } imports { what }{ target } (line { self . lineno } )\" @property def external ( self ) -> bool : \"\"\" Property to tell if the dependency's target is a valid node. Returns: Whether the dependency's target is a valid node. \"\"\" return isinstance ( self . target , str )","title":"Dependency"},{"location":"reference/dependenpy/dsm/#dependenpy.dsm.Dependency.__init__","text":"Initialization method. Parameters: Name Type Description Default source Module source Module. required lineno int number of line at which import statement occurs. required target str/Module/Package the target node. required what str what is imported (optional). None Source code in dependenpy/dsm.py 426 427 428 429 430 431 432 433 434 435 436 437 438 439 def __init__ ( self , source , lineno , target , what = None ): \"\"\" Initialization method. Args: source (Module): source Module. lineno (int): number of line at which import statement occurs. target (str/Module/Package): the target node. what (str): what is imported (optional). \"\"\" self . source = source self . lineno = lineno self . target = target self . what = what","title":"__init__()"},{"location":"reference/dependenpy/dsm/#dependenpy.dsm.Dependency.external","text":"Property to tell if the dependency's target is a valid node. Returns: Type Description bool Whether the dependency's target is a valid node. Source code in dependenpy/dsm.py 446 447 448 449 450 451 452 453 454 @property def external ( self ) -> bool : \"\"\" Property to tell if the dependency's target is a valid node. Returns: Whether the dependency's target is a valid node. \"\"\" return isinstance ( self . target , str )","title":"external()"},{"location":"reference/dependenpy/dsm/#dependenpy.dsm.Module","text":"Bases: LeafNode , NodeMixin , PrintMixin Module class. This class represents a Python module (a Python file). Source code in dependenpy/dsm.py 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 class Module ( LeafNode , NodeMixin , PrintMixin ): # noqa: WPS338 \"\"\" Module class. This class represents a Python module (a Python file). \"\"\" RECURSIVE_NODES = ( ast . ClassDef , ast . FunctionDef , ast . If , ast . IfExp , ast . Try , ast . With , ast . ExceptHandler ) def __init__ ( self , name , path , dsm = None , package = None ): \"\"\" Initialization method. Args: name (str): name of the module. path (str): path to the module. dsm (DSM): parent DSM. package (Package): parent Package. \"\"\" super () . __init__ () self . name = name self . path = path self . package = package self . dsm = dsm self . dependencies = [] def __contains__ ( self , item ) -> bool : \"\"\" Whether given item is contained inside this module. Args: item (Package/Module): a package or module. Returns: True if self is item or item is self's package and self if an `__init__` module. \"\"\" if self is item : return True elif self . package is item and self . name == \"__init__\" : return True return False @property def ismodule ( self ) -> bool : \"\"\" Inherited from NodeMixin. Always True. Returns: Whether this object is a module. \"\"\" return True def as_dict ( self , absolute : bool = False ) -> dict : \"\"\" Return the dependencies as a dictionary. Arguments: absolute: Whether to use the absolute name. Returns: dict: dictionary of dependencies. \"\"\" return { \"name\" : self . absolute_name () if absolute else self . name , \"path\" : self . path , \"dependencies\" : [ { # 'source': d.source.absolute_name(), # redundant \"target\" : dep . target if dep . external else dep . target . absolute_name (), \"lineno\" : dep . lineno , \"what\" : dep . what , \"external\" : dep . external , } for dep in self . dependencies ], } def _to_text ( self , ** kwargs ): indent = kwargs . pop ( \"indent\" , 2 ) base_indent = kwargs . pop ( \"base_indent\" , None ) if base_indent is None : base_indent = indent indent = 0 text = [ \" \" * indent + self . name + \" \\n \" ] new_indent = indent + base_indent for dep in self . dependencies : external = \"! \" if dep . external else \"\" text . append ( \" \" * new_indent + external + str ( dep ) + \" \\n \" ) return \"\" . join ( text ) def _to_csv ( self , ** kwargs ): header = kwargs . pop ( \"header\" , True ) text = [ \"module,path,target,lineno,what,external \\n \" if header else \"\" ] name = self . absolute_name () for dep in self . dependencies : target = dep . target if dep . external else dep . target . absolute_name () text . append ( f \" { name } , { self . path } , { target } , { dep . lineno } , { dep . what or '' } , { dep . external } \\n \" ) return \"\" . join ( text ) def _to_json ( self , ** kwargs ): absolute = kwargs . pop ( \"absolute\" , False ) return json . dumps ( self . as_dict ( absolute = absolute ), ** kwargs ) def build_dependencies ( self ): \"\"\" Build the dependencies for this module. Parse the code with ast, find all the import statements, convert them into Dependency objects. \"\"\" highest = self . dsm or self . root if self is highest : highest = LeafNode () for import_ in self . parse_code (): target = highest . get_target ( import_ [ \"target\" ]) if target : what = import_ [ \"target\" ] . split ( \".\" )[ - 1 ] if what != target . name : import_ [ \"what\" ] = what import_ [ \"target\" ] = target self . dependencies . append ( Dependency ( source = self , ** import_ )) def parse_code ( self ) -> list [ dict ]: \"\"\" Read the source code and return all the import statements. Returns: list of dict: the import statements. \"\"\" code = Path ( self . path ) . read_text ( encoding = \"utf-8\" ) try : body = ast . parse ( code ) . body except SyntaxError : code = code . encode ( \"utf-8\" ) # type: ignore[assignment] try : # noqa: WPS505 body = ast . parse ( code ) . body except SyntaxError : return [] return self . get_imports ( body ) def get_imports ( self , ast_body ) -> list [ dict ]: # noqa: WPS231,WPS615 \"\"\" Return all the import statements given an AST body (AST nodes). Args: ast_body (compiled code's body): the body to filter. Returns: The import statements. \"\"\" imports : list [ dict ] = [] for node in ast_body : if isinstance ( node , ast . Import ): imports . extend ({ \"target\" : name . name , \"lineno\" : node . lineno } for name in node . names ) elif isinstance ( node , ast . ImportFrom ): for name in node . names : abs_name = self . absolute_name ( self . depth - node . level ) + \".\" if node . level > 0 else \"\" node_module = node . module + \".\" if node . module else \"\" name = abs_name + node_module + name . name # type: ignore[assignment] imports . append ({ \"target\" : name , \"lineno\" : node . lineno }) elif isinstance ( node , Module . RECURSIVE_NODES ): imports . extend ( self . get_imports ( node . body )) if isinstance ( node , ast . Try ): imports . extend ( self . get_imports ( node . finalbody )) return imports def cardinal ( self , to ) -> int : \"\"\" Return the number of dependencies of this module to the given node. Args: to (Package/Module): the target node. Returns: Number of dependencies. \"\"\" return len ([ dep for dep in self . dependencies if not dep . external and dep . target in to ])","title":"Module"},{"location":"reference/dependenpy/dsm/#dependenpy.dsm.Module.__contains__","text":"Whether given item is contained inside this module. Parameters: Name Type Description Default item Package/Module a package or module. required Returns: Type Description bool True if self is item or item is self's package and self if an __init__ module. Source code in dependenpy/dsm.py 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 def __contains__ ( self , item ) -> bool : \"\"\" Whether given item is contained inside this module. Args: item (Package/Module): a package or module. Returns: True if self is item or item is self's package and self if an `__init__` module. \"\"\" if self is item : return True elif self . package is item and self . name == \"__init__\" : return True return False","title":"__contains__()"},{"location":"reference/dependenpy/dsm/#dependenpy.dsm.Module.__init__","text":"Initialization method. Parameters: Name Type Description Default name str name of the module. required path str path to the module. required dsm DSM parent DSM. None package Package parent Package. None Source code in dependenpy/dsm.py 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 def __init__ ( self , name , path , dsm = None , package = None ): \"\"\" Initialization method. Args: name (str): name of the module. path (str): path to the module. dsm (DSM): parent DSM. package (Package): parent Package. \"\"\" super () . __init__ () self . name = name self . path = path self . package = package self . dsm = dsm self . dependencies = []","title":"__init__()"},{"location":"reference/dependenpy/dsm/#dependenpy.dsm.Module.as_dict","text":"Return the dependencies as a dictionary. Parameters: Name Type Description Default absolute bool Whether to use the absolute name. False Returns: Name Type Description dict dict dictionary of dependencies. Source code in dependenpy/dsm.py 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 def as_dict ( self , absolute : bool = False ) -> dict : \"\"\" Return the dependencies as a dictionary. Arguments: absolute: Whether to use the absolute name. Returns: dict: dictionary of dependencies. \"\"\" return { \"name\" : self . absolute_name () if absolute else self . name , \"path\" : self . path , \"dependencies\" : [ { # 'source': d.source.absolute_name(), # redundant \"target\" : dep . target if dep . external else dep . target . absolute_name (), \"lineno\" : dep . lineno , \"what\" : dep . what , \"external\" : dep . external , } for dep in self . dependencies ], }","title":"as_dict()"},{"location":"reference/dependenpy/dsm/#dependenpy.dsm.Module.build_dependencies","text":"Build the dependencies for this module. Parse the code with ast, find all the import statements, convert them into Dependency objects. Source code in dependenpy/dsm.py 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 def build_dependencies ( self ): \"\"\" Build the dependencies for this module. Parse the code with ast, find all the import statements, convert them into Dependency objects. \"\"\" highest = self . dsm or self . root if self is highest : highest = LeafNode () for import_ in self . parse_code (): target = highest . get_target ( import_ [ \"target\" ]) if target : what = import_ [ \"target\" ] . split ( \".\" )[ - 1 ] if what != target . name : import_ [ \"what\" ] = what import_ [ \"target\" ] = target self . dependencies . append ( Dependency ( source = self , ** import_ ))","title":"build_dependencies()"},{"location":"reference/dependenpy/dsm/#dependenpy.dsm.Module.cardinal","text":"Return the number of dependencies of this module to the given node. Parameters: Name Type Description Default to Package/Module the target node. required Returns: Type Description int Number of dependencies. Source code in dependenpy/dsm.py 406 407 408 409 410 411 412 413 414 415 416 def cardinal ( self , to ) -> int : \"\"\" Return the number of dependencies of this module to the given node. Args: to (Package/Module): the target node. Returns: Number of dependencies. \"\"\" return len ([ dep for dep in self . dependencies if not dep . external and dep . target in to ])","title":"cardinal()"},{"location":"reference/dependenpy/dsm/#dependenpy.dsm.Module.get_imports","text":"Return all the import statements given an AST body (AST nodes). Parameters: Name Type Description Default ast_body compiled code's body the body to filter. required Returns: Type Description list [ dict ] The import statements. Source code in dependenpy/dsm.py 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 def get_imports ( self , ast_body ) -> list [ dict ]: # noqa: WPS231,WPS615 \"\"\" Return all the import statements given an AST body (AST nodes). Args: ast_body (compiled code's body): the body to filter. Returns: The import statements. \"\"\" imports : list [ dict ] = [] for node in ast_body : if isinstance ( node , ast . Import ): imports . extend ({ \"target\" : name . name , \"lineno\" : node . lineno } for name in node . names ) elif isinstance ( node , ast . ImportFrom ): for name in node . names : abs_name = self . absolute_name ( self . depth - node . level ) + \".\" if node . level > 0 else \"\" node_module = node . module + \".\" if node . module else \"\" name = abs_name + node_module + name . name # type: ignore[assignment] imports . append ({ \"target\" : name , \"lineno\" : node . lineno }) elif isinstance ( node , Module . RECURSIVE_NODES ): imports . extend ( self . get_imports ( node . body )) if isinstance ( node , ast . Try ): imports . extend ( self . get_imports ( node . finalbody )) return imports","title":"get_imports()"},{"location":"reference/dependenpy/dsm/#dependenpy.dsm.Module.ismodule","text":"Inherited from NodeMixin. Always True. Returns: Type Description bool Whether this object is a module. Source code in dependenpy/dsm.py 282 283 284 285 286 287 288 289 290 @property def ismodule ( self ) -> bool : \"\"\" Inherited from NodeMixin. Always True. Returns: Whether this object is a module. \"\"\" return True","title":"ismodule()"},{"location":"reference/dependenpy/dsm/#dependenpy.dsm.Module.parse_code","text":"Read the source code and return all the import statements. Returns: Type Description list [ dict ] list of dict: the import statements. Source code in dependenpy/dsm.py 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 def parse_code ( self ) -> list [ dict ]: \"\"\" Read the source code and return all the import statements. Returns: list of dict: the import statements. \"\"\" code = Path ( self . path ) . read_text ( encoding = \"utf-8\" ) try : body = ast . parse ( code ) . body except SyntaxError : code = code . encode ( \"utf-8\" ) # type: ignore[assignment] try : # noqa: WPS505 body = ast . parse ( code ) . body except SyntaxError : return [] return self . get_imports ( body )","title":"parse_code()"},{"location":"reference/dependenpy/dsm/#dependenpy.dsm.Package","text":"Bases: RootNode , LeafNode , NodeMixin , PrintMixin Package class. This class represent Python packages as nodes in a tree. Source code in dependenpy/dsm.py 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 class Package ( RootNode , LeafNode , NodeMixin , PrintMixin ): # noqa: WPS215 \"\"\" Package class. This class represent Python packages as nodes in a tree. \"\"\" def __init__ ( self , name : str , path : str , dsm : DSM = None , package : \"Package\" = None , limit_to : List [ str ] = None , build_tree : bool = True , build_dependencies : bool = True , enforce_init : bool = True , ): \"\"\" Initialization method. Args: name: name of the package. path: path to the package. dsm: parent DSM. package: parent package. limit_to: list of string to limit the recursive tree-building to what is specified. build_tree: auto-build the tree or not. build_dependencies: auto-build the dependencies or not. enforce_init: if True, only treat directories if they contain an `__init__.py` file. \"\"\" self . name = name self . path = path self . package = package self . dsm = dsm self . limit_to = limit_to or [] self . enforce_init = enforce_init RootNode . __init__ ( self , build_tree ) # noqa: WPS609 LeafNode . __init__ ( self ) # noqa: WPS609 if build_tree and build_dependencies : self . build_dependencies () @property def ispackage ( self ) -> bool : \"\"\" Inherited from NodeMixin. Always True. Returns: Whether this object is a package. \"\"\" return True @property def issubpackage ( self ) -> bool : \"\"\" Property to tell if this node is a sub-package. Returns: This package has a parent. \"\"\" return self . package is not None @property def isroot ( self ) -> bool : \"\"\" Property to tell if this node is a root node. Returns: This package has no parent. \"\"\" return self . package is None def split_limits_heads ( self ) -> tuple [ list [ str ], list [ str ]]: \"\"\" Return first parts of dot-separated strings, and rest of strings. Returns: The heads and rest of the strings. \"\"\" heads = [] new_limit_to = [] for limit in self . limit_to : if \".\" in limit : name , limit = limit . split ( \".\" , 1 ) # noqa: WPS440 heads . append ( name ) new_limit_to . append ( limit ) else : heads . append ( limit ) return heads , new_limit_to def build_tree ( self ): # noqa: WPS231 \"\"\"Build the tree for this package.\"\"\" for module in listdir ( self . path ): abs_m = join ( self . path , module ) if isfile ( abs_m ) and module . endswith ( \".py\" ): name = splitext ( module )[ 0 ] if not self . limit_to or name in self . limit_to : self . modules . append ( Module ( name , abs_m , self . dsm , self )) elif isdir ( abs_m ): if isfile ( join ( abs_m , \"__init__.py\" )) or not self . enforce_init : heads , new_limit_to = self . split_limits_heads () if not heads or module in heads : self . packages . append ( Package ( module , abs_m , self . dsm , self , new_limit_to , build_tree = True , build_dependencies = False , enforce_init = self . enforce_init , ) ) def cardinal ( self , to ) -> int : \"\"\" Return the number of dependencies of this package to the given node. Args: to (Package/Module): target node. Returns: Number of dependencies. \"\"\" return sum ( module . cardinal ( to ) for module in self . submodules )","title":"Package"},{"location":"reference/dependenpy/dsm/#dependenpy.dsm.Package.__init__","text":"Initialization method. Parameters: Name Type Description Default name str name of the package. required path str path to the package. required dsm DSM parent DSM. None package 'Package' parent package. None limit_to List [ str ] list of string to limit the recursive tree-building to what is specified. None build_tree bool auto-build the tree or not. True build_dependencies bool auto-build the dependencies or not. True enforce_init bool if True, only treat directories if they contain an __init__.py file. True Source code in dependenpy/dsm.py 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 def __init__ ( self , name : str , path : str , dsm : DSM = None , package : \"Package\" = None , limit_to : List [ str ] = None , build_tree : bool = True , build_dependencies : bool = True , enforce_init : bool = True , ): \"\"\" Initialization method. Args: name: name of the package. path: path to the package. dsm: parent DSM. package: parent package. limit_to: list of string to limit the recursive tree-building to what is specified. build_tree: auto-build the tree or not. build_dependencies: auto-build the dependencies or not. enforce_init: if True, only treat directories if they contain an `__init__.py` file. \"\"\" self . name = name self . path = path self . package = package self . dsm = dsm self . limit_to = limit_to or [] self . enforce_init = enforce_init RootNode . __init__ ( self , build_tree ) # noqa: WPS609 LeafNode . __init__ ( self ) # noqa: WPS609 if build_tree and build_dependencies : self . build_dependencies ()","title":"__init__()"},{"location":"reference/dependenpy/dsm/#dependenpy.dsm.Package.build_tree","text":"Build the tree for this package. Source code in dependenpy/dsm.py 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 def build_tree ( self ): # noqa: WPS231 \"\"\"Build the tree for this package.\"\"\" for module in listdir ( self . path ): abs_m = join ( self . path , module ) if isfile ( abs_m ) and module . endswith ( \".py\" ): name = splitext ( module )[ 0 ] if not self . limit_to or name in self . limit_to : self . modules . append ( Module ( name , abs_m , self . dsm , self )) elif isdir ( abs_m ): if isfile ( join ( abs_m , \"__init__.py\" )) or not self . enforce_init : heads , new_limit_to = self . split_limits_heads () if not heads or module in heads : self . packages . append ( Package ( module , abs_m , self . dsm , self , new_limit_to , build_tree = True , build_dependencies = False , enforce_init = self . enforce_init , ) )","title":"build_tree()"},{"location":"reference/dependenpy/dsm/#dependenpy.dsm.Package.cardinal","text":"Return the number of dependencies of this package to the given node. Parameters: Name Type Description Default to Package/Module target node. required Returns: Type Description int Number of dependencies. Source code in dependenpy/dsm.py 226 227 228 229 230 231 232 233 234 235 236 def cardinal ( self , to ) -> int : \"\"\" Return the number of dependencies of this package to the given node. Args: to (Package/Module): target node. Returns: Number of dependencies. \"\"\" return sum ( module . cardinal ( to ) for module in self . submodules )","title":"cardinal()"},{"location":"reference/dependenpy/dsm/#dependenpy.dsm.Package.ispackage","text":"Inherited from NodeMixin. Always True. Returns: Type Description bool Whether this object is a package. Source code in dependenpy/dsm.py 153 154 155 156 157 158 159 160 161 @property def ispackage ( self ) -> bool : \"\"\" Inherited from NodeMixin. Always True. Returns: Whether this object is a package. \"\"\" return True","title":"ispackage()"},{"location":"reference/dependenpy/dsm/#dependenpy.dsm.Package.isroot","text":"Property to tell if this node is a root node. Returns: Type Description bool This package has no parent. Source code in dependenpy/dsm.py 173 174 175 176 177 178 179 180 181 @property def isroot ( self ) -> bool : \"\"\" Property to tell if this node is a root node. Returns: This package has no parent. \"\"\" return self . package is None","title":"isroot()"},{"location":"reference/dependenpy/dsm/#dependenpy.dsm.Package.issubpackage","text":"Property to tell if this node is a sub-package. Returns: Type Description bool This package has a parent. Source code in dependenpy/dsm.py 163 164 165 166 167 168 169 170 171 @property def issubpackage ( self ) -> bool : \"\"\" Property to tell if this node is a sub-package. Returns: This package has a parent. \"\"\" return self . package is not None","title":"issubpackage()"},{"location":"reference/dependenpy/dsm/#dependenpy.dsm.Package.split_limits_heads","text":"Return first parts of dot-separated strings, and rest of strings. Returns: Type Description tuple [ list [ str ], list [ str ]] The heads and rest of the strings. Source code in dependenpy/dsm.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 def split_limits_heads ( self ) -> tuple [ list [ str ], list [ str ]]: \"\"\" Return first parts of dot-separated strings, and rest of strings. Returns: The heads and rest of the strings. \"\"\" heads = [] new_limit_to = [] for limit in self . limit_to : if \".\" in limit : name , limit = limit . split ( \".\" , 1 ) # noqa: WPS440 heads . append ( name ) new_limit_to . append ( limit ) else : heads . append ( limit ) return heads , new_limit_to","title":"split_limits_heads()"},{"location":"reference/dependenpy/finder/","text":"dependenpy finder module. Finder \u00a4 Bases: object Main package finder class. Initialize it with a list of package finder classes (not instances). Source code in dependenpy/finder.py 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 class Finder ( object ): \"\"\" Main package finder class. Initialize it with a list of package finder classes (not instances). \"\"\" def __init__ ( self , finders : List [ Type ] = None ): \"\"\" Initialization method. Args: finders: list of package finder classes (not instances) in a specific order. Default: [LocalPackageFinder, InstalledPackageFinder]. \"\"\" if finders is None : self . finders = [ LocalPackageFinder (), InstalledPackageFinder ()] else : self . finders = [ finder () for finder in finders ] def find ( self , package : str , ** kwargs : Any ) -> PackageSpec | None : \"\"\" Find a package using package finders. Return the first package found. Args: package: package to find. **kwargs: additional keyword arguments used by finders. Returns: Package spec or None. \"\"\" for finder in self . finders : package_spec = finder . find ( package , ** kwargs ) if package_spec : return package_spec return None __init__ ( finders = None ) \u00a4 Initialization method. Parameters: Name Type Description Default finders List [ Type ] list of package finder classes (not instances) in a specific order. Default: [LocalPackageFinder, InstalledPackageFinder]. None Source code in dependenpy/finder.py 156 157 158 159 160 161 162 163 164 165 166 167 def __init__ ( self , finders : List [ Type ] = None ): \"\"\" Initialization method. Args: finders: list of package finder classes (not instances) in a specific order. Default: [LocalPackageFinder, InstalledPackageFinder]. \"\"\" if finders is None : self . finders = [ LocalPackageFinder (), InstalledPackageFinder ()] else : self . finders = [ finder () for finder in finders ] find ( package , ** kwargs ) \u00a4 Find a package using package finders. Return the first package found. Parameters: Name Type Description Default package str package to find. required **kwargs Any additional keyword arguments used by finders. {} Returns: Type Description PackageSpec | None Package spec or None. Source code in dependenpy/finder.py 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 def find ( self , package : str , ** kwargs : Any ) -> PackageSpec | None : \"\"\" Find a package using package finders. Return the first package found. Args: package: package to find. **kwargs: additional keyword arguments used by finders. Returns: Package spec or None. \"\"\" for finder in self . finders : package_spec = finder . find ( package , ** kwargs ) if package_spec : return package_spec return None InstalledPackageFinder \u00a4 Bases: PackageFinder Finder to find installed Python packages using importlib. Source code in dependenpy/finder.py 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 class InstalledPackageFinder ( PackageFinder ): \"\"\"Finder to find installed Python packages using importlib.\"\"\" def find ( self , package : str , ** kwargs : Any ) -> PackageSpec | None : \"\"\" Find method. Args: package: package to find. **kwargs: additional keyword arguments. Returns: Package spec or None. \"\"\" spec = find_spec ( package ) if spec is None : return None if \".\" in package : package , rest = package . split ( \".\" , 1 ) limit = [ rest ] spec = find_spec ( package ) else : limit = [] if spec is not None : if spec . submodule_search_locations : path = spec . submodule_search_locations [ 0 ] elif spec . origin and spec . origin != \"built-in\" : path = spec . origin else : return None return PackageSpec ( spec . name , path , limit ) return None find ( package , ** kwargs ) \u00a4 Find method. Parameters: Name Type Description Default package str package to find. required **kwargs Any additional keyword arguments. {} Returns: Type Description PackageSpec | None Package spec or None. Source code in dependenpy/finder.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 def find ( self , package : str , ** kwargs : Any ) -> PackageSpec | None : \"\"\" Find method. Args: package: package to find. **kwargs: additional keyword arguments. Returns: Package spec or None. \"\"\" spec = find_spec ( package ) if spec is None : return None if \".\" in package : package , rest = package . split ( \".\" , 1 ) limit = [ rest ] spec = find_spec ( package ) else : limit = [] if spec is not None : if spec . submodule_search_locations : path = spec . submodule_search_locations [ 0 ] elif spec . origin and spec . origin != \"built-in\" : path = spec . origin else : return None return PackageSpec ( spec . name , path , limit ) return None LocalPackageFinder \u00a4 Bases: PackageFinder Finder to find local packages (directories on the disk). Source code in dependenpy/finder.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 class LocalPackageFinder ( PackageFinder ): \"\"\"Finder to find local packages (directories on the disk).\"\"\" def find ( self , package : str , ** kwargs : Any ) -> PackageSpec | None : \"\"\" Find method. Args: package: package to find. **kwargs: additional keyword arguments. Returns: Package spec or None. \"\"\" if not exists ( package ): return None name , path = None , None enforce_init = kwargs . pop ( \"enforce_init\" , True ) if isdir ( package ): if isfile ( join ( package , \"__init__.py\" )) or not enforce_init : name , path = basename ( package ), package elif isfile ( package ) and package . endswith ( \".py\" ): name , path = splitext ( basename ( package ))[ 0 ], package if name and path : return PackageSpec ( name , path ) return None find ( package , ** kwargs ) \u00a4 Find method. Parameters: Name Type Description Default package str package to find. required **kwargs Any additional keyword arguments. {} Returns: Type Description PackageSpec | None Package spec or None. Source code in dependenpy/finder.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 def find ( self , package : str , ** kwargs : Any ) -> PackageSpec | None : \"\"\" Find method. Args: package: package to find. **kwargs: additional keyword arguments. Returns: Package spec or None. \"\"\" if not exists ( package ): return None name , path = None , None enforce_init = kwargs . pop ( \"enforce_init\" , True ) if isdir ( package ): if isfile ( join ( package , \"__init__.py\" )) or not enforce_init : name , path = basename ( package ), package elif isfile ( package ) and package . endswith ( \".py\" ): name , path = splitext ( basename ( package ))[ 0 ], package if name and path : return PackageSpec ( name , path ) return None PackageFinder \u00a4 Bases: object Abstract package finder class. Source code in dependenpy/finder.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 class PackageFinder ( object ): \"\"\"Abstract package finder class.\"\"\" def find ( self , package : str , ** kwargs : Any ) -> PackageSpec | None : \"\"\" Find method. Args: package: package to find. **kwargs: additional keyword arguments. Returns: Package spec or None. \"\"\" # noqa: DAR202,DAR401 raise NotImplementedError find ( package , ** kwargs ) \u00a4 Find method. Parameters: Name Type Description Default package str package to find. required **kwargs Any additional keyword arguments. {} Returns: Type Description PackageSpec | None Package spec or None. Source code in dependenpy/finder.py 73 74 75 76 77 78 79 80 81 82 83 84 def find ( self , package : str , ** kwargs : Any ) -> PackageSpec | None : \"\"\" Find method. Args: package: package to find. **kwargs: additional keyword arguments. Returns: Package spec or None. \"\"\" # noqa: DAR202,DAR401 raise NotImplementedError PackageSpec \u00a4 Bases: object Holder for a package specification (given as argument to DSM). Source code in dependenpy/finder.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 class PackageSpec ( object ): \"\"\"Holder for a package specification (given as argument to DSM).\"\"\" def __init__ ( self , name , path , limit_to = None ): \"\"\" Initialization method. Args: name (str): name of the package. path (str): path to the package. limit_to (list of str): limitations. \"\"\" self . name = name self . path = path self . limit_to = limit_to or [] def __hash__ ( self ): return hash (( self . name , self . path )) @property def ismodule ( self ) -> bool : \"\"\" Property to tell if the package is in fact a module (a file). Returns: Whether this package is in fact a module. \"\"\" return self . path . endswith ( \".py\" ) def add ( self , spec : PackageSpec ) -> None : \"\"\" Add limitations of given spec to self's. Args: spec: Another spec. \"\"\" for limit in spec . limit_to : if limit not in self . limit_to : self . limit_to . append ( limit ) @staticmethod # noqa: WPS602 def combine ( specs : list [ PackageSpec ]) -> list [ PackageSpec ]: # noqa: WPS602 \"\"\" Combine package specifications' limitations. Args: specs: The package specifications. Returns: The new, merged list of PackageSpec. \"\"\" new_specs : dict [ PackageSpec , PackageSpec ] = {} for spec in specs : if new_specs . get ( spec , None ) is None : new_specs [ spec ] = spec else : new_specs [ spec ] . add ( spec ) return list ( new_specs . values ()) __init__ ( name , path , limit_to = None ) \u00a4 Initialization method. Parameters: Name Type Description Default name str name of the package. required path str path to the package. required limit_to list of str limitations. None Source code in dependenpy/finder.py 13 14 15 16 17 18 19 20 21 22 23 24 def __init__ ( self , name , path , limit_to = None ): \"\"\" Initialization method. Args: name (str): name of the package. path (str): path to the package. limit_to (list of str): limitations. \"\"\" self . name = name self . path = path self . limit_to = limit_to or [] add ( spec ) \u00a4 Add limitations of given spec to self's. Parameters: Name Type Description Default spec PackageSpec Another spec. required Source code in dependenpy/finder.py 39 40 41 42 43 44 45 46 47 48 def add ( self , spec : PackageSpec ) -> None : \"\"\" Add limitations of given spec to self's. Args: spec: Another spec. \"\"\" for limit in spec . limit_to : if limit not in self . limit_to : self . limit_to . append ( limit ) combine ( specs ) staticmethod \u00a4 Combine package specifications' limitations. Parameters: Name Type Description Default specs list [ PackageSpec ] The package specifications. required Returns: Type Description list [ PackageSpec ] The new, merged list of PackageSpec. Source code in dependenpy/finder.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 @staticmethod # noqa: WPS602 def combine ( specs : list [ PackageSpec ]) -> list [ PackageSpec ]: # noqa: WPS602 \"\"\" Combine package specifications' limitations. Args: specs: The package specifications. Returns: The new, merged list of PackageSpec. \"\"\" new_specs : dict [ PackageSpec , PackageSpec ] = {} for spec in specs : if new_specs . get ( spec , None ) is None : new_specs [ spec ] = spec else : new_specs [ spec ] . add ( spec ) return list ( new_specs . values ()) ismodule () property \u00a4 Property to tell if the package is in fact a module (a file). Returns: Type Description bool Whether this package is in fact a module. Source code in dependenpy/finder.py 29 30 31 32 33 34 35 36 37 @property def ismodule ( self ) -> bool : \"\"\" Property to tell if the package is in fact a module (a file). Returns: Whether this package is in fact a module. \"\"\" return self . path . endswith ( \".py\" )","title":"finder"},{"location":"reference/dependenpy/finder/#dependenpy.finder.Finder","text":"Bases: object Main package finder class. Initialize it with a list of package finder classes (not instances). Source code in dependenpy/finder.py 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 class Finder ( object ): \"\"\" Main package finder class. Initialize it with a list of package finder classes (not instances). \"\"\" def __init__ ( self , finders : List [ Type ] = None ): \"\"\" Initialization method. Args: finders: list of package finder classes (not instances) in a specific order. Default: [LocalPackageFinder, InstalledPackageFinder]. \"\"\" if finders is None : self . finders = [ LocalPackageFinder (), InstalledPackageFinder ()] else : self . finders = [ finder () for finder in finders ] def find ( self , package : str , ** kwargs : Any ) -> PackageSpec | None : \"\"\" Find a package using package finders. Return the first package found. Args: package: package to find. **kwargs: additional keyword arguments used by finders. Returns: Package spec or None. \"\"\" for finder in self . finders : package_spec = finder . find ( package , ** kwargs ) if package_spec : return package_spec return None","title":"Finder"},{"location":"reference/dependenpy/finder/#dependenpy.finder.Finder.__init__","text":"Initialization method. Parameters: Name Type Description Default finders List [ Type ] list of package finder classes (not instances) in a specific order. Default: [LocalPackageFinder, InstalledPackageFinder]. None Source code in dependenpy/finder.py 156 157 158 159 160 161 162 163 164 165 166 167 def __init__ ( self , finders : List [ Type ] = None ): \"\"\" Initialization method. Args: finders: list of package finder classes (not instances) in a specific order. Default: [LocalPackageFinder, InstalledPackageFinder]. \"\"\" if finders is None : self . finders = [ LocalPackageFinder (), InstalledPackageFinder ()] else : self . finders = [ finder () for finder in finders ]","title":"__init__()"},{"location":"reference/dependenpy/finder/#dependenpy.finder.Finder.find","text":"Find a package using package finders. Return the first package found. Parameters: Name Type Description Default package str package to find. required **kwargs Any additional keyword arguments used by finders. {} Returns: Type Description PackageSpec | None Package spec or None. Source code in dependenpy/finder.py 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 def find ( self , package : str , ** kwargs : Any ) -> PackageSpec | None : \"\"\" Find a package using package finders. Return the first package found. Args: package: package to find. **kwargs: additional keyword arguments used by finders. Returns: Package spec or None. \"\"\" for finder in self . finders : package_spec = finder . find ( package , ** kwargs ) if package_spec : return package_spec return None","title":"find()"},{"location":"reference/dependenpy/finder/#dependenpy.finder.InstalledPackageFinder","text":"Bases: PackageFinder Finder to find installed Python packages using importlib. Source code in dependenpy/finder.py 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 class InstalledPackageFinder ( PackageFinder ): \"\"\"Finder to find installed Python packages using importlib.\"\"\" def find ( self , package : str , ** kwargs : Any ) -> PackageSpec | None : \"\"\" Find method. Args: package: package to find. **kwargs: additional keyword arguments. Returns: Package spec or None. \"\"\" spec = find_spec ( package ) if spec is None : return None if \".\" in package : package , rest = package . split ( \".\" , 1 ) limit = [ rest ] spec = find_spec ( package ) else : limit = [] if spec is not None : if spec . submodule_search_locations : path = spec . submodule_search_locations [ 0 ] elif spec . origin and spec . origin != \"built-in\" : path = spec . origin else : return None return PackageSpec ( spec . name , path , limit ) return None","title":"InstalledPackageFinder"},{"location":"reference/dependenpy/finder/#dependenpy.finder.InstalledPackageFinder.find","text":"Find method. Parameters: Name Type Description Default package str package to find. required **kwargs Any additional keyword arguments. {} Returns: Type Description PackageSpec | None Package spec or None. Source code in dependenpy/finder.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 def find ( self , package : str , ** kwargs : Any ) -> PackageSpec | None : \"\"\" Find method. Args: package: package to find. **kwargs: additional keyword arguments. Returns: Package spec or None. \"\"\" spec = find_spec ( package ) if spec is None : return None if \".\" in package : package , rest = package . split ( \".\" , 1 ) limit = [ rest ] spec = find_spec ( package ) else : limit = [] if spec is not None : if spec . submodule_search_locations : path = spec . submodule_search_locations [ 0 ] elif spec . origin and spec . origin != \"built-in\" : path = spec . origin else : return None return PackageSpec ( spec . name , path , limit ) return None","title":"find()"},{"location":"reference/dependenpy/finder/#dependenpy.finder.LocalPackageFinder","text":"Bases: PackageFinder Finder to find local packages (directories on the disk). Source code in dependenpy/finder.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 class LocalPackageFinder ( PackageFinder ): \"\"\"Finder to find local packages (directories on the disk).\"\"\" def find ( self , package : str , ** kwargs : Any ) -> PackageSpec | None : \"\"\" Find method. Args: package: package to find. **kwargs: additional keyword arguments. Returns: Package spec or None. \"\"\" if not exists ( package ): return None name , path = None , None enforce_init = kwargs . pop ( \"enforce_init\" , True ) if isdir ( package ): if isfile ( join ( package , \"__init__.py\" )) or not enforce_init : name , path = basename ( package ), package elif isfile ( package ) and package . endswith ( \".py\" ): name , path = splitext ( basename ( package ))[ 0 ], package if name and path : return PackageSpec ( name , path ) return None","title":"LocalPackageFinder"},{"location":"reference/dependenpy/finder/#dependenpy.finder.LocalPackageFinder.find","text":"Find method. Parameters: Name Type Description Default package str package to find. required **kwargs Any additional keyword arguments. {} Returns: Type Description PackageSpec | None Package spec or None. Source code in dependenpy/finder.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 def find ( self , package : str , ** kwargs : Any ) -> PackageSpec | None : \"\"\" Find method. Args: package: package to find. **kwargs: additional keyword arguments. Returns: Package spec or None. \"\"\" if not exists ( package ): return None name , path = None , None enforce_init = kwargs . pop ( \"enforce_init\" , True ) if isdir ( package ): if isfile ( join ( package , \"__init__.py\" )) or not enforce_init : name , path = basename ( package ), package elif isfile ( package ) and package . endswith ( \".py\" ): name , path = splitext ( basename ( package ))[ 0 ], package if name and path : return PackageSpec ( name , path ) return None","title":"find()"},{"location":"reference/dependenpy/finder/#dependenpy.finder.PackageFinder","text":"Bases: object Abstract package finder class. Source code in dependenpy/finder.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 class PackageFinder ( object ): \"\"\"Abstract package finder class.\"\"\" def find ( self , package : str , ** kwargs : Any ) -> PackageSpec | None : \"\"\" Find method. Args: package: package to find. **kwargs: additional keyword arguments. Returns: Package spec or None. \"\"\" # noqa: DAR202,DAR401 raise NotImplementedError","title":"PackageFinder"},{"location":"reference/dependenpy/finder/#dependenpy.finder.PackageFinder.find","text":"Find method. Parameters: Name Type Description Default package str package to find. required **kwargs Any additional keyword arguments. {} Returns: Type Description PackageSpec | None Package spec or None. Source code in dependenpy/finder.py 73 74 75 76 77 78 79 80 81 82 83 84 def find ( self , package : str , ** kwargs : Any ) -> PackageSpec | None : \"\"\" Find method. Args: package: package to find. **kwargs: additional keyword arguments. Returns: Package spec or None. \"\"\" # noqa: DAR202,DAR401 raise NotImplementedError","title":"find()"},{"location":"reference/dependenpy/finder/#dependenpy.finder.PackageSpec","text":"Bases: object Holder for a package specification (given as argument to DSM). Source code in dependenpy/finder.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 class PackageSpec ( object ): \"\"\"Holder for a package specification (given as argument to DSM).\"\"\" def __init__ ( self , name , path , limit_to = None ): \"\"\" Initialization method. Args: name (str): name of the package. path (str): path to the package. limit_to (list of str): limitations. \"\"\" self . name = name self . path = path self . limit_to = limit_to or [] def __hash__ ( self ): return hash (( self . name , self . path )) @property def ismodule ( self ) -> bool : \"\"\" Property to tell if the package is in fact a module (a file). Returns: Whether this package is in fact a module. \"\"\" return self . path . endswith ( \".py\" ) def add ( self , spec : PackageSpec ) -> None : \"\"\" Add limitations of given spec to self's. Args: spec: Another spec. \"\"\" for limit in spec . limit_to : if limit not in self . limit_to : self . limit_to . append ( limit ) @staticmethod # noqa: WPS602 def combine ( specs : list [ PackageSpec ]) -> list [ PackageSpec ]: # noqa: WPS602 \"\"\" Combine package specifications' limitations. Args: specs: The package specifications. Returns: The new, merged list of PackageSpec. \"\"\" new_specs : dict [ PackageSpec , PackageSpec ] = {} for spec in specs : if new_specs . get ( spec , None ) is None : new_specs [ spec ] = spec else : new_specs [ spec ] . add ( spec ) return list ( new_specs . values ())","title":"PackageSpec"},{"location":"reference/dependenpy/finder/#dependenpy.finder.PackageSpec.__init__","text":"Initialization method. Parameters: Name Type Description Default name str name of the package. required path str path to the package. required limit_to list of str limitations. None Source code in dependenpy/finder.py 13 14 15 16 17 18 19 20 21 22 23 24 def __init__ ( self , name , path , limit_to = None ): \"\"\" Initialization method. Args: name (str): name of the package. path (str): path to the package. limit_to (list of str): limitations. \"\"\" self . name = name self . path = path self . limit_to = limit_to or []","title":"__init__()"},{"location":"reference/dependenpy/finder/#dependenpy.finder.PackageSpec.add","text":"Add limitations of given spec to self's. Parameters: Name Type Description Default spec PackageSpec Another spec. required Source code in dependenpy/finder.py 39 40 41 42 43 44 45 46 47 48 def add ( self , spec : PackageSpec ) -> None : \"\"\" Add limitations of given spec to self's. Args: spec: Another spec. \"\"\" for limit in spec . limit_to : if limit not in self . limit_to : self . limit_to . append ( limit )","title":"add()"},{"location":"reference/dependenpy/finder/#dependenpy.finder.PackageSpec.combine","text":"Combine package specifications' limitations. Parameters: Name Type Description Default specs list [ PackageSpec ] The package specifications. required Returns: Type Description list [ PackageSpec ] The new, merged list of PackageSpec. Source code in dependenpy/finder.py 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 @staticmethod # noqa: WPS602 def combine ( specs : list [ PackageSpec ]) -> list [ PackageSpec ]: # noqa: WPS602 \"\"\" Combine package specifications' limitations. Args: specs: The package specifications. Returns: The new, merged list of PackageSpec. \"\"\" new_specs : dict [ PackageSpec , PackageSpec ] = {} for spec in specs : if new_specs . get ( spec , None ) is None : new_specs [ spec ] = spec else : new_specs [ spec ] . add ( spec ) return list ( new_specs . values ())","title":"combine()"},{"location":"reference/dependenpy/finder/#dependenpy.finder.PackageSpec.ismodule","text":"Property to tell if the package is in fact a module (a file). Returns: Type Description bool Whether this package is in fact a module. Source code in dependenpy/finder.py 29 30 31 32 33 34 35 36 37 @property def ismodule ( self ) -> bool : \"\"\" Property to tell if the package is in fact a module (a file). Returns: Whether this package is in fact a module. \"\"\" return self . path . endswith ( \".py\" )","title":"ismodule()"},{"location":"reference/dependenpy/helpers/","text":"dependenpy printer module. PrintMixin \u00a4 Bases: object Print mixin class. Source code in dependenpy/helpers.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class PrintMixin ( object ): \"\"\"Print mixin class.\"\"\" def print ( self , format : str | None = TEXT , output : IO = sys . stdout , ** kwargs : Any ): # noqa: A002,A003 \"\"\" Print the object in a file or on standard output by default. Args: format: output format (csv, json or text). output: descriptor to an opened file (default to standard output). **kwargs: additional arguments. \"\"\" if format is None : format = TEXT if format != TEXT : kwargs . pop ( \"zero\" , \"\" ) if format == TEXT : print ( self . _to_text ( ** kwargs ), file = output ) elif format == CSV : print ( self . _to_csv ( ** kwargs ), file = output ) elif format == JSON : print ( self . _to_json ( ** kwargs ), file = output ) def _to_text ( self , ** kwargs ): raise NotImplementedError def _to_csv ( self , ** kwargs ): raise NotImplementedError def _to_json ( self , ** kwargs ): raise NotImplementedError print ( format = TEXT , output = sys . stdout , ** kwargs ) \u00a4 Print the object in a file or on standard output by default. Parameters: Name Type Description Default format str | None output format (csv, json or text). TEXT output IO descriptor to an opened file (default to standard output). sys.stdout **kwargs Any additional arguments. {} Source code in dependenpy/helpers.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def print ( self , format : str | None = TEXT , output : IO = sys . stdout , ** kwargs : Any ): # noqa: A002,A003 \"\"\" Print the object in a file or on standard output by default. Args: format: output format (csv, json or text). output: descriptor to an opened file (default to standard output). **kwargs: additional arguments. \"\"\" if format is None : format = TEXT if format != TEXT : kwargs . pop ( \"zero\" , \"\" ) if format == TEXT : print ( self . _to_text ( ** kwargs ), file = output ) elif format == CSV : print ( self . _to_csv ( ** kwargs ), file = output ) elif format == JSON : print ( self . _to_json ( ** kwargs ), file = output ) guess_depth ( packages ) \u00a4 Guess the optimal depth to use for the given list of arguments. Parameters: Name Type Description Default packages list [ str ] List of packages. required Returns: Type Description int Guessed depth to use. Source code in dependenpy/helpers.py 49 50 51 52 53 54 55 56 57 58 59 60 61 def guess_depth ( packages : list [ str ]) -> int : \"\"\" Guess the optimal depth to use for the given list of arguments. Args: packages: List of packages. Returns: Guessed depth to use. \"\"\" if len ( packages ) == 1 : return packages [ 0 ] . count ( \".\" ) + 2 return min ( package . count ( \".\" ) for package in packages ) + 1","title":"helpers"},{"location":"reference/dependenpy/helpers/#dependenpy.helpers.PrintMixin","text":"Bases: object Print mixin class. Source code in dependenpy/helpers.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class PrintMixin ( object ): \"\"\"Print mixin class.\"\"\" def print ( self , format : str | None = TEXT , output : IO = sys . stdout , ** kwargs : Any ): # noqa: A002,A003 \"\"\" Print the object in a file or on standard output by default. Args: format: output format (csv, json or text). output: descriptor to an opened file (default to standard output). **kwargs: additional arguments. \"\"\" if format is None : format = TEXT if format != TEXT : kwargs . pop ( \"zero\" , \"\" ) if format == TEXT : print ( self . _to_text ( ** kwargs ), file = output ) elif format == CSV : print ( self . _to_csv ( ** kwargs ), file = output ) elif format == JSON : print ( self . _to_json ( ** kwargs ), file = output ) def _to_text ( self , ** kwargs ): raise NotImplementedError def _to_csv ( self , ** kwargs ): raise NotImplementedError def _to_json ( self , ** kwargs ): raise NotImplementedError","title":"PrintMixin"},{"location":"reference/dependenpy/helpers/#dependenpy.helpers.PrintMixin.print","text":"Print the object in a file or on standard output by default. Parameters: Name Type Description Default format str | None output format (csv, json or text). TEXT output IO descriptor to an opened file (default to standard output). sys.stdout **kwargs Any additional arguments. {} Source code in dependenpy/helpers.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def print ( self , format : str | None = TEXT , output : IO = sys . stdout , ** kwargs : Any ): # noqa: A002,A003 \"\"\" Print the object in a file or on standard output by default. Args: format: output format (csv, json or text). output: descriptor to an opened file (default to standard output). **kwargs: additional arguments. \"\"\" if format is None : format = TEXT if format != TEXT : kwargs . pop ( \"zero\" , \"\" ) if format == TEXT : print ( self . _to_text ( ** kwargs ), file = output ) elif format == CSV : print ( self . _to_csv ( ** kwargs ), file = output ) elif format == JSON : print ( self . _to_json ( ** kwargs ), file = output )","title":"print()"},{"location":"reference/dependenpy/helpers/#dependenpy.helpers.guess_depth","text":"Guess the optimal depth to use for the given list of arguments. Parameters: Name Type Description Default packages list [ str ] List of packages. required Returns: Type Description int Guessed depth to use. Source code in dependenpy/helpers.py 49 50 51 52 53 54 55 56 57 58 59 60 61 def guess_depth ( packages : list [ str ]) -> int : \"\"\" Guess the optimal depth to use for the given list of arguments. Args: packages: List of packages. Returns: Guessed depth to use. \"\"\" if len ( packages ) == 1 : return packages [ 0 ] . count ( \".\" ) + 2 return min ( package . count ( \".\" ) for package in packages ) + 1","title":"guess_depth()"},{"location":"reference/dependenpy/node/","text":"dependenpy node module. LeafNode \u00a4 Bases: object Shared code between Package and Module. Source code in dependenpy/node.py 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 class LeafNode ( object ): \"\"\"Shared code between Package and Module.\"\"\" def __init__ ( self ): \"\"\"Initialization method.\"\"\" self . _depth_cache = None def __str__ ( self ): return self . absolute_name () @property def root ( self ) -> Package : \"\"\" Property to return the root of this node. Returns: Package: this node's root package. \"\"\" node : Package = self # type: ignore[assignment] while node . package is not None : node = node . package return node @property def depth ( self ) -> int : \"\"\" Property to tell the depth of the node in the tree. Returns: The node's depth in the tree. \"\"\" if self . _depth_cache is not None : return self . _depth_cache node : Package depth , node = 1 , self # type: ignore[assignment] while node . package is not None : depth += 1 node = node . package self . _depth_cache = depth return depth def absolute_name ( self , depth : int = 0 ) -> str : \"\"\" Return the absolute name of the node. Concatenate names from root to self within depth. Args: depth: Maximum depth to go to. Returns: Absolute name of the node (until given depth is reached). \"\"\" node : Package node , node_depth = self , self . depth # type: ignore[assignment] if depth < 1 : depth = node_depth while node_depth > depth and node . package is not None : node = node . package node_depth -= 1 names = [] while node is not None : names . append ( node . name ) node = node . package # type: ignore[assignment] return \".\" . join ( reversed ( names )) __init__ () \u00a4 Initialization method. Source code in dependenpy/node.py 371 372 373 def __init__ ( self ): \"\"\"Initialization method.\"\"\" self . _depth_cache = None absolute_name ( depth = 0 ) \u00a4 Return the absolute name of the node. Concatenate names from root to self within depth. Parameters: Name Type Description Default depth int Maximum depth to go to. 0 Returns: Type Description str Absolute name of the node (until given depth is reached). Source code in dependenpy/node.py 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 def absolute_name ( self , depth : int = 0 ) -> str : \"\"\" Return the absolute name of the node. Concatenate names from root to self within depth. Args: depth: Maximum depth to go to. Returns: Absolute name of the node (until given depth is reached). \"\"\" node : Package node , node_depth = self , self . depth # type: ignore[assignment] if depth < 1 : depth = node_depth while node_depth > depth and node . package is not None : node = node . package node_depth -= 1 names = [] while node is not None : names . append ( node . name ) node = node . package # type: ignore[assignment] return \".\" . join ( reversed ( names )) depth () property \u00a4 Property to tell the depth of the node in the tree. Returns: Type Description int The node's depth in the tree. Source code in dependenpy/node.py 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 @property def depth ( self ) -> int : \"\"\" Property to tell the depth of the node in the tree. Returns: The node's depth in the tree. \"\"\" if self . _depth_cache is not None : return self . _depth_cache node : Package depth , node = 1 , self # type: ignore[assignment] while node . package is not None : depth += 1 node = node . package self . _depth_cache = depth return depth root () property \u00a4 Property to return the root of this node. Returns: Name Type Description Package Package this node's root package. Source code in dependenpy/node.py 378 379 380 381 382 383 384 385 386 387 388 389 @property def root ( self ) -> Package : \"\"\" Property to return the root of this node. Returns: Package: this node's root package. \"\"\" node : Package = self # type: ignore[assignment] while node . package is not None : node = node . package return node NodeMixin \u00a4 Bases: object Shared code between DSM, Package and Module. Source code in dependenpy/node.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class NodeMixin ( object ): \"\"\"Shared code between DSM, Package and Module.\"\"\" @property def ismodule ( self ) -> bool : \"\"\" Property to check if object is instance of Module. Returns: Whether this object is a module. \"\"\" return False @property def ispackage ( self ) -> bool : \"\"\" Property to check if object is instance of Package. Returns: Whether this object is a package. \"\"\" return False @property def isdsm ( self ) -> bool : \"\"\" Property to check if object is instance of DSM. Returns: Whether this object is a DSM. \"\"\" return False isdsm () property \u00a4 Property to check if object is instance of DSM. Returns: Type Description bool Whether this object is a DSM. Source code in dependenpy/node.py 38 39 40 41 42 43 44 45 46 @property def isdsm ( self ) -> bool : \"\"\" Property to check if object is instance of DSM. Returns: Whether this object is a DSM. \"\"\" return False ismodule () property \u00a4 Property to check if object is instance of Module. Returns: Type Description bool Whether this object is a module. Source code in dependenpy/node.py 18 19 20 21 22 23 24 25 26 @property def ismodule ( self ) -> bool : \"\"\" Property to check if object is instance of Module. Returns: Whether this object is a module. \"\"\" return False ispackage () property \u00a4 Property to check if object is instance of Package. Returns: Type Description bool Whether this object is a package. Source code in dependenpy/node.py 28 29 30 31 32 33 34 35 36 @property def ispackage ( self ) -> bool : \"\"\" Property to check if object is instance of Package. Returns: Whether this object is a package. \"\"\" return False RootNode \u00a4 Bases: object Shared code between DSM and Package. Source code in dependenpy/node.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 class RootNode ( object ): \"\"\"Shared code between DSM and Package.\"\"\" def __init__ ( self , build_tree = True ): \"\"\" Initialization method. Args: build_tree (bool): whether to immediately build the tree or not. \"\"\" self . _target_cache = {} self . _item_cache = {} self . _contains_cache = {} self . _matrix_cache = {} self . _graph_cache = {} self . _treemap_cache = None self . modules = [] self . packages = [] if build_tree : self . build_tree () def __contains__ ( self , item : Package | Module ) -> bool : \"\"\" Get result of _contains, cache it and return it. Args: item: A package or module. Returns: True if self contains item, False otherwise. \"\"\" if item not in self . _contains_cache : self . _contains_cache [ item ] = self . _contains ( item ) return self . _contains_cache [ item ] def __getitem__ ( self , item : str ) -> Package | Module : # noqa: WPS231 \"\"\" Return the corresponding Package or Module object. Args: item: Name of the package/module, dot-separated. Raises: KeyError: When the package or module cannot be found. Returns: The corresponding object. \"\"\" depth = item . count ( \".\" ) + 1 parts = item . split ( \".\" , 1 ) for module in self . modules : if parts [ 0 ] == module . name : if depth == 1 : return module for package in self . packages : if parts [ 0 ] == package . name : if depth == 1 : return package obj = package . get ( parts [ 1 ]) if obj : return obj raise KeyError ( item ) def __bool__ ( self ) -> bool : \"\"\" Node as Boolean. Returns: Result of node.empty. \"\"\" return bool ( self . modules or self . packages ) @property def empty ( self ) -> bool : \"\"\" Whether the node has neither modules nor packages. Returns: True if empty, False otherwise. \"\"\" return not bool ( self ) @property def submodules ( self ) -> list [ Module ]: \"\"\" Property to return all sub-modules of the node, recursively. Returns: The sub-modules. \"\"\" submodules = [] submodules . extend ( self . modules ) for package in self . packages : submodules . extend ( package . submodules ) return submodules def build_tree ( self ): \"\"\"To be overridden.\"\"\" # noqa: DAR401 raise NotImplementedError def _contains ( self , item ): \"\"\" Whether given item is contained inside the node modules/packages. Args: item (Package/Module): a package or module. Returns: bool: True if self is item or item in self's packages/modules. \"\"\" if self is item : return True for module in self . modules : if item in module : return True for package in self . packages : if item in package : return True return False def get ( self , item : str ) -> Package | Module : \"\"\" Get item through `__getitem__` and cache the result. Args: item: Name of package or module. Returns: The corresponding object. \"\"\" if item not in self . _item_cache : try : obj = self . __getitem__ ( item ) except KeyError : obj = None self . _item_cache [ item ] = obj return self . _item_cache [ item ] def get_target ( self , target : str ) -> Package | Module : \"\"\" Get the result of _get_target, cache it and return it. Args: target: Target to find. Returns: Package containing target or corresponding module. \"\"\" if target not in self . _target_cache : self . _target_cache [ target ] = self . _get_target ( target ) return self . _target_cache [ target ] def _get_target ( self , target ): # noqa: WPS231 \"\"\" Get the Package or Module related to given target. Args: target (str): target to find. Returns: Package/Module: package containing target or corresponding module. \"\"\" depth = target . count ( \".\" ) + 1 parts = target . split ( \".\" , 1 ) for module in self . modules : if parts [ 0 ] == module . name : if depth < 3 : return module for package in self . packages : if parts [ 0 ] == package . name : if depth == 1 : return package target = package . _get_target ( parts [ 1 ]) # noqa: WPS437 if target : return target # FIXME: can lead to internal dep instead of external # see example with django.contrib.auth.forms # importing forms from django # Idea: when parsing files with ast, record what objects # are defined in the module. Then check here if the given # part is one of these objects. if depth < 3 : return package return None def build_dependencies ( self ): \"\"\" Recursively build the dependencies for sub-modules and sub-packages. Iterate on node's modules then packages and call their build_dependencies methods. \"\"\" for module in self . modules : module . build_dependencies () for package in self . packages : package . build_dependencies () def print_graph ( self , format : str | None = None , output : IO = sys . stdout , depth : int = 0 , ** kwargs : Any # noqa: A002 ): \"\"\" Print the graph for self's nodes. Args: format: Output format (csv, json or text). output: File descriptor on which to write. depth: Depth of the graph. **kwargs: Additional keyword arguments passed to `graph.print`. \"\"\" graph = self . as_graph ( depth = depth ) graph . print ( format = format , output = output , ** kwargs ) def print_matrix ( self , format : str | None = None , output : IO = sys . stdout , depth : int = 0 , ** kwargs : Any # noqa: A002 ): \"\"\" Print the matrix for self's nodes. Args: format: Output format (csv, json or text). output: File descriptor on which to write. depth: Depth of the matrix. **kwargs: Additional keyword arguments passed to `matrix.print`. \"\"\" matrix = self . as_matrix ( depth = depth ) matrix . print ( format = format , output = output , ** kwargs ) def print_treemap ( self , format : str | None = None , output : IO = sys . stdout , ** kwargs : Any ): # noqa: A002 \"\"\" Print the matrix for self's nodes. Args: format: Output format (csv, json or text). output: File descriptor on which to write. **kwargs: Additional keyword arguments passed to `treemap.print`. \"\"\" treemap = self . as_treemap () treemap . print ( format = format , output = output , ** kwargs ) def _to_text ( self , ** kwargs ): indent = kwargs . pop ( \"indent\" , 2 ) base_indent = kwargs . pop ( \"base_indent\" , None ) if base_indent is None : base_indent = indent indent = 0 text = [ \" \" * indent + str ( self ) + \" \\n \" ] new_indent = indent + base_indent for module in self . modules : text . append ( module . _to_text ( indent = new_indent , base_indent = base_indent )) # noqa: WPS437 for package in self . packages : text . append ( package . _to_text ( indent = new_indent , base_indent = base_indent )) # noqa: WPS437 return \"\" . join ( text ) def _to_csv ( self , ** kwargs ): header = kwargs . pop ( \"header\" , True ) modules = sorted ( self . submodules , key = lambda mod : mod . absolute_name ()) text = [ \"module,path,target,lineno,what,external \\n \" if header else \"\" ] for module in modules : text . append ( module . _to_csv ( header = False )) # noqa: WPS437 return \"\" . join ( text ) def _to_json ( self , ** kwargs ): return json . dumps ( self . as_dict (), ** kwargs ) def as_dict ( self ) -> dict : \"\"\" Return the dependencies as a dictionary. Returns: Dictionary of dependencies. \"\"\" return { \"name\" : str ( self ), \"modules\" : [ module . as_dict () for module in self . modules ], \"packages\" : [ package . as_dict () for package in self . packages ], } def as_graph ( self , depth : int = 0 ) -> Graph : \"\"\" Create a graph with self as node, cache it, return it. Args: depth: Depth of the graph. Returns: An instance of Graph. \"\"\" if depth not in self . _graph_cache : self . _graph_cache [ depth ] = Graph ( self , depth = depth ) return self . _graph_cache [ depth ] def as_matrix ( self , depth : int = 0 ) -> Matrix : \"\"\" Create a matrix with self as node, cache it, return it. Args: depth: Depth of the matrix. Returns: An instance of Matrix. \"\"\" if depth not in self . _matrix_cache : self . _matrix_cache [ depth ] = Matrix ( self , depth = depth ) # type: ignore[arg-type] return self . _matrix_cache [ depth ] def as_treemap ( self ) -> TreeMap : \"\"\" Return the dependencies as a TreeMap. Returns: An instance of TreeMap. \"\"\" if not self . _treemap_cache : self . _treemap_cache = TreeMap ( self ) return self . _treemap_cache __bool__ () \u00a4 Node as Boolean. Returns: Type Description bool Result of node.empty. Source code in dependenpy/node.py 113 114 115 116 117 118 119 120 121 def __bool__ ( self ) -> bool : \"\"\" Node as Boolean. Returns: Result of node.empty. \"\"\" return bool ( self . modules or self . packages ) __contains__ ( item ) \u00a4 Get result of _contains, cache it and return it. Parameters: Name Type Description Default item Package | Module A package or module. required Returns: Type Description bool True if self contains item, False otherwise. Source code in dependenpy/node.py 71 72 73 74 75 76 77 78 79 80 81 82 83 def __contains__ ( self , item : Package | Module ) -> bool : \"\"\" Get result of _contains, cache it and return it. Args: item: A package or module. Returns: True if self contains item, False otherwise. \"\"\" if item not in self . _contains_cache : self . _contains_cache [ item ] = self . _contains ( item ) return self . _contains_cache [ item ] __getitem__ ( item ) \u00a4 Return the corresponding Package or Module object. Parameters: Name Type Description Default item str Name of the package/module, dot-separated. required Raises: Type Description KeyError When the package or module cannot be found. Returns: Type Description Package | Module The corresponding object. Source code in dependenpy/node.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def __getitem__ ( self , item : str ) -> Package | Module : # noqa: WPS231 \"\"\" Return the corresponding Package or Module object. Args: item: Name of the package/module, dot-separated. Raises: KeyError: When the package or module cannot be found. Returns: The corresponding object. \"\"\" depth = item . count ( \".\" ) + 1 parts = item . split ( \".\" , 1 ) for module in self . modules : if parts [ 0 ] == module . name : if depth == 1 : return module for package in self . packages : if parts [ 0 ] == package . name : if depth == 1 : return package obj = package . get ( parts [ 1 ]) if obj : return obj raise KeyError ( item ) __init__ ( build_tree = True ) \u00a4 Initialization method. Parameters: Name Type Description Default build_tree bool whether to immediately build the tree or not. True Source code in dependenpy/node.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 def __init__ ( self , build_tree = True ): \"\"\" Initialization method. Args: build_tree (bool): whether to immediately build the tree or not. \"\"\" self . _target_cache = {} self . _item_cache = {} self . _contains_cache = {} self . _matrix_cache = {} self . _graph_cache = {} self . _treemap_cache = None self . modules = [] self . packages = [] if build_tree : self . build_tree () as_dict () \u00a4 Return the dependencies as a dictionary. Returns: Type Description dict Dictionary of dependencies. Source code in dependenpy/node.py 315 316 317 318 319 320 321 322 323 324 325 326 def as_dict ( self ) -> dict : \"\"\" Return the dependencies as a dictionary. Returns: Dictionary of dependencies. \"\"\" return { \"name\" : str ( self ), \"modules\" : [ module . as_dict () for module in self . modules ], \"packages\" : [ package . as_dict () for package in self . packages ], } as_graph ( depth = 0 ) \u00a4 Create a graph with self as node, cache it, return it. Parameters: Name Type Description Default depth int Depth of the graph. 0 Returns: Type Description Graph An instance of Graph. Source code in dependenpy/node.py 328 329 330 331 332 333 334 335 336 337 338 339 340 def as_graph ( self , depth : int = 0 ) -> Graph : \"\"\" Create a graph with self as node, cache it, return it. Args: depth: Depth of the graph. Returns: An instance of Graph. \"\"\" if depth not in self . _graph_cache : self . _graph_cache [ depth ] = Graph ( self , depth = depth ) return self . _graph_cache [ depth ] as_matrix ( depth = 0 ) \u00a4 Create a matrix with self as node, cache it, return it. Parameters: Name Type Description Default depth int Depth of the matrix. 0 Returns: Type Description Matrix An instance of Matrix. Source code in dependenpy/node.py 342 343 344 345 346 347 348 349 350 351 352 353 354 def as_matrix ( self , depth : int = 0 ) -> Matrix : \"\"\" Create a matrix with self as node, cache it, return it. Args: depth: Depth of the matrix. Returns: An instance of Matrix. \"\"\" if depth not in self . _matrix_cache : self . _matrix_cache [ depth ] = Matrix ( self , depth = depth ) # type: ignore[arg-type] return self . _matrix_cache [ depth ] as_treemap () \u00a4 Return the dependencies as a TreeMap. Returns: Type Description TreeMap An instance of TreeMap. Source code in dependenpy/node.py 356 357 358 359 360 361 362 363 364 365 def as_treemap ( self ) -> TreeMap : \"\"\" Return the dependencies as a TreeMap. Returns: An instance of TreeMap. \"\"\" if not self . _treemap_cache : self . _treemap_cache = TreeMap ( self ) return self . _treemap_cache build_dependencies () \u00a4 Recursively build the dependencies for sub-modules and sub-packages. Iterate on node's modules then packages and call their build_dependencies methods. Source code in dependenpy/node.py 236 237 238 239 240 241 242 243 244 245 246 def build_dependencies ( self ): \"\"\" Recursively build the dependencies for sub-modules and sub-packages. Iterate on node's modules then packages and call their build_dependencies methods. \"\"\" for module in self . modules : module . build_dependencies () for package in self . packages : package . build_dependencies () build_tree () \u00a4 To be overridden. Source code in dependenpy/node.py 147 148 149 def build_tree ( self ): \"\"\"To be overridden.\"\"\" # noqa: DAR401 raise NotImplementedError empty () property \u00a4 Whether the node has neither modules nor packages. Returns: Type Description bool True if empty, False otherwise. Source code in dependenpy/node.py 123 124 125 126 127 128 129 130 131 @property def empty ( self ) -> bool : \"\"\" Whether the node has neither modules nor packages. Returns: True if empty, False otherwise. \"\"\" return not bool ( self ) get ( item ) \u00a4 Get item through __getitem__ and cache the result. Parameters: Name Type Description Default item str Name of package or module. required Returns: Type Description Package | Module The corresponding object. Source code in dependenpy/node.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 def get ( self , item : str ) -> Package | Module : \"\"\" Get item through `__getitem__` and cache the result. Args: item: Name of package or module. Returns: The corresponding object. \"\"\" if item not in self . _item_cache : try : obj = self . __getitem__ ( item ) except KeyError : obj = None self . _item_cache [ item ] = obj return self . _item_cache [ item ] get_target ( target ) \u00a4 Get the result of _get_target, cache it and return it. Parameters: Name Type Description Default target str Target to find. required Returns: Type Description Package | Module Package containing target or corresponding module. Source code in dependenpy/node.py 189 190 191 192 193 194 195 196 197 198 199 200 201 def get_target ( self , target : str ) -> Package | Module : \"\"\" Get the result of _get_target, cache it and return it. Args: target: Target to find. Returns: Package containing target or corresponding module. \"\"\" if target not in self . _target_cache : self . _target_cache [ target ] = self . _get_target ( target ) return self . _target_cache [ target ] print_graph ( format = None , output = sys . stdout , depth = 0 , ** kwargs ) \u00a4 Print the graph for self's nodes. Parameters: Name Type Description Default format str | None Output format (csv, json or text). None output IO File descriptor on which to write. sys.stdout depth int Depth of the graph. 0 **kwargs Any Additional keyword arguments passed to graph.print . {} Source code in dependenpy/node.py 248 249 250 251 252 253 254 255 256 257 258 259 260 261 def print_graph ( self , format : str | None = None , output : IO = sys . stdout , depth : int = 0 , ** kwargs : Any # noqa: A002 ): \"\"\" Print the graph for self's nodes. Args: format: Output format (csv, json or text). output: File descriptor on which to write. depth: Depth of the graph. **kwargs: Additional keyword arguments passed to `graph.print`. \"\"\" graph = self . as_graph ( depth = depth ) graph . print ( format = format , output = output , ** kwargs ) print_matrix ( format = None , output = sys . stdout , depth = 0 , ** kwargs ) \u00a4 Print the matrix for self's nodes. Parameters: Name Type Description Default format str | None Output format (csv, json or text). None output IO File descriptor on which to write. sys.stdout depth int Depth of the matrix. 0 **kwargs Any Additional keyword arguments passed to matrix.print . {} Source code in dependenpy/node.py 263 264 265 266 267 268 269 270 271 272 273 274 275 276 def print_matrix ( self , format : str | None = None , output : IO = sys . stdout , depth : int = 0 , ** kwargs : Any # noqa: A002 ): \"\"\" Print the matrix for self's nodes. Args: format: Output format (csv, json or text). output: File descriptor on which to write. depth: Depth of the matrix. **kwargs: Additional keyword arguments passed to `matrix.print`. \"\"\" matrix = self . as_matrix ( depth = depth ) matrix . print ( format = format , output = output , ** kwargs ) print_treemap ( format = None , output = sys . stdout , ** kwargs ) \u00a4 Print the matrix for self's nodes. Parameters: Name Type Description Default format str | None Output format (csv, json or text). None output IO File descriptor on which to write. sys.stdout **kwargs Any Additional keyword arguments passed to treemap.print . {} Source code in dependenpy/node.py 278 279 280 281 282 283 284 285 286 287 288 def print_treemap ( self , format : str | None = None , output : IO = sys . stdout , ** kwargs : Any ): # noqa: A002 \"\"\" Print the matrix for self's nodes. Args: format: Output format (csv, json or text). output: File descriptor on which to write. **kwargs: Additional keyword arguments passed to `treemap.print`. \"\"\" treemap = self . as_treemap () treemap . print ( format = format , output = output , ** kwargs ) submodules () property \u00a4 Property to return all sub-modules of the node, recursively. Returns: Type Description list [ Module ] The sub-modules. Source code in dependenpy/node.py 133 134 135 136 137 138 139 140 141 142 143 144 145 @property def submodules ( self ) -> list [ Module ]: \"\"\" Property to return all sub-modules of the node, recursively. Returns: The sub-modules. \"\"\" submodules = [] submodules . extend ( self . modules ) for package in self . packages : submodules . extend ( package . submodules ) return submodules","title":"node"},{"location":"reference/dependenpy/node/#dependenpy.node.LeafNode","text":"Bases: object Shared code between Package and Module. Source code in dependenpy/node.py 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 class LeafNode ( object ): \"\"\"Shared code between Package and Module.\"\"\" def __init__ ( self ): \"\"\"Initialization method.\"\"\" self . _depth_cache = None def __str__ ( self ): return self . absolute_name () @property def root ( self ) -> Package : \"\"\" Property to return the root of this node. Returns: Package: this node's root package. \"\"\" node : Package = self # type: ignore[assignment] while node . package is not None : node = node . package return node @property def depth ( self ) -> int : \"\"\" Property to tell the depth of the node in the tree. Returns: The node's depth in the tree. \"\"\" if self . _depth_cache is not None : return self . _depth_cache node : Package depth , node = 1 , self # type: ignore[assignment] while node . package is not None : depth += 1 node = node . package self . _depth_cache = depth return depth def absolute_name ( self , depth : int = 0 ) -> str : \"\"\" Return the absolute name of the node. Concatenate names from root to self within depth. Args: depth: Maximum depth to go to. Returns: Absolute name of the node (until given depth is reached). \"\"\" node : Package node , node_depth = self , self . depth # type: ignore[assignment] if depth < 1 : depth = node_depth while node_depth > depth and node . package is not None : node = node . package node_depth -= 1 names = [] while node is not None : names . append ( node . name ) node = node . package # type: ignore[assignment] return \".\" . join ( reversed ( names ))","title":"LeafNode"},{"location":"reference/dependenpy/node/#dependenpy.node.LeafNode.__init__","text":"Initialization method. Source code in dependenpy/node.py 371 372 373 def __init__ ( self ): \"\"\"Initialization method.\"\"\" self . _depth_cache = None","title":"__init__()"},{"location":"reference/dependenpy/node/#dependenpy.node.LeafNode.absolute_name","text":"Return the absolute name of the node. Concatenate names from root to self within depth. Parameters: Name Type Description Default depth int Maximum depth to go to. 0 Returns: Type Description str Absolute name of the node (until given depth is reached). Source code in dependenpy/node.py 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 def absolute_name ( self , depth : int = 0 ) -> str : \"\"\" Return the absolute name of the node. Concatenate names from root to self within depth. Args: depth: Maximum depth to go to. Returns: Absolute name of the node (until given depth is reached). \"\"\" node : Package node , node_depth = self , self . depth # type: ignore[assignment] if depth < 1 : depth = node_depth while node_depth > depth and node . package is not None : node = node . package node_depth -= 1 names = [] while node is not None : names . append ( node . name ) node = node . package # type: ignore[assignment] return \".\" . join ( reversed ( names ))","title":"absolute_name()"},{"location":"reference/dependenpy/node/#dependenpy.node.LeafNode.depth","text":"Property to tell the depth of the node in the tree. Returns: Type Description int The node's depth in the tree. Source code in dependenpy/node.py 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 @property def depth ( self ) -> int : \"\"\" Property to tell the depth of the node in the tree. Returns: The node's depth in the tree. \"\"\" if self . _depth_cache is not None : return self . _depth_cache node : Package depth , node = 1 , self # type: ignore[assignment] while node . package is not None : depth += 1 node = node . package self . _depth_cache = depth return depth","title":"depth()"},{"location":"reference/dependenpy/node/#dependenpy.node.LeafNode.root","text":"Property to return the root of this node. Returns: Name Type Description Package Package this node's root package. Source code in dependenpy/node.py 378 379 380 381 382 383 384 385 386 387 388 389 @property def root ( self ) -> Package : \"\"\" Property to return the root of this node. Returns: Package: this node's root package. \"\"\" node : Package = self # type: ignore[assignment] while node . package is not None : node = node . package return node","title":"root()"},{"location":"reference/dependenpy/node/#dependenpy.node.NodeMixin","text":"Bases: object Shared code between DSM, Package and Module. Source code in dependenpy/node.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 class NodeMixin ( object ): \"\"\"Shared code between DSM, Package and Module.\"\"\" @property def ismodule ( self ) -> bool : \"\"\" Property to check if object is instance of Module. Returns: Whether this object is a module. \"\"\" return False @property def ispackage ( self ) -> bool : \"\"\" Property to check if object is instance of Package. Returns: Whether this object is a package. \"\"\" return False @property def isdsm ( self ) -> bool : \"\"\" Property to check if object is instance of DSM. Returns: Whether this object is a DSM. \"\"\" return False","title":"NodeMixin"},{"location":"reference/dependenpy/node/#dependenpy.node.NodeMixin.isdsm","text":"Property to check if object is instance of DSM. Returns: Type Description bool Whether this object is a DSM. Source code in dependenpy/node.py 38 39 40 41 42 43 44 45 46 @property def isdsm ( self ) -> bool : \"\"\" Property to check if object is instance of DSM. Returns: Whether this object is a DSM. \"\"\" return False","title":"isdsm()"},{"location":"reference/dependenpy/node/#dependenpy.node.NodeMixin.ismodule","text":"Property to check if object is instance of Module. Returns: Type Description bool Whether this object is a module. Source code in dependenpy/node.py 18 19 20 21 22 23 24 25 26 @property def ismodule ( self ) -> bool : \"\"\" Property to check if object is instance of Module. Returns: Whether this object is a module. \"\"\" return False","title":"ismodule()"},{"location":"reference/dependenpy/node/#dependenpy.node.NodeMixin.ispackage","text":"Property to check if object is instance of Package. Returns: Type Description bool Whether this object is a package. Source code in dependenpy/node.py 28 29 30 31 32 33 34 35 36 @property def ispackage ( self ) -> bool : \"\"\" Property to check if object is instance of Package. Returns: Whether this object is a package. \"\"\" return False","title":"ispackage()"},{"location":"reference/dependenpy/node/#dependenpy.node.RootNode","text":"Bases: object Shared code between DSM and Package. Source code in dependenpy/node.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 class RootNode ( object ): \"\"\"Shared code between DSM and Package.\"\"\" def __init__ ( self , build_tree = True ): \"\"\" Initialization method. Args: build_tree (bool): whether to immediately build the tree or not. \"\"\" self . _target_cache = {} self . _item_cache = {} self . _contains_cache = {} self . _matrix_cache = {} self . _graph_cache = {} self . _treemap_cache = None self . modules = [] self . packages = [] if build_tree : self . build_tree () def __contains__ ( self , item : Package | Module ) -> bool : \"\"\" Get result of _contains, cache it and return it. Args: item: A package or module. Returns: True if self contains item, False otherwise. \"\"\" if item not in self . _contains_cache : self . _contains_cache [ item ] = self . _contains ( item ) return self . _contains_cache [ item ] def __getitem__ ( self , item : str ) -> Package | Module : # noqa: WPS231 \"\"\" Return the corresponding Package or Module object. Args: item: Name of the package/module, dot-separated. Raises: KeyError: When the package or module cannot be found. Returns: The corresponding object. \"\"\" depth = item . count ( \".\" ) + 1 parts = item . split ( \".\" , 1 ) for module in self . modules : if parts [ 0 ] == module . name : if depth == 1 : return module for package in self . packages : if parts [ 0 ] == package . name : if depth == 1 : return package obj = package . get ( parts [ 1 ]) if obj : return obj raise KeyError ( item ) def __bool__ ( self ) -> bool : \"\"\" Node as Boolean. Returns: Result of node.empty. \"\"\" return bool ( self . modules or self . packages ) @property def empty ( self ) -> bool : \"\"\" Whether the node has neither modules nor packages. Returns: True if empty, False otherwise. \"\"\" return not bool ( self ) @property def submodules ( self ) -> list [ Module ]: \"\"\" Property to return all sub-modules of the node, recursively. Returns: The sub-modules. \"\"\" submodules = [] submodules . extend ( self . modules ) for package in self . packages : submodules . extend ( package . submodules ) return submodules def build_tree ( self ): \"\"\"To be overridden.\"\"\" # noqa: DAR401 raise NotImplementedError def _contains ( self , item ): \"\"\" Whether given item is contained inside the node modules/packages. Args: item (Package/Module): a package or module. Returns: bool: True if self is item or item in self's packages/modules. \"\"\" if self is item : return True for module in self . modules : if item in module : return True for package in self . packages : if item in package : return True return False def get ( self , item : str ) -> Package | Module : \"\"\" Get item through `__getitem__` and cache the result. Args: item: Name of package or module. Returns: The corresponding object. \"\"\" if item not in self . _item_cache : try : obj = self . __getitem__ ( item ) except KeyError : obj = None self . _item_cache [ item ] = obj return self . _item_cache [ item ] def get_target ( self , target : str ) -> Package | Module : \"\"\" Get the result of _get_target, cache it and return it. Args: target: Target to find. Returns: Package containing target or corresponding module. \"\"\" if target not in self . _target_cache : self . _target_cache [ target ] = self . _get_target ( target ) return self . _target_cache [ target ] def _get_target ( self , target ): # noqa: WPS231 \"\"\" Get the Package or Module related to given target. Args: target (str): target to find. Returns: Package/Module: package containing target or corresponding module. \"\"\" depth = target . count ( \".\" ) + 1 parts = target . split ( \".\" , 1 ) for module in self . modules : if parts [ 0 ] == module . name : if depth < 3 : return module for package in self . packages : if parts [ 0 ] == package . name : if depth == 1 : return package target = package . _get_target ( parts [ 1 ]) # noqa: WPS437 if target : return target # FIXME: can lead to internal dep instead of external # see example with django.contrib.auth.forms # importing forms from django # Idea: when parsing files with ast, record what objects # are defined in the module. Then check here if the given # part is one of these objects. if depth < 3 : return package return None def build_dependencies ( self ): \"\"\" Recursively build the dependencies for sub-modules and sub-packages. Iterate on node's modules then packages and call their build_dependencies methods. \"\"\" for module in self . modules : module . build_dependencies () for package in self . packages : package . build_dependencies () def print_graph ( self , format : str | None = None , output : IO = sys . stdout , depth : int = 0 , ** kwargs : Any # noqa: A002 ): \"\"\" Print the graph for self's nodes. Args: format: Output format (csv, json or text). output: File descriptor on which to write. depth: Depth of the graph. **kwargs: Additional keyword arguments passed to `graph.print`. \"\"\" graph = self . as_graph ( depth = depth ) graph . print ( format = format , output = output , ** kwargs ) def print_matrix ( self , format : str | None = None , output : IO = sys . stdout , depth : int = 0 , ** kwargs : Any # noqa: A002 ): \"\"\" Print the matrix for self's nodes. Args: format: Output format (csv, json or text). output: File descriptor on which to write. depth: Depth of the matrix. **kwargs: Additional keyword arguments passed to `matrix.print`. \"\"\" matrix = self . as_matrix ( depth = depth ) matrix . print ( format = format , output = output , ** kwargs ) def print_treemap ( self , format : str | None = None , output : IO = sys . stdout , ** kwargs : Any ): # noqa: A002 \"\"\" Print the matrix for self's nodes. Args: format: Output format (csv, json or text). output: File descriptor on which to write. **kwargs: Additional keyword arguments passed to `treemap.print`. \"\"\" treemap = self . as_treemap () treemap . print ( format = format , output = output , ** kwargs ) def _to_text ( self , ** kwargs ): indent = kwargs . pop ( \"indent\" , 2 ) base_indent = kwargs . pop ( \"base_indent\" , None ) if base_indent is None : base_indent = indent indent = 0 text = [ \" \" * indent + str ( self ) + \" \\n \" ] new_indent = indent + base_indent for module in self . modules : text . append ( module . _to_text ( indent = new_indent , base_indent = base_indent )) # noqa: WPS437 for package in self . packages : text . append ( package . _to_text ( indent = new_indent , base_indent = base_indent )) # noqa: WPS437 return \"\" . join ( text ) def _to_csv ( self , ** kwargs ): header = kwargs . pop ( \"header\" , True ) modules = sorted ( self . submodules , key = lambda mod : mod . absolute_name ()) text = [ \"module,path,target,lineno,what,external \\n \" if header else \"\" ] for module in modules : text . append ( module . _to_csv ( header = False )) # noqa: WPS437 return \"\" . join ( text ) def _to_json ( self , ** kwargs ): return json . dumps ( self . as_dict (), ** kwargs ) def as_dict ( self ) -> dict : \"\"\" Return the dependencies as a dictionary. Returns: Dictionary of dependencies. \"\"\" return { \"name\" : str ( self ), \"modules\" : [ module . as_dict () for module in self . modules ], \"packages\" : [ package . as_dict () for package in self . packages ], } def as_graph ( self , depth : int = 0 ) -> Graph : \"\"\" Create a graph with self as node, cache it, return it. Args: depth: Depth of the graph. Returns: An instance of Graph. \"\"\" if depth not in self . _graph_cache : self . _graph_cache [ depth ] = Graph ( self , depth = depth ) return self . _graph_cache [ depth ] def as_matrix ( self , depth : int = 0 ) -> Matrix : \"\"\" Create a matrix with self as node, cache it, return it. Args: depth: Depth of the matrix. Returns: An instance of Matrix. \"\"\" if depth not in self . _matrix_cache : self . _matrix_cache [ depth ] = Matrix ( self , depth = depth ) # type: ignore[arg-type] return self . _matrix_cache [ depth ] def as_treemap ( self ) -> TreeMap : \"\"\" Return the dependencies as a TreeMap. Returns: An instance of TreeMap. \"\"\" if not self . _treemap_cache : self . _treemap_cache = TreeMap ( self ) return self . _treemap_cache","title":"RootNode"},{"location":"reference/dependenpy/node/#dependenpy.node.RootNode.__bool__","text":"Node as Boolean. Returns: Type Description bool Result of node.empty. Source code in dependenpy/node.py 113 114 115 116 117 118 119 120 121 def __bool__ ( self ) -> bool : \"\"\" Node as Boolean. Returns: Result of node.empty. \"\"\" return bool ( self . modules or self . packages )","title":"__bool__()"},{"location":"reference/dependenpy/node/#dependenpy.node.RootNode.__contains__","text":"Get result of _contains, cache it and return it. Parameters: Name Type Description Default item Package | Module A package or module. required Returns: Type Description bool True if self contains item, False otherwise. Source code in dependenpy/node.py 71 72 73 74 75 76 77 78 79 80 81 82 83 def __contains__ ( self , item : Package | Module ) -> bool : \"\"\" Get result of _contains, cache it and return it. Args: item: A package or module. Returns: True if self contains item, False otherwise. \"\"\" if item not in self . _contains_cache : self . _contains_cache [ item ] = self . _contains ( item ) return self . _contains_cache [ item ]","title":"__contains__()"},{"location":"reference/dependenpy/node/#dependenpy.node.RootNode.__getitem__","text":"Return the corresponding Package or Module object. Parameters: Name Type Description Default item str Name of the package/module, dot-separated. required Raises: Type Description KeyError When the package or module cannot be found. Returns: Type Description Package | Module The corresponding object. Source code in dependenpy/node.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def __getitem__ ( self , item : str ) -> Package | Module : # noqa: WPS231 \"\"\" Return the corresponding Package or Module object. Args: item: Name of the package/module, dot-separated. Raises: KeyError: When the package or module cannot be found. Returns: The corresponding object. \"\"\" depth = item . count ( \".\" ) + 1 parts = item . split ( \".\" , 1 ) for module in self . modules : if parts [ 0 ] == module . name : if depth == 1 : return module for package in self . packages : if parts [ 0 ] == package . name : if depth == 1 : return package obj = package . get ( parts [ 1 ]) if obj : return obj raise KeyError ( item )","title":"__getitem__()"},{"location":"reference/dependenpy/node/#dependenpy.node.RootNode.__init__","text":"Initialization method. Parameters: Name Type Description Default build_tree bool whether to immediately build the tree or not. True Source code in dependenpy/node.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 def __init__ ( self , build_tree = True ): \"\"\" Initialization method. Args: build_tree (bool): whether to immediately build the tree or not. \"\"\" self . _target_cache = {} self . _item_cache = {} self . _contains_cache = {} self . _matrix_cache = {} self . _graph_cache = {} self . _treemap_cache = None self . modules = [] self . packages = [] if build_tree : self . build_tree ()","title":"__init__()"},{"location":"reference/dependenpy/node/#dependenpy.node.RootNode.as_dict","text":"Return the dependencies as a dictionary. Returns: Type Description dict Dictionary of dependencies. Source code in dependenpy/node.py 315 316 317 318 319 320 321 322 323 324 325 326 def as_dict ( self ) -> dict : \"\"\" Return the dependencies as a dictionary. Returns: Dictionary of dependencies. \"\"\" return { \"name\" : str ( self ), \"modules\" : [ module . as_dict () for module in self . modules ], \"packages\" : [ package . as_dict () for package in self . packages ], }","title":"as_dict()"},{"location":"reference/dependenpy/node/#dependenpy.node.RootNode.as_graph","text":"Create a graph with self as node, cache it, return it. Parameters: Name Type Description Default depth int Depth of the graph. 0 Returns: Type Description Graph An instance of Graph. Source code in dependenpy/node.py 328 329 330 331 332 333 334 335 336 337 338 339 340 def as_graph ( self , depth : int = 0 ) -> Graph : \"\"\" Create a graph with self as node, cache it, return it. Args: depth: Depth of the graph. Returns: An instance of Graph. \"\"\" if depth not in self . _graph_cache : self . _graph_cache [ depth ] = Graph ( self , depth = depth ) return self . _graph_cache [ depth ]","title":"as_graph()"},{"location":"reference/dependenpy/node/#dependenpy.node.RootNode.as_matrix","text":"Create a matrix with self as node, cache it, return it. Parameters: Name Type Description Default depth int Depth of the matrix. 0 Returns: Type Description Matrix An instance of Matrix. Source code in dependenpy/node.py 342 343 344 345 346 347 348 349 350 351 352 353 354 def as_matrix ( self , depth : int = 0 ) -> Matrix : \"\"\" Create a matrix with self as node, cache it, return it. Args: depth: Depth of the matrix. Returns: An instance of Matrix. \"\"\" if depth not in self . _matrix_cache : self . _matrix_cache [ depth ] = Matrix ( self , depth = depth ) # type: ignore[arg-type] return self . _matrix_cache [ depth ]","title":"as_matrix()"},{"location":"reference/dependenpy/node/#dependenpy.node.RootNode.as_treemap","text":"Return the dependencies as a TreeMap. Returns: Type Description TreeMap An instance of TreeMap. Source code in dependenpy/node.py 356 357 358 359 360 361 362 363 364 365 def as_treemap ( self ) -> TreeMap : \"\"\" Return the dependencies as a TreeMap. Returns: An instance of TreeMap. \"\"\" if not self . _treemap_cache : self . _treemap_cache = TreeMap ( self ) return self . _treemap_cache","title":"as_treemap()"},{"location":"reference/dependenpy/node/#dependenpy.node.RootNode.build_dependencies","text":"Recursively build the dependencies for sub-modules and sub-packages. Iterate on node's modules then packages and call their build_dependencies methods. Source code in dependenpy/node.py 236 237 238 239 240 241 242 243 244 245 246 def build_dependencies ( self ): \"\"\" Recursively build the dependencies for sub-modules and sub-packages. Iterate on node's modules then packages and call their build_dependencies methods. \"\"\" for module in self . modules : module . build_dependencies () for package in self . packages : package . build_dependencies ()","title":"build_dependencies()"},{"location":"reference/dependenpy/node/#dependenpy.node.RootNode.build_tree","text":"To be overridden. Source code in dependenpy/node.py 147 148 149 def build_tree ( self ): \"\"\"To be overridden.\"\"\" # noqa: DAR401 raise NotImplementedError","title":"build_tree()"},{"location":"reference/dependenpy/node/#dependenpy.node.RootNode.empty","text":"Whether the node has neither modules nor packages. Returns: Type Description bool True if empty, False otherwise. Source code in dependenpy/node.py 123 124 125 126 127 128 129 130 131 @property def empty ( self ) -> bool : \"\"\" Whether the node has neither modules nor packages. Returns: True if empty, False otherwise. \"\"\" return not bool ( self )","title":"empty()"},{"location":"reference/dependenpy/node/#dependenpy.node.RootNode.get","text":"Get item through __getitem__ and cache the result. Parameters: Name Type Description Default item str Name of package or module. required Returns: Type Description Package | Module The corresponding object. Source code in dependenpy/node.py 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 def get ( self , item : str ) -> Package | Module : \"\"\" Get item through `__getitem__` and cache the result. Args: item: Name of package or module. Returns: The corresponding object. \"\"\" if item not in self . _item_cache : try : obj = self . __getitem__ ( item ) except KeyError : obj = None self . _item_cache [ item ] = obj return self . _item_cache [ item ]","title":"get()"},{"location":"reference/dependenpy/node/#dependenpy.node.RootNode.get_target","text":"Get the result of _get_target, cache it and return it. Parameters: Name Type Description Default target str Target to find. required Returns: Type Description Package | Module Package containing target or corresponding module. Source code in dependenpy/node.py 189 190 191 192 193 194 195 196 197 198 199 200 201 def get_target ( self , target : str ) -> Package | Module : \"\"\" Get the result of _get_target, cache it and return it. Args: target: Target to find. Returns: Package containing target or corresponding module. \"\"\" if target not in self . _target_cache : self . _target_cache [ target ] = self . _get_target ( target ) return self . _target_cache [ target ]","title":"get_target()"},{"location":"reference/dependenpy/node/#dependenpy.node.RootNode.print_graph","text":"Print the graph for self's nodes. Parameters: Name Type Description Default format str | None Output format (csv, json or text). None output IO File descriptor on which to write. sys.stdout depth int Depth of the graph. 0 **kwargs Any Additional keyword arguments passed to graph.print . {} Source code in dependenpy/node.py 248 249 250 251 252 253 254 255 256 257 258 259 260 261 def print_graph ( self , format : str | None = None , output : IO = sys . stdout , depth : int = 0 , ** kwargs : Any # noqa: A002 ): \"\"\" Print the graph for self's nodes. Args: format: Output format (csv, json or text). output: File descriptor on which to write. depth: Depth of the graph. **kwargs: Additional keyword arguments passed to `graph.print`. \"\"\" graph = self . as_graph ( depth = depth ) graph . print ( format = format , output = output , ** kwargs )","title":"print_graph()"},{"location":"reference/dependenpy/node/#dependenpy.node.RootNode.print_matrix","text":"Print the matrix for self's nodes. Parameters: Name Type Description Default format str | None Output format (csv, json or text). None output IO File descriptor on which to write. sys.stdout depth int Depth of the matrix. 0 **kwargs Any Additional keyword arguments passed to matrix.print . {} Source code in dependenpy/node.py 263 264 265 266 267 268 269 270 271 272 273 274 275 276 def print_matrix ( self , format : str | None = None , output : IO = sys . stdout , depth : int = 0 , ** kwargs : Any # noqa: A002 ): \"\"\" Print the matrix for self's nodes. Args: format: Output format (csv, json or text). output: File descriptor on which to write. depth: Depth of the matrix. **kwargs: Additional keyword arguments passed to `matrix.print`. \"\"\" matrix = self . as_matrix ( depth = depth ) matrix . print ( format = format , output = output , ** kwargs )","title":"print_matrix()"},{"location":"reference/dependenpy/node/#dependenpy.node.RootNode.print_treemap","text":"Print the matrix for self's nodes. Parameters: Name Type Description Default format str | None Output format (csv, json or text). None output IO File descriptor on which to write. sys.stdout **kwargs Any Additional keyword arguments passed to treemap.print . {} Source code in dependenpy/node.py 278 279 280 281 282 283 284 285 286 287 288 def print_treemap ( self , format : str | None = None , output : IO = sys . stdout , ** kwargs : Any ): # noqa: A002 \"\"\" Print the matrix for self's nodes. Args: format: Output format (csv, json or text). output: File descriptor on which to write. **kwargs: Additional keyword arguments passed to `treemap.print`. \"\"\" treemap = self . as_treemap () treemap . print ( format = format , output = output , ** kwargs )","title":"print_treemap()"},{"location":"reference/dependenpy/node/#dependenpy.node.RootNode.submodules","text":"Property to return all sub-modules of the node, recursively. Returns: Type Description list [ Module ] The sub-modules. Source code in dependenpy/node.py 133 134 135 136 137 138 139 140 141 142 143 144 145 @property def submodules ( self ) -> list [ Module ]: \"\"\" Property to return all sub-modules of the node, recursively. Returns: The sub-modules. \"\"\" submodules = [] submodules . extend ( self . modules ) for package in self . packages : submodules . extend ( package . submodules ) return submodules","title":"submodules()"},{"location":"reference/dependenpy/plugins/","text":"dependenpy plugins module. InternalDependencies \u00a4 Bases: archan . Provider Dependenpy provider for Archan. Source code in dependenpy/plugins.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class InternalDependencies ( archan . Provider ): # type: ignore # noqa: WPS440 \"\"\"Dependenpy provider for Archan.\"\"\" identifier = \"dependenpy.InternalDependencies\" name = \"Internal Dependencies\" description = \"Provide matrix data about internal dependencies in a set of packages.\" argument_list = ( archan . Argument ( \"packages\" , list , \"The list of packages to check for.\" ), archan . Argument ( \"enforce_init\" , bool , default = True , description = \"Whether to assert presence of __init__.py files in directories.\" , ), archan . Argument ( \"depth\" , int , \"The depth of the matrix to generate.\" ), ) def get_data ( self , packages : list [ str ], enforce_init : bool = True , depth : int = None ) -> archan . DSM : \"\"\" Provide matrix data for internal dependencies in a set of packages. Args: packages: the list of packages to check for. enforce_init: whether to assert presence of __init__.py files in directories. depth: the depth of the matrix to generate. Returns: Instance of archan DSM. \"\"\" dsm = DependenpyDSM ( * packages , enforce_init = enforce_init ) if depth is None : depth = guess_depth ( packages ) matrix = dsm . as_matrix ( depth = depth ) return archan . DesignStructureMatrix ( data = matrix . data , entities = matrix . keys ) get_data ( packages , enforce_init = True , depth = None ) \u00a4 Provide matrix data for internal dependencies in a set of packages. Parameters: Name Type Description Default packages list [ str ] the list of packages to check for. required enforce_init bool whether to assert presence of init .py files in directories. True depth int the depth of the matrix to generate. None Returns: Type Description archan . DSM Instance of archan DSM. Source code in dependenpy/plugins.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def get_data ( self , packages : list [ str ], enforce_init : bool = True , depth : int = None ) -> archan . DSM : \"\"\" Provide matrix data for internal dependencies in a set of packages. Args: packages: the list of packages to check for. enforce_init: whether to assert presence of __init__.py files in directories. depth: the depth of the matrix to generate. Returns: Instance of archan DSM. \"\"\" dsm = DependenpyDSM ( * packages , enforce_init = enforce_init ) if depth is None : depth = guess_depth ( packages ) matrix = dsm . as_matrix ( depth = depth ) return archan . DesignStructureMatrix ( data = matrix . data , entities = matrix . keys )","title":"plugins"},{"location":"reference/dependenpy/plugins/#dependenpy.plugins.InternalDependencies","text":"Bases: archan . Provider Dependenpy provider for Archan. Source code in dependenpy/plugins.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class InternalDependencies ( archan . Provider ): # type: ignore # noqa: WPS440 \"\"\"Dependenpy provider for Archan.\"\"\" identifier = \"dependenpy.InternalDependencies\" name = \"Internal Dependencies\" description = \"Provide matrix data about internal dependencies in a set of packages.\" argument_list = ( archan . Argument ( \"packages\" , list , \"The list of packages to check for.\" ), archan . Argument ( \"enforce_init\" , bool , default = True , description = \"Whether to assert presence of __init__.py files in directories.\" , ), archan . Argument ( \"depth\" , int , \"The depth of the matrix to generate.\" ), ) def get_data ( self , packages : list [ str ], enforce_init : bool = True , depth : int = None ) -> archan . DSM : \"\"\" Provide matrix data for internal dependencies in a set of packages. Args: packages: the list of packages to check for. enforce_init: whether to assert presence of __init__.py files in directories. depth: the depth of the matrix to generate. Returns: Instance of archan DSM. \"\"\" dsm = DependenpyDSM ( * packages , enforce_init = enforce_init ) if depth is None : depth = guess_depth ( packages ) matrix = dsm . as_matrix ( depth = depth ) return archan . DesignStructureMatrix ( data = matrix . data , entities = matrix . keys )","title":"InternalDependencies"},{"location":"reference/dependenpy/plugins/#dependenpy.plugins.InternalDependencies.get_data","text":"Provide matrix data for internal dependencies in a set of packages. Parameters: Name Type Description Default packages list [ str ] the list of packages to check for. required enforce_init bool whether to assert presence of init .py files in directories. True depth int the depth of the matrix to generate. None Returns: Type Description archan . DSM Instance of archan DSM. Source code in dependenpy/plugins.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def get_data ( self , packages : list [ str ], enforce_init : bool = True , depth : int = None ) -> archan . DSM : \"\"\" Provide matrix data for internal dependencies in a set of packages. Args: packages: the list of packages to check for. enforce_init: whether to assert presence of __init__.py files in directories. depth: the depth of the matrix to generate. Returns: Instance of archan DSM. \"\"\" dsm = DependenpyDSM ( * packages , enforce_init = enforce_init ) if depth is None : depth = guess_depth ( packages ) matrix = dsm . as_matrix ( depth = depth ) return archan . DesignStructureMatrix ( data = matrix . data , entities = matrix . keys )","title":"get_data()"},{"location":"reference/dependenpy/structures/","text":"dependenpy structures module. Edge \u00a4 Bases: object Edge class. Used in Graph class. Source code in dependenpy/structures.py 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 class Edge ( object ): \"\"\"Edge class. Used in Graph class.\"\"\" def __init__ ( self , vertex_out , vertex_in , weight = 1 ): \"\"\" Initialization method. Args: vertex_out (Vertex): source vertex (edge going out). vertex_in (Vertex): target vertex (edge going in). weight (int): weight of the edge. \"\"\" self . vertex_out = None self . vertex_in = None self . weight = weight self . go_from ( vertex_out ) self . go_in ( vertex_in ) def __str__ ( self ): return f \" { self . vertex_out . name } -- { self . weight } --> { self . vertex_in . name } \" def go_from ( self , vertex ): \"\"\" Tell the edge to go out from this vertex. Args: vertex (Vertex): vertex to go from. \"\"\" if self . vertex_out : self . vertex_out . edges_out . remove ( self ) self . vertex_out = vertex vertex . edges_out . add ( self ) def go_in ( self , vertex ): \"\"\" Tell the edge to go into this vertex. Args: vertex (Vertex): vertex to go into. \"\"\" if self . vertex_in : self . vertex_in . edges_in . remove ( self ) self . vertex_in = vertex vertex . edges_in . add ( self ) __init__ ( vertex_out , vertex_in , weight = 1 ) \u00a4 Initialization method. Parameters: Name Type Description Default vertex_out Vertex source vertex (edge going out). required vertex_in Vertex target vertex (edge going in). required weight int weight of the edge. 1 Source code in dependenpy/structures.py 256 257 258 259 260 261 262 263 264 265 266 267 268 269 def __init__ ( self , vertex_out , vertex_in , weight = 1 ): \"\"\" Initialization method. Args: vertex_out (Vertex): source vertex (edge going out). vertex_in (Vertex): target vertex (edge going in). weight (int): weight of the edge. \"\"\" self . vertex_out = None self . vertex_in = None self . weight = weight self . go_from ( vertex_out ) self . go_in ( vertex_in ) go_from ( vertex ) \u00a4 Tell the edge to go out from this vertex. Parameters: Name Type Description Default vertex Vertex vertex to go from. required Source code in dependenpy/structures.py 274 275 276 277 278 279 280 281 282 283 284 def go_from ( self , vertex ): \"\"\" Tell the edge to go out from this vertex. Args: vertex (Vertex): vertex to go from. \"\"\" if self . vertex_out : self . vertex_out . edges_out . remove ( self ) self . vertex_out = vertex vertex . edges_out . add ( self ) go_in ( vertex ) \u00a4 Tell the edge to go into this vertex. Parameters: Name Type Description Default vertex Vertex vertex to go into. required Source code in dependenpy/structures.py 286 287 288 289 290 291 292 293 294 295 296 def go_in ( self , vertex ): \"\"\" Tell the edge to go into this vertex. Args: vertex (Vertex): vertex to go into. \"\"\" if self . vertex_in : self . vertex_in . edges_in . remove ( self ) self . vertex_in = vertex vertex . edges_in . add ( self ) Graph \u00a4 Bases: PrintMixin Graph class. A class to build a graph given a list of nodes. After instantiation, it has two attributes: vertices, the set of nodes, and edges, the set of edges. Source code in dependenpy/structures.py 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 class Graph ( PrintMixin ): \"\"\" Graph class. A class to build a graph given a list of nodes. After instantiation, it has two attributes: vertices, the set of nodes, and edges, the set of edges. \"\"\" def __init__ ( self , * nodes , depth = 0 ): \"\"\" Initialization method. An intermediary matrix is built to ease the creation of the graph. Args: *nodes (list of DSM/Package/Module): the nodes on which to build the graph. depth (int): the depth of the intermediary matrix. See the documentation for Matrix class. \"\"\" self . edges = set () vertices = [] matrix = Matrix ( * nodes , depth = depth ) for key in matrix . keys : vertices . append ( Vertex ( key )) for line_index , line in enumerate ( matrix . data ): for col_index , cell in enumerate ( line ): if cell > 0 : self . edges . add ( Edge ( vertices [ line_index ], vertices [ col_index ], weight = cell )) self . vertices = set ( vertices ) def _to_csv ( self , ** kwargs ): header = kwargs . pop ( \"header\" , True ) text = [ \"vertex_out,edge_weight,vertex_in \\n \" if header else \"\" ] for edge in self . edges : text . append ( f \" { edge . vertex_out . name } , { edge . weight } , { edge . vertex_in . name } \\n \" ) for vertex in self . vertices : if not ( vertex . edges_out or vertex . edges_in ): text . append ( \" {vertex.name} ,, \\n \" ) return \"\" . join ( text ) def _to_json ( self , ** kwargs ): return json . dumps ( { \"vertices\" : [ vertex . name for vertex in self . vertices ], \"edges\" : [ { \"out\" : edge . vertex_out . name , \"weight\" : edge . weight , \"in\" : edge . vertex_in . name } for edge in self . edges ], }, ** kwargs , ) def _to_text ( self , ** kwargs ): return \"\" __init__ ( * nodes , depth = 0 ) \u00a4 Initialization method. An intermediary matrix is built to ease the creation of the graph. Parameters: Name Type Description Default *nodes list of DSM/Package/Module the nodes on which to build the graph. () depth int the depth of the intermediary matrix. See the documentation for Matrix class. 0 Source code in dependenpy/structures.py 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 def __init__ ( self , * nodes , depth = 0 ): \"\"\" Initialization method. An intermediary matrix is built to ease the creation of the graph. Args: *nodes (list of DSM/Package/Module): the nodes on which to build the graph. depth (int): the depth of the intermediary matrix. See the documentation for Matrix class. \"\"\" self . edges = set () vertices = [] matrix = Matrix ( * nodes , depth = depth ) for key in matrix . keys : vertices . append ( Vertex ( key )) for line_index , line in enumerate ( matrix . data ): for col_index , cell in enumerate ( line ): if cell > 0 : self . edges . add ( Edge ( vertices [ line_index ], vertices [ col_index ], weight = cell )) self . vertices = set ( vertices ) Matrix \u00a4 Bases: PrintMixin Matrix class. A class to build a matrix given a list of nodes. After instantiation, it has two attributes: data, a 2-dimensions array, and keys, the names of the entities in the corresponding order. Source code in dependenpy/structures.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 class Matrix ( PrintMixin ): \"\"\" Matrix class. A class to build a matrix given a list of nodes. After instantiation, it has two attributes: data, a 2-dimensions array, and keys, the names of the entities in the corresponding order. \"\"\" def __init__ ( self , * nodes : DSM | Package | Module , depth : int = 0 ): # noqa: WPS231 \"\"\" Initialization method. Args: *nodes: The nodes on which to build the matrix. depth: The depth of the matrix. This depth is always absolute, meaning that building a matrix with a sub-package \"A.B.C\" and a depth of 1 will return a matrix of size 1, containing A only. To see the matrix for the sub-modules and sub-packages in C, you will have to give depth=4. \"\"\" modules : list [ Module ] = [] for node in nodes : if node . ismodule : modules . append ( node ) # type: ignore[arg-type] elif node . ispackage or node . isdsm : modules . extend ( node . submodules ) # type: ignore[union-attr] if depth < 1 : keys = modules else : keys = [] for module in modules : if module . depth <= depth : keys . append ( module ) continue package = module . package while package . depth > depth and package . package and package not in nodes : package = package . package if package not in keys : keys . append ( package ) size = len ( keys ) data = [[ 0 ] * size for _ in range ( size )] # noqa: WPS435 keys = sorted ( keys , key = lambda key : key . absolute_name ()) if depth < 1 : for index , key in enumerate ( keys ): # noqa: WPS440 key . index = index # type: ignore[attr-defined] for index , key in enumerate ( keys ): # noqa: WPS440 for dep in key . dependencies : if dep . external : continue if dep . target . ismodule and dep . target in keys : data [ index ][ dep . target . index ] += 1 elif dep . target . ispackage : init = dep . target . get ( \"__init__\" ) if init is not None and init in keys : data [ index ][ init . index ] += 1 else : for row , row_key in enumerate ( keys ): for col , col_key in enumerate ( keys ): data [ row ][ col ] = row_key . cardinal ( to = col_key ) self . size = size self . keys = [ key . absolute_name () for key in keys ] # noqa: WPS441 self . data = data @staticmethod # noqa: WPS602 def cast ( keys : list [ str ], data : list [ list [ int ]]) -> Matrix : # noqa: WPS602 \"\"\" Cast a set of keys and an array to a Matrix object. Arguments: keys: The matrix keys. data: The matrix data. Returns: A new matrix. \"\"\" matrix = Matrix () matrix . keys = copy . deepcopy ( keys ) matrix . data = copy . deepcopy ( data ) return matrix @property def total ( self ) -> int : \"\"\" Return the total number of dependencies within this matrix. Returns: The total number of dependencies. \"\"\" return sum ( cell for line in self . data for cell in line ) def _to_csv ( self , ** kwargs ): text = [ \"module,\" , \",\" . join ( self . keys )] for index , key in enumerate ( self . keys ): line = \",\" . join ( map ( str , self . data [ index ])) text . append ( f \" { key } , { line } \" ) return \" \\n \" . join ( text ) def _to_json ( self , ** kwargs ): return json . dumps ({ \"keys\" : self . keys , \"data\" : self . data }, ** kwargs ) def _to_text ( self , ** kwargs ): if not self . keys or not self . data : return \"\" zero = kwargs . pop ( \"zero\" , \"0\" ) max_key_length = max ( len ( key ) for key in self . keys + [ \"Module\" ]) max_dep_length = max ([ len ( str ( col )) for line in self . data for col in line ] + [ len ( zero )]) key_col_length = len ( str ( len ( self . keys ))) key_line_length = max ( key_col_length , 2 ) column_length = max ( key_col_length , max_dep_length ) bold = Style . BRIGHT reset = Style . RESET_ALL # first line left headers text = [ f \" \\n { bold }{ 'Module' : > { max_key_length }}{ reset } \u2502 { bold }{ 'Id' : > { key_line_length }}{ reset } \u2502\" ] # first line column headers for index , _ in enumerate ( self . keys ): text . append ( f \" { bold }{ index : ^ { column_length }}{ reset } \u2502\" ) text . append ( \" \\n \" ) # line of dashes text . append ( f \" { '\u2500' * max_key_length } \u2500\u253c\u2500 { '\u2500' * key_line_length } \u2500\u253c\" ) for _ in range ( len ( self . keys ) - 1 ): text . append ( f \" { '\u2500' * column_length } \u253c\" ) text . append ( f \" { '\u2500' * column_length } \u2524\" ) text . append ( \" \\n \" ) # lines for index , key in enumerate ( self . keys ): # noqa: WPS440 text . append ( f \" { key : > { max_key_length }} \u2502 { bold }{ index : > { key_line_length }}{ reset } \u2502\" ) for value in self . data [ index ]: text . append (( f \" { value if value else zero : > { column_length }} \u2502\" )) text . append ( \" \\n \" ) text . append ( \" \\n \" ) return \"\" . join ( text ) __init__ ( * nodes , depth = 0 ) \u00a4 Initialization method. Parameters: Name Type Description Default *nodes DSM | Package | Module The nodes on which to build the matrix. () depth int The depth of the matrix. This depth is always absolute, meaning that building a matrix with a sub-package \"A.B.C\" and a depth of 1 will return a matrix of size 1, containing A only. To see the matrix for the sub-modules and sub-packages in C, you will have to give depth=4. 0 Source code in dependenpy/structures.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def __init__ ( self , * nodes : DSM | Package | Module , depth : int = 0 ): # noqa: WPS231 \"\"\" Initialization method. Args: *nodes: The nodes on which to build the matrix. depth: The depth of the matrix. This depth is always absolute, meaning that building a matrix with a sub-package \"A.B.C\" and a depth of 1 will return a matrix of size 1, containing A only. To see the matrix for the sub-modules and sub-packages in C, you will have to give depth=4. \"\"\" modules : list [ Module ] = [] for node in nodes : if node . ismodule : modules . append ( node ) # type: ignore[arg-type] elif node . ispackage or node . isdsm : modules . extend ( node . submodules ) # type: ignore[union-attr] if depth < 1 : keys = modules else : keys = [] for module in modules : if module . depth <= depth : keys . append ( module ) continue package = module . package while package . depth > depth and package . package and package not in nodes : package = package . package if package not in keys : keys . append ( package ) size = len ( keys ) data = [[ 0 ] * size for _ in range ( size )] # noqa: WPS435 keys = sorted ( keys , key = lambda key : key . absolute_name ()) if depth < 1 : for index , key in enumerate ( keys ): # noqa: WPS440 key . index = index # type: ignore[attr-defined] for index , key in enumerate ( keys ): # noqa: WPS440 for dep in key . dependencies : if dep . external : continue if dep . target . ismodule and dep . target in keys : data [ index ][ dep . target . index ] += 1 elif dep . target . ispackage : init = dep . target . get ( \"__init__\" ) if init is not None and init in keys : data [ index ][ init . index ] += 1 else : for row , row_key in enumerate ( keys ): for col , col_key in enumerate ( keys ): data [ row ][ col ] = row_key . cardinal ( to = col_key ) self . size = size self . keys = [ key . absolute_name () for key in keys ] # noqa: WPS441 self . data = data cast ( keys , data ) staticmethod \u00a4 Cast a set of keys and an array to a Matrix object. Parameters: Name Type Description Default keys list [ str ] The matrix keys. required data list [ list [ int ]] The matrix data. required Returns: Type Description Matrix A new matrix. Source code in dependenpy/structures.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 @staticmethod # noqa: WPS602 def cast ( keys : list [ str ], data : list [ list [ int ]]) -> Matrix : # noqa: WPS602 \"\"\" Cast a set of keys and an array to a Matrix object. Arguments: keys: The matrix keys. data: The matrix data. Returns: A new matrix. \"\"\" matrix = Matrix () matrix . keys = copy . deepcopy ( keys ) matrix . data = copy . deepcopy ( data ) return matrix total () property \u00a4 Return the total number of dependencies within this matrix. Returns: Type Description int The total number of dependencies. Source code in dependenpy/structures.py 102 103 104 105 106 107 108 109 110 @property def total ( self ) -> int : \"\"\" Return the total number of dependencies within this matrix. Returns: The total number of dependencies. \"\"\" return sum ( cell for line in self . data for cell in line ) TreeMap \u00a4 Bases: PrintMixin TreeMap class. Source code in dependenpy/structures.py 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 class TreeMap ( PrintMixin ): \"\"\"TreeMap class.\"\"\" def __init__ ( self , * nodes : Any , value : int = - 1 ): \"\"\" Initialization method. Arguments: *nodes: the nodes from which to build the treemap. value: the value of the current area. \"\"\" # if nodes: # matrix_lower_level = Matrix(*nodes, depth=2) # matrix_current_level = Matrix(*nodes, depth=1) # if value == -1: # value = sum(c for row in matrix_current_level.data for c in row) # splits = [0] # key_comp = matrix_lower_level.keys[0].split('.')[0] # i = 1 # for key in matrix_lower_level.keys[1:]: # key = key.split('.')[0] # if key != key_comp: # splits.append(i) # key_comp = key # i += 1 # splits.append(i) # # self.data = [] # for i in range(len(splits) - 1): # self.data.append([]) # rows = matrix_lower_level.data[splits[i]:splits[i+1]] # for j in range(len(splits) - 1): # self.data[i].append([row[splits[j]:splits[j+1]] for row in rows]) self . value = value def _to_csv ( self , ** kwargs ): return \"\" def _to_json ( self , ** kwargs ): return \"\" def _to_text ( self , ** kwargs ): return \"\" __init__ ( * nodes , value =- 1 ) \u00a4 Initialization method. Parameters: Name Type Description Default *nodes Any the nodes from which to build the treemap. () value int the value of the current area. -1 Source code in dependenpy/structures.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 def __init__ ( self , * nodes : Any , value : int = - 1 ): \"\"\" Initialization method. Arguments: *nodes: the nodes from which to build the treemap. value: the value of the current area. \"\"\" # if nodes: # matrix_lower_level = Matrix(*nodes, depth=2) # matrix_current_level = Matrix(*nodes, depth=1) # if value == -1: # value = sum(c for row in matrix_current_level.data for c in row) # splits = [0] # key_comp = matrix_lower_level.keys[0].split('.')[0] # i = 1 # for key in matrix_lower_level.keys[1:]: # key = key.split('.')[0] # if key != key_comp: # splits.append(i) # key_comp = key # i += 1 # splits.append(i) # # self.data = [] # for i in range(len(splits) - 1): # self.data.append([]) # rows = matrix_lower_level.data[splits[i]:splits[i+1]] # for j in range(len(splits) - 1): # self.data[i].append([row[splits[j]:splits[j+1]] for row in rows]) self . value = value Vertex \u00a4 Bases: object Vertex class. Used in Graph class. Source code in dependenpy/structures.py 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 class Vertex ( object ): \"\"\"Vertex class. Used in Graph class.\"\"\" def __init__ ( self , name ): \"\"\" Initialization method. Args: name (str): name of the vertex. \"\"\" self . name = name self . edges_in = set () self . edges_out = set () def __str__ ( self ): return self . name def connect_to ( self , vertex : Vertex , weight : int = 1 ) -> Edge : \"\"\" Connect this vertex to another one. Args: vertex: Vertex to connect to. weight: Weight of the edge. Returns: The newly created edge. \"\"\" for edge in self . edges_out : if vertex == edge . vertex_in : return edge return Edge ( self , vertex , weight ) def connect_from ( self , vertex : Vertex , weight : int = 1 ) -> Edge : \"\"\" Connect another vertex to this one. Args: vertex: Vertex to connect from. weight: Weight of the edge. Returns: The newly created edge. \"\"\" for edge in self . edges_in : if vertex == edge . vertex_out : return edge return Edge ( vertex , self , weight ) __init__ ( name ) \u00a4 Initialization method. Parameters: Name Type Description Default name str name of the vertex. required Source code in dependenpy/structures.py 206 207 208 209 210 211 212 213 214 215 def __init__ ( self , name ): \"\"\" Initialization method. Args: name (str): name of the vertex. \"\"\" self . name = name self . edges_in = set () self . edges_out = set () connect_from ( vertex , weight = 1 ) \u00a4 Connect another vertex to this one. Parameters: Name Type Description Default vertex Vertex Vertex to connect from. required weight int Weight of the edge. 1 Returns: Type Description Edge The newly created edge. Source code in dependenpy/structures.py 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 def connect_from ( self , vertex : Vertex , weight : int = 1 ) -> Edge : \"\"\" Connect another vertex to this one. Args: vertex: Vertex to connect from. weight: Weight of the edge. Returns: The newly created edge. \"\"\" for edge in self . edges_in : if vertex == edge . vertex_out : return edge return Edge ( vertex , self , weight ) connect_to ( vertex , weight = 1 ) \u00a4 Connect this vertex to another one. Parameters: Name Type Description Default vertex Vertex Vertex to connect to. required weight int Weight of the edge. 1 Returns: Type Description Edge The newly created edge. Source code in dependenpy/structures.py 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 def connect_to ( self , vertex : Vertex , weight : int = 1 ) -> Edge : \"\"\" Connect this vertex to another one. Args: vertex: Vertex to connect to. weight: Weight of the edge. Returns: The newly created edge. \"\"\" for edge in self . edges_out : if vertex == edge . vertex_in : return edge return Edge ( self , vertex , weight )","title":"structures"},{"location":"reference/dependenpy/structures/#dependenpy.structures.Edge","text":"Bases: object Edge class. Used in Graph class. Source code in dependenpy/structures.py 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 class Edge ( object ): \"\"\"Edge class. Used in Graph class.\"\"\" def __init__ ( self , vertex_out , vertex_in , weight = 1 ): \"\"\" Initialization method. Args: vertex_out (Vertex): source vertex (edge going out). vertex_in (Vertex): target vertex (edge going in). weight (int): weight of the edge. \"\"\" self . vertex_out = None self . vertex_in = None self . weight = weight self . go_from ( vertex_out ) self . go_in ( vertex_in ) def __str__ ( self ): return f \" { self . vertex_out . name } -- { self . weight } --> { self . vertex_in . name } \" def go_from ( self , vertex ): \"\"\" Tell the edge to go out from this vertex. Args: vertex (Vertex): vertex to go from. \"\"\" if self . vertex_out : self . vertex_out . edges_out . remove ( self ) self . vertex_out = vertex vertex . edges_out . add ( self ) def go_in ( self , vertex ): \"\"\" Tell the edge to go into this vertex. Args: vertex (Vertex): vertex to go into. \"\"\" if self . vertex_in : self . vertex_in . edges_in . remove ( self ) self . vertex_in = vertex vertex . edges_in . add ( self )","title":"Edge"},{"location":"reference/dependenpy/structures/#dependenpy.structures.Edge.__init__","text":"Initialization method. Parameters: Name Type Description Default vertex_out Vertex source vertex (edge going out). required vertex_in Vertex target vertex (edge going in). required weight int weight of the edge. 1 Source code in dependenpy/structures.py 256 257 258 259 260 261 262 263 264 265 266 267 268 269 def __init__ ( self , vertex_out , vertex_in , weight = 1 ): \"\"\" Initialization method. Args: vertex_out (Vertex): source vertex (edge going out). vertex_in (Vertex): target vertex (edge going in). weight (int): weight of the edge. \"\"\" self . vertex_out = None self . vertex_in = None self . weight = weight self . go_from ( vertex_out ) self . go_in ( vertex_in )","title":"__init__()"},{"location":"reference/dependenpy/structures/#dependenpy.structures.Edge.go_from","text":"Tell the edge to go out from this vertex. Parameters: Name Type Description Default vertex Vertex vertex to go from. required Source code in dependenpy/structures.py 274 275 276 277 278 279 280 281 282 283 284 def go_from ( self , vertex ): \"\"\" Tell the edge to go out from this vertex. Args: vertex (Vertex): vertex to go from. \"\"\" if self . vertex_out : self . vertex_out . edges_out . remove ( self ) self . vertex_out = vertex vertex . edges_out . add ( self )","title":"go_from()"},{"location":"reference/dependenpy/structures/#dependenpy.structures.Edge.go_in","text":"Tell the edge to go into this vertex. Parameters: Name Type Description Default vertex Vertex vertex to go into. required Source code in dependenpy/structures.py 286 287 288 289 290 291 292 293 294 295 296 def go_in ( self , vertex ): \"\"\" Tell the edge to go into this vertex. Args: vertex (Vertex): vertex to go into. \"\"\" if self . vertex_in : self . vertex_in . edges_in . remove ( self ) self . vertex_in = vertex vertex . edges_in . add ( self )","title":"go_in()"},{"location":"reference/dependenpy/structures/#dependenpy.structures.Graph","text":"Bases: PrintMixin Graph class. A class to build a graph given a list of nodes. After instantiation, it has two attributes: vertices, the set of nodes, and edges, the set of edges. Source code in dependenpy/structures.py 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 class Graph ( PrintMixin ): \"\"\" Graph class. A class to build a graph given a list of nodes. After instantiation, it has two attributes: vertices, the set of nodes, and edges, the set of edges. \"\"\" def __init__ ( self , * nodes , depth = 0 ): \"\"\" Initialization method. An intermediary matrix is built to ease the creation of the graph. Args: *nodes (list of DSM/Package/Module): the nodes on which to build the graph. depth (int): the depth of the intermediary matrix. See the documentation for Matrix class. \"\"\" self . edges = set () vertices = [] matrix = Matrix ( * nodes , depth = depth ) for key in matrix . keys : vertices . append ( Vertex ( key )) for line_index , line in enumerate ( matrix . data ): for col_index , cell in enumerate ( line ): if cell > 0 : self . edges . add ( Edge ( vertices [ line_index ], vertices [ col_index ], weight = cell )) self . vertices = set ( vertices ) def _to_csv ( self , ** kwargs ): header = kwargs . pop ( \"header\" , True ) text = [ \"vertex_out,edge_weight,vertex_in \\n \" if header else \"\" ] for edge in self . edges : text . append ( f \" { edge . vertex_out . name } , { edge . weight } , { edge . vertex_in . name } \\n \" ) for vertex in self . vertices : if not ( vertex . edges_out or vertex . edges_in ): text . append ( \" {vertex.name} ,, \\n \" ) return \"\" . join ( text ) def _to_json ( self , ** kwargs ): return json . dumps ( { \"vertices\" : [ vertex . name for vertex in self . vertices ], \"edges\" : [ { \"out\" : edge . vertex_out . name , \"weight\" : edge . weight , \"in\" : edge . vertex_in . name } for edge in self . edges ], }, ** kwargs , ) def _to_text ( self , ** kwargs ): return \"\"","title":"Graph"},{"location":"reference/dependenpy/structures/#dependenpy.structures.Graph.__init__","text":"Initialization method. An intermediary matrix is built to ease the creation of the graph. Parameters: Name Type Description Default *nodes list of DSM/Package/Module the nodes on which to build the graph. () depth int the depth of the intermediary matrix. See the documentation for Matrix class. 0 Source code in dependenpy/structures.py 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 def __init__ ( self , * nodes , depth = 0 ): \"\"\" Initialization method. An intermediary matrix is built to ease the creation of the graph. Args: *nodes (list of DSM/Package/Module): the nodes on which to build the graph. depth (int): the depth of the intermediary matrix. See the documentation for Matrix class. \"\"\" self . edges = set () vertices = [] matrix = Matrix ( * nodes , depth = depth ) for key in matrix . keys : vertices . append ( Vertex ( key )) for line_index , line in enumerate ( matrix . data ): for col_index , cell in enumerate ( line ): if cell > 0 : self . edges . add ( Edge ( vertices [ line_index ], vertices [ col_index ], weight = cell )) self . vertices = set ( vertices )","title":"__init__()"},{"location":"reference/dependenpy/structures/#dependenpy.structures.Matrix","text":"Bases: PrintMixin Matrix class. A class to build a matrix given a list of nodes. After instantiation, it has two attributes: data, a 2-dimensions array, and keys, the names of the entities in the corresponding order. Source code in dependenpy/structures.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 class Matrix ( PrintMixin ): \"\"\" Matrix class. A class to build a matrix given a list of nodes. After instantiation, it has two attributes: data, a 2-dimensions array, and keys, the names of the entities in the corresponding order. \"\"\" def __init__ ( self , * nodes : DSM | Package | Module , depth : int = 0 ): # noqa: WPS231 \"\"\" Initialization method. Args: *nodes: The nodes on which to build the matrix. depth: The depth of the matrix. This depth is always absolute, meaning that building a matrix with a sub-package \"A.B.C\" and a depth of 1 will return a matrix of size 1, containing A only. To see the matrix for the sub-modules and sub-packages in C, you will have to give depth=4. \"\"\" modules : list [ Module ] = [] for node in nodes : if node . ismodule : modules . append ( node ) # type: ignore[arg-type] elif node . ispackage or node . isdsm : modules . extend ( node . submodules ) # type: ignore[union-attr] if depth < 1 : keys = modules else : keys = [] for module in modules : if module . depth <= depth : keys . append ( module ) continue package = module . package while package . depth > depth and package . package and package not in nodes : package = package . package if package not in keys : keys . append ( package ) size = len ( keys ) data = [[ 0 ] * size for _ in range ( size )] # noqa: WPS435 keys = sorted ( keys , key = lambda key : key . absolute_name ()) if depth < 1 : for index , key in enumerate ( keys ): # noqa: WPS440 key . index = index # type: ignore[attr-defined] for index , key in enumerate ( keys ): # noqa: WPS440 for dep in key . dependencies : if dep . external : continue if dep . target . ismodule and dep . target in keys : data [ index ][ dep . target . index ] += 1 elif dep . target . ispackage : init = dep . target . get ( \"__init__\" ) if init is not None and init in keys : data [ index ][ init . index ] += 1 else : for row , row_key in enumerate ( keys ): for col , col_key in enumerate ( keys ): data [ row ][ col ] = row_key . cardinal ( to = col_key ) self . size = size self . keys = [ key . absolute_name () for key in keys ] # noqa: WPS441 self . data = data @staticmethod # noqa: WPS602 def cast ( keys : list [ str ], data : list [ list [ int ]]) -> Matrix : # noqa: WPS602 \"\"\" Cast a set of keys and an array to a Matrix object. Arguments: keys: The matrix keys. data: The matrix data. Returns: A new matrix. \"\"\" matrix = Matrix () matrix . keys = copy . deepcopy ( keys ) matrix . data = copy . deepcopy ( data ) return matrix @property def total ( self ) -> int : \"\"\" Return the total number of dependencies within this matrix. Returns: The total number of dependencies. \"\"\" return sum ( cell for line in self . data for cell in line ) def _to_csv ( self , ** kwargs ): text = [ \"module,\" , \",\" . join ( self . keys )] for index , key in enumerate ( self . keys ): line = \",\" . join ( map ( str , self . data [ index ])) text . append ( f \" { key } , { line } \" ) return \" \\n \" . join ( text ) def _to_json ( self , ** kwargs ): return json . dumps ({ \"keys\" : self . keys , \"data\" : self . data }, ** kwargs ) def _to_text ( self , ** kwargs ): if not self . keys or not self . data : return \"\" zero = kwargs . pop ( \"zero\" , \"0\" ) max_key_length = max ( len ( key ) for key in self . keys + [ \"Module\" ]) max_dep_length = max ([ len ( str ( col )) for line in self . data for col in line ] + [ len ( zero )]) key_col_length = len ( str ( len ( self . keys ))) key_line_length = max ( key_col_length , 2 ) column_length = max ( key_col_length , max_dep_length ) bold = Style . BRIGHT reset = Style . RESET_ALL # first line left headers text = [ f \" \\n { bold }{ 'Module' : > { max_key_length }}{ reset } \u2502 { bold }{ 'Id' : > { key_line_length }}{ reset } \u2502\" ] # first line column headers for index , _ in enumerate ( self . keys ): text . append ( f \" { bold }{ index : ^ { column_length }}{ reset } \u2502\" ) text . append ( \" \\n \" ) # line of dashes text . append ( f \" { '\u2500' * max_key_length } \u2500\u253c\u2500 { '\u2500' * key_line_length } \u2500\u253c\" ) for _ in range ( len ( self . keys ) - 1 ): text . append ( f \" { '\u2500' * column_length } \u253c\" ) text . append ( f \" { '\u2500' * column_length } \u2524\" ) text . append ( \" \\n \" ) # lines for index , key in enumerate ( self . keys ): # noqa: WPS440 text . append ( f \" { key : > { max_key_length }} \u2502 { bold }{ index : > { key_line_length }}{ reset } \u2502\" ) for value in self . data [ index ]: text . append (( f \" { value if value else zero : > { column_length }} \u2502\" )) text . append ( \" \\n \" ) text . append ( \" \\n \" ) return \"\" . join ( text )","title":"Matrix"},{"location":"reference/dependenpy/structures/#dependenpy.structures.Matrix.__init__","text":"Initialization method. Parameters: Name Type Description Default *nodes DSM | Package | Module The nodes on which to build the matrix. () depth int The depth of the matrix. This depth is always absolute, meaning that building a matrix with a sub-package \"A.B.C\" and a depth of 1 will return a matrix of size 1, containing A only. To see the matrix for the sub-modules and sub-packages in C, you will have to give depth=4. 0 Source code in dependenpy/structures.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 def __init__ ( self , * nodes : DSM | Package | Module , depth : int = 0 ): # noqa: WPS231 \"\"\" Initialization method. Args: *nodes: The nodes on which to build the matrix. depth: The depth of the matrix. This depth is always absolute, meaning that building a matrix with a sub-package \"A.B.C\" and a depth of 1 will return a matrix of size 1, containing A only. To see the matrix for the sub-modules and sub-packages in C, you will have to give depth=4. \"\"\" modules : list [ Module ] = [] for node in nodes : if node . ismodule : modules . append ( node ) # type: ignore[arg-type] elif node . ispackage or node . isdsm : modules . extend ( node . submodules ) # type: ignore[union-attr] if depth < 1 : keys = modules else : keys = [] for module in modules : if module . depth <= depth : keys . append ( module ) continue package = module . package while package . depth > depth and package . package and package not in nodes : package = package . package if package not in keys : keys . append ( package ) size = len ( keys ) data = [[ 0 ] * size for _ in range ( size )] # noqa: WPS435 keys = sorted ( keys , key = lambda key : key . absolute_name ()) if depth < 1 : for index , key in enumerate ( keys ): # noqa: WPS440 key . index = index # type: ignore[attr-defined] for index , key in enumerate ( keys ): # noqa: WPS440 for dep in key . dependencies : if dep . external : continue if dep . target . ismodule and dep . target in keys : data [ index ][ dep . target . index ] += 1 elif dep . target . ispackage : init = dep . target . get ( \"__init__\" ) if init is not None and init in keys : data [ index ][ init . index ] += 1 else : for row , row_key in enumerate ( keys ): for col , col_key in enumerate ( keys ): data [ row ][ col ] = row_key . cardinal ( to = col_key ) self . size = size self . keys = [ key . absolute_name () for key in keys ] # noqa: WPS441 self . data = data","title":"__init__()"},{"location":"reference/dependenpy/structures/#dependenpy.structures.Matrix.cast","text":"Cast a set of keys and an array to a Matrix object. Parameters: Name Type Description Default keys list [ str ] The matrix keys. required data list [ list [ int ]] The matrix data. required Returns: Type Description Matrix A new matrix. Source code in dependenpy/structures.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 @staticmethod # noqa: WPS602 def cast ( keys : list [ str ], data : list [ list [ int ]]) -> Matrix : # noqa: WPS602 \"\"\" Cast a set of keys and an array to a Matrix object. Arguments: keys: The matrix keys. data: The matrix data. Returns: A new matrix. \"\"\" matrix = Matrix () matrix . keys = copy . deepcopy ( keys ) matrix . data = copy . deepcopy ( data ) return matrix","title":"cast()"},{"location":"reference/dependenpy/structures/#dependenpy.structures.Matrix.total","text":"Return the total number of dependencies within this matrix. Returns: Type Description int The total number of dependencies. Source code in dependenpy/structures.py 102 103 104 105 106 107 108 109 110 @property def total ( self ) -> int : \"\"\" Return the total number of dependencies within this matrix. Returns: The total number of dependencies. \"\"\" return sum ( cell for line in self . data for cell in line )","title":"total()"},{"location":"reference/dependenpy/structures/#dependenpy.structures.TreeMap","text":"Bases: PrintMixin TreeMap class. Source code in dependenpy/structures.py 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 class TreeMap ( PrintMixin ): \"\"\"TreeMap class.\"\"\" def __init__ ( self , * nodes : Any , value : int = - 1 ): \"\"\" Initialization method. Arguments: *nodes: the nodes from which to build the treemap. value: the value of the current area. \"\"\" # if nodes: # matrix_lower_level = Matrix(*nodes, depth=2) # matrix_current_level = Matrix(*nodes, depth=1) # if value == -1: # value = sum(c for row in matrix_current_level.data for c in row) # splits = [0] # key_comp = matrix_lower_level.keys[0].split('.')[0] # i = 1 # for key in matrix_lower_level.keys[1:]: # key = key.split('.')[0] # if key != key_comp: # splits.append(i) # key_comp = key # i += 1 # splits.append(i) # # self.data = [] # for i in range(len(splits) - 1): # self.data.append([]) # rows = matrix_lower_level.data[splits[i]:splits[i+1]] # for j in range(len(splits) - 1): # self.data[i].append([row[splits[j]:splits[j+1]] for row in rows]) self . value = value def _to_csv ( self , ** kwargs ): return \"\" def _to_json ( self , ** kwargs ): return \"\" def _to_text ( self , ** kwargs ): return \"\"","title":"TreeMap"},{"location":"reference/dependenpy/structures/#dependenpy.structures.TreeMap.__init__","text":"Initialization method. Parameters: Name Type Description Default *nodes Any the nodes from which to build the treemap. () value int the value of the current area. -1 Source code in dependenpy/structures.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 def __init__ ( self , * nodes : Any , value : int = - 1 ): \"\"\" Initialization method. Arguments: *nodes: the nodes from which to build the treemap. value: the value of the current area. \"\"\" # if nodes: # matrix_lower_level = Matrix(*nodes, depth=2) # matrix_current_level = Matrix(*nodes, depth=1) # if value == -1: # value = sum(c for row in matrix_current_level.data for c in row) # splits = [0] # key_comp = matrix_lower_level.keys[0].split('.')[0] # i = 1 # for key in matrix_lower_level.keys[1:]: # key = key.split('.')[0] # if key != key_comp: # splits.append(i) # key_comp = key # i += 1 # splits.append(i) # # self.data = [] # for i in range(len(splits) - 1): # self.data.append([]) # rows = matrix_lower_level.data[splits[i]:splits[i+1]] # for j in range(len(splits) - 1): # self.data[i].append([row[splits[j]:splits[j+1]] for row in rows]) self . value = value","title":"__init__()"},{"location":"reference/dependenpy/structures/#dependenpy.structures.Vertex","text":"Bases: object Vertex class. Used in Graph class. Source code in dependenpy/structures.py 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 class Vertex ( object ): \"\"\"Vertex class. Used in Graph class.\"\"\" def __init__ ( self , name ): \"\"\" Initialization method. Args: name (str): name of the vertex. \"\"\" self . name = name self . edges_in = set () self . edges_out = set () def __str__ ( self ): return self . name def connect_to ( self , vertex : Vertex , weight : int = 1 ) -> Edge : \"\"\" Connect this vertex to another one. Args: vertex: Vertex to connect to. weight: Weight of the edge. Returns: The newly created edge. \"\"\" for edge in self . edges_out : if vertex == edge . vertex_in : return edge return Edge ( self , vertex , weight ) def connect_from ( self , vertex : Vertex , weight : int = 1 ) -> Edge : \"\"\" Connect another vertex to this one. Args: vertex: Vertex to connect from. weight: Weight of the edge. Returns: The newly created edge. \"\"\" for edge in self . edges_in : if vertex == edge . vertex_out : return edge return Edge ( vertex , self , weight )","title":"Vertex"},{"location":"reference/dependenpy/structures/#dependenpy.structures.Vertex.__init__","text":"Initialization method. Parameters: Name Type Description Default name str name of the vertex. required Source code in dependenpy/structures.py 206 207 208 209 210 211 212 213 214 215 def __init__ ( self , name ): \"\"\" Initialization method. Args: name (str): name of the vertex. \"\"\" self . name = name self . edges_in = set () self . edges_out = set ()","title":"__init__()"},{"location":"reference/dependenpy/structures/#dependenpy.structures.Vertex.connect_from","text":"Connect another vertex to this one. Parameters: Name Type Description Default vertex Vertex Vertex to connect from. required weight int Weight of the edge. 1 Returns: Type Description Edge The newly created edge. Source code in dependenpy/structures.py 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 def connect_from ( self , vertex : Vertex , weight : int = 1 ) -> Edge : \"\"\" Connect another vertex to this one. Args: vertex: Vertex to connect from. weight: Weight of the edge. Returns: The newly created edge. \"\"\" for edge in self . edges_in : if vertex == edge . vertex_out : return edge return Edge ( vertex , self , weight )","title":"connect_from()"},{"location":"reference/dependenpy/structures/#dependenpy.structures.Vertex.connect_to","text":"Connect this vertex to another one. Parameters: Name Type Description Default vertex Vertex Vertex to connect to. required weight int Weight of the edge. 1 Returns: Type Description Edge The newly created edge. Source code in dependenpy/structures.py 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 def connect_to ( self , vertex : Vertex , weight : int = 1 ) -> Edge : \"\"\" Connect this vertex to another one. Args: vertex: Vertex to connect to. weight: Weight of the edge. Returns: The newly created edge. \"\"\" for edge in self . edges_out : if vertex == edge . vertex_in : return edge return Edge ( self , vertex , weight )","title":"connect_to()"},{"location":"coverage/","text":".md-content { max-width: none !important; } article h1, article > a { display: none; } var coviframe = document.getElementById(\"coviframe\"); function resizeIframe() { coviframe.style.height = coviframe.contentWindow.document.documentElement.offsetHeight + 'px'; } coviframe.contentWindow.document.body.onclick = function() { coviframe.contentWindow.location.reload(); }","title":"Coverage report"}]}