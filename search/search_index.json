{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Dependenpy","text":"<p>Show the inter-dependencies between modules of Python packages.</p> <p><code>dependenpy</code> allows you to build a dependency matrix for a set of Python packages. To do this, it reads and searches the source code for import statements.</p> <p></p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install dependenpy\n</code></pre> <p>With <code>uv</code>:</p> <pre><code>uv tool install dependenpy\n</code></pre>"},{"location":"#usage-as-a-library","title":"Usage (as a library)","text":"<pre><code>from dependenpy import DSM\n\n# create DSM\ndsm = DSM('django')\n\n# transform as matrix\nmatrix = dsm.as_matrix(depth=2)\n\n# initialize with many packages\ndsm = DSM('django', 'meerkat', 'appsettings', 'dependenpy', 'archan')\nwith open('output', 'w') as output:\n    dsm.print(format='json', indent=2, output=output)\n\n# access packages and modules\nmeerkat = dsm['meerkat']  # or dsm.get('meerkat')\nfinder = dsm['dependenpy.finder']  # or even dsm['dependenpy']['finder']\n\n# instances of DSM and Package all have print, as_matrix, etc. methods\nmeerkat.print_matrix(depth=2)\n</code></pre> <p>This package was originally design to work in a Django project. The Django package django-meerkat uses it to display the matrices with Highcharts.</p>"},{"location":"#usage-command-line","title":"Usage (command-line)","text":"<pre><code>usage: dependenpy [-d DEPTH] [-f {csv,json,text}] [-g] [-G] [-h]\n                  [-i INDENT] [-l] [-m] [-o OUTPUT] [-t] [-v] \n                  [-z STRING] PACKAGES [PACKAGES ...]\n\nCommand line tool for dependenpy Python package.\n\npositional arguments:\n  PACKAGES              The package list. Can be a comma-separated list. Each\n                        package must be either a valid path or a package in\n                        PYTHONPATH.\n\noptional arguments:\n  -d DEPTH, --depth DEPTH\n                        Specify matrix or graph depth. Default: best guess.\n  -f {csv,json,text}, --format {csv,json,text}\n                        Output format. Default: text.\n  -g, --show-graph      Show the graph (no text format). Default: false.\n  -G, --greedy          Explore subdirectories even if they do not contain an\n                        __init__.py file. Can make execution slower. Default:\n                        false.\n  -h, --help            Show this help message and exit.\n  -i INDENT, --indent INDENT\n                        Specify output indentation. CSV will never be\n                        indented. Text will always have new-lines. JSON can be\n                        minified with a negative value. Default: best guess.\n  -l, --show-dependencies-list\n                        Show the dependencies list. Default: false.\n  -m, --show-matrix     Show the matrix. Default: true unless -g, -l or -t.\n  -o OUTPUT, --output OUTPUT\n                        Output to given file. Default: stdout.\n  -t, --show-treemap    Show the treemap (work in progress). Default: false.\n  -v, --version         Show the current version of the program and exit.\n  -z ZERO, --zero ZERO  Character to use for cells with value=0 (text matrix \n                        display only). Default: \"0\".\n</code></pre> <p>Example:</p> <pre><code>$ # running dependenpy on itself\n$ dependenpy dependenpy -z=\n\n                Module \u2502 Id \u25020\u25021\u25022\u25023\u25024\u25025\u25026\u25027\u25028\u2502\n \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u253c\u2500\u2524\n   dependenpy.__init__ \u2502  0 \u2502 \u2502 \u2502 \u25024\u2502 \u2502 \u2502 \u2502 \u25022\u2502\n   dependenpy.__main__ \u2502  1 \u2502 \u2502 \u25021\u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502\n        dependenpy.cli \u2502  2 \u25021\u2502 \u2502 \u25021\u2502 \u25024\u2502 \u2502 \u2502 \u2502\n        dependenpy.dsm \u2502  3 \u2502 \u2502 \u2502 \u2502 \u25022\u25021\u25023\u2502 \u2502 \u2502\n     dependenpy.finder \u2502  4 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502\n    dependenpy.helpers \u2502  5 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502\n       dependenpy.node \u2502  6 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u25023\u2502\n    dependenpy.plugins \u2502  7 \u2502 \u2502 \u2502 \u25021\u2502 \u25021\u2502 \u2502 \u2502 \u2502\n dependenpy.structures \u2502  8 \u2502 \u2502 \u2502 \u2502 \u2502 \u25021\u2502 \u2502 \u2502 \u2502\n</code></pre>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#333-2025-09-19","title":"3.3.3 - 2025-09-19","text":"<p>Compare with 3.3.2</p>"},{"location":"changelog/#build","title":"Build","text":"<ul> <li>Update main entrypoint path (907f525 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#code-refactoring","title":"Code Refactoring","text":"<ul> <li>Add back previous module layout as deprecated (dd9f563 by Timoth\u00e9e Mazzucotelli).</li> <li>Move modules under internal folder, re-expose API at the top-level (cad1295 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#332-2022-09-04","title":"3.3.2 - 2022-09-04","text":"<p>Compare with 3.3.1</p>"},{"location":"changelog/#bug-fixes","title":"Bug Fixes","text":"<ul> <li>Add back missing colorama runtime dependency (f3e274c by Vlad Dumitrescu). References: #57</li> <li>Copy data when casting a matrix (13ec81a by Vlad Dumitrescu). References: #53</li> </ul>"},{"location":"changelog/#331-2022-06-13","title":"3.3.1 - 2022-06-13","text":"<p>Compare with 3.3.0</p>"},{"location":"changelog/#bug-fixes_1","title":"Bug Fixes","text":"<ul> <li>Handle the case where all modules names are shorter than the header when printing a matrix (1d83b17 by Vlad Dumitrescu). PR #48</li> </ul>"},{"location":"changelog/#330-2020-09-04","title":"3.3.0 - 2020-09-04","text":"<p>Compare with 3.2.0</p>"},{"location":"changelog/#code-refactoring_1","title":"Code Refactoring","text":"<ul> <li>Poetrize the project (811c3fb by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#features","title":"Features","text":"<ul> <li>Add 'zero' argument to change character for 0 (1c13c00 by Timoth\u00e9e Mazzucotelli).</li> <li>Update archan provider for archan 3.0 (9249dc1 by Timoth\u00e9e Mazzucotelli).</li> </ul>"},{"location":"changelog/#320-2017-06-27","title":"3.2.0 - 2017-06-27","text":"<p>Compare with 3.1.0</p>"},{"location":"changelog/#features_1","title":"Features","text":"<ul> <li>Add graph option (1ebc8f6).</li> <li>Implement archan provider (66edb5b).</li> </ul>"},{"location":"changelog/#310-2017-06-02","title":"3.1.0 - 2017-06-02","text":"<p>Compare with 3.0.0</p>"},{"location":"changelog/#features_2","title":"Features","text":"<ul> <li>Add <code>-i, --indent</code> option to specify indentation level.</li> </ul>"},{"location":"changelog/#changes","title":"Changes","text":"<ul> <li>Change <code>-i, --enforce-init</code> option to its contrary <code>-g, --greedy</code>.</li> <li>Options <code>-l</code>, <code>-m</code> and <code>-t</code> are now mutually exclusive.</li> </ul>"},{"location":"changelog/#bug-fixes_2","title":"Bug fixes","text":"<ul> <li>Fix imports order (9a9fcc3).</li> <li>Fix matrix build for depth=0 (955cc21).</li> </ul>"},{"location":"changelog/#misc","title":"Misc","text":"<ul> <li>Improve cli tool and print methods, </li> </ul>"},{"location":"changelog/#300-2017-05-22","title":"3.0.0 - 2017-05-22","text":"<p>Compare with 2.0.3</p> <p>This version is a big refactoring. The code is way more object oriented, cleaner, shorter, simpler, smarter, more user friendly- in short: better.</p> <p>Additional features:</p> <ul> <li>command line entry point,</li> <li>runtime static imports are now caught (in functions or classes),   as well as import statements (previously only from import).</li> </ul>"},{"location":"changelog/#203-2017-04-20","title":"2.0.3 - 2017-04-20","text":"<p>Compare with 2.0.2</p>"},{"location":"changelog/#changes_1","title":"Changes","text":"<ul> <li>Change license from MPL 2.0 to ISC (35400bf).</li> </ul>"},{"location":"changelog/#bug-fixes_3","title":"Bug fixes","text":"<ul> <li>Fix occasional UnicodeEncode when reading utf8 file (333e987).</li> <li>Handle bad characters in files when parsing with ast (200e014).</li> </ul>"},{"location":"changelog/#202-2016-10-06","title":"2.0.2 - 2016-10-06","text":"<p>Compare with 1.0.4</p> <ul> <li>Split code in two projects: dependenpy and archan.</li> <li>Update to use Python 3.</li> <li>Various bug fixes, additions, improvements and refactor.</li> </ul>"},{"location":"changelog/#104-2015-03-05","title":"1.0.4 - 2015-03-05","text":"<p>Compare with 1.0.3</p> <p>Documentation and tests improvements.</p>"},{"location":"changelog/#103-2015-02-26","title":"1.0.3 - 2015-02-26","text":"<p>Compare with 1.0.2</p>"},{"location":"changelog/#bug-fixes_4","title":"Bug fixes","text":"<ul> <li>Add check for target_index not None (d3e573f).</li> </ul>"},{"location":"changelog/#102-2015-02-24","title":"1.0.2 - 2015-02-24","text":"<p>Compare with 1.0.1</p>"},{"location":"changelog/#features_3","title":"Features","text":"<ul> <li>Added CSV export (ce8a911).</li> </ul>"},{"location":"changelog/#bug-fixes_5","title":"Bug fixes","text":"<ul> <li>Fix get_matrix if str instead of int, fix csv write row (extend return None) (bb1289d).</li> </ul>"},{"location":"changelog/#101-2015-02-23","title":"1.0.1 - 2015-02-23","text":"<p>Compare with 1.0</p>"},{"location":"changelog/#bug-fixes_6","title":"Bug fixes","text":"<ul> <li>Fix hashable for dict (7d221db).</li> <li>Fix path resolver (4e8a192).</li> </ul>"},{"location":"changelog/#10-2015-02-23","title":"1.0 - 2015-02-23","text":"<p>Compare with 0.2-beta</p>"},{"location":"changelog/#code-refactoring_2","title":"Code refactoring","text":"<ul> <li>4bd14d9</li> <li>15ba1e5</li> <li>12fa604</li> </ul>"},{"location":"changelog/#02-beta-2015-02-20","title":"0.2-beta - 2015-02-20","text":"<p>Compare with first commit</p> <p>First release.</p>"},{"location":"code_of_conduct/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes, and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances of any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email address, without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a professional setting</li> </ul>"},{"location":"code_of_conduct/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at dev@pawamoy.fr. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"code_of_conduct/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"code_of_conduct/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"code_of_conduct/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"code_of_conduct/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"code_of_conduct/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"code_of_conduct/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://www.contributor-covenant.org/version/2/1/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given.</p>"},{"location":"contributing/#environment-setup","title":"Environment setup","text":"<p>Nothing easier!</p> <p>Fork and clone the repository, then:</p> <pre><code>cd dependenpy\nmake setup\n</code></pre> <p>Note</p> <p>If it fails for some reason, you'll need to install uv manually.</p> <p>You can install it with:</p> <pre><code>curl -LsSf https://astral.sh/uv/install.sh | sh\n</code></pre> <p>Now you can try running <code>make setup</code> again, or simply <code>uv sync</code>.</p> <p>You now have the dependencies installed.</p> <p>You can run the application with <code>make run dependenpy [ARGS...]</code>.</p> <p>Run <code>make help</code> to see all the available actions!</p>"},{"location":"contributing/#tasks","title":"Tasks","text":"<p>The entry-point to run commands and tasks is the <code>make</code> Python script, located in the <code>scripts</code> directory. Try running <code>make</code> to show the available commands and tasks. The commands do not need the Python dependencies to be installed, while the tasks do. The cross-platform tasks are written in Python, thanks to duty.</p> <p>If you work in VSCode, we provide an action to configure VSCode for the project.</p>"},{"location":"contributing/#development","title":"Development","text":"<p>As usual:</p> <ol> <li>create a new branch: <code>git switch -c feature-or-bugfix-name</code></li> <li>edit the code and/or the documentation</li> </ol> <p>Before committing:</p> <ol> <li>run <code>make format</code> to auto-format the code</li> <li>run <code>make check</code> to check everything (fix any warning)</li> <li>run <code>make test</code> to run the tests (fix any issue)</li> <li>if you updated the documentation or the project dependencies:<ol> <li>run <code>make docs</code></li> <li>go to http://localhost:8000 and check that everything looks good</li> </ol> </li> <li>follow our commit message convention</li> </ol> <p>If you are unsure about how to fix or ignore a warning, just let the continuous integration fail, and we will help you during review.</p> <p>Don't bother updating the changelog, we will take care of this.</p>"},{"location":"contributing/#commit-message-convention","title":"Commit message convention","text":"<p>Commit messages must follow our convention based on the Angular style or the Karma convention:</p> <pre><code>&lt;type&gt;[(scope)]: Subject\n\n[Body]\n</code></pre> <p>Subject and body must be valid Markdown. Subject must have proper casing (uppercase for first letter if it makes sense), but no dot at the end, and no punctuation in general.</p> <p>Scope and body are optional. Type can be:</p> <ul> <li><code>build</code>: About packaging, building wheels, etc.</li> <li><code>chore</code>: About packaging or repo/files management.</li> <li><code>ci</code>: About Continuous Integration.</li> <li><code>deps</code>: Dependencies update.</li> <li><code>docs</code>: About documentation.</li> <li><code>feat</code>: New feature.</li> <li><code>fix</code>: Bug fix.</li> <li><code>perf</code>: About performance.</li> <li><code>refactor</code>: Changes that are not features or bug fixes.</li> <li><code>style</code>: A change in code style/format.</li> <li><code>tests</code>: About tests.</li> </ul> <p>If you write a body, please add trailers at the end (for example issues and PR references, or co-authors), without relying on GitHub's flavored Markdown:</p> <pre><code>Body.\n\nIssue #10: https://github.com/namespace/project/issues/10\nRelated to PR namespace/other-project#15: https://github.com/namespace/other-project/pull/15\n</code></pre> <p>These \"trailers\" must appear at the end of the body, without any blank lines between them. The trailer title can contain any character except colons <code>:</code>. We expect a full URI for each trailer, not just GitHub autolinks (for example, full GitHub URLs for commits and issues, not the hash or the #issue-number).</p> <p>We do not enforce a line length on commit messages summary and body, but please avoid very long summaries, and very long lines in the body, unless they are part of code blocks that must not be wrapped.</p>"},{"location":"contributing/#pull-requests-guidelines","title":"Pull requests guidelines","text":"<p>Link to any related issue in the Pull Request message.</p> <p>During the review, we recommend using fixups:</p> <pre><code># SHA is the SHA of the commit you want to fix\ngit commit --fixup=SHA\n</code></pre> <p>Once all the changes are approved, you can squash your commits:</p> <pre><code>git rebase -i --autosquash main\n</code></pre> <p>And force-push:</p> <pre><code>git push -f\n</code></pre> <p>If this seems all too complicated, you can push or force-push each new commit, and we will squash them ourselves if needed, before merging.</p>"},{"location":"credits/","title":"Credits","text":""},{"location":"credits/#exec-1--credits","title":"Credits","text":"<p>These projects were used to build dependenpy. Thank you!</p> <p>Python | uv | copier-uv</p>"},{"location":"credits/#exec-1--runtime-dependencies","title":"Runtime dependencies","text":"Project Summary Version (accepted) Version (last resolved) License colorama Cross-platform colored terminal text. <code>&gt;=0.4.5, &gt;=0.4</code> <code>0.4.6</code> BSD License"},{"location":"credits/#exec-1--development-dependencies","title":"Development dependencies","text":"Project Summary Version (accepted) Version (last resolved) License ansimarkup Produce colored terminal text with an xml-like markup <code>~=1.4</code> <code>1.5.0</code> Revised BSD License babel Internationalization utilities <code>&gt;=2.7.0</code> <code>2.17.0</code> BSD-3-Clause backrefs A wrapper around re and regex that adds additional back references. <code>~=5.7.post1</code> <code>5.9</code> MIT beautifulsoup4 Screen-scraping library <code>&gt;=4.12</code> <code>4.13.5</code> MIT License build A simple, correct Python build frontend <code>&gt;=1.2</code> <code>1.3.0</code> MIT cappa Declarative CLI argument parser. <code>&gt;=0.29</code> <code>0.30.2</code> ? certifi Python package for providing Mozilla's CA Bundle. <code>&gt;=2017.4.17</code> <code>2025.8.3</code> MPL-2.0 cffi Foreign Function Interface for Python calling C code. <code>&gt;=1.14</code> <code>2.0.0</code> MIT charset-normalizer The Real First Universal Charset Detector. Open, modern and actively maintained alternative to Chardet. <code>&gt;=2, &lt;4</code> <code>3.4.3</code> MIT click Composable command line interface toolkit <code>&lt;8.2.2</code> <code>8.2.1</code> BSD-3-Clause colorama Cross-platform colored terminal text. <code>&gt;=0.4.5, &gt;=0.4</code> <code>0.4.6</code> BSD License coverage Code coverage measurement for Python <code>&gt;=7.10.6</code> <code>7.10.6</code> Apache-2.0 cryptography cryptography is a package which provides cryptographic recipes and primitives to Python developers. <code>&gt;=2.0</code> <code>46.0.1</code> Apache-2.0 OR BSD-3-Clause csscompressor A python port of YUI CSS Compressor <code>&gt;=0.9.5</code> <code>0.9.5</code> BSD docutils Docutils -- Python Documentation Utilities <code>&gt;=0.21.2</code> <code>0.22.1</code> Public Domain + BSD License + GNU General Public License (GPL) duty A simple task runner. <code>&gt;=1.6</code> <code>1.6.3</code> ISC execnet execnet: rapid multi-Python deployment <code>&gt;=2.1</code> <code>2.1.1</code> MIT failprint Run a command, print its output only if it fails. <code>&gt;=1.0.5</code> <code>1.0.6</code> ISC ghp-import Copy your docs directly to the gh-pages branch. <code>&gt;=1.0</code> <code>2.1.0</code> Apache Software License git-changelog Automatic Changelog generator using Jinja2 templates. <code>&gt;=2.5</code> <code>2.6.3</code> ISC gitdb Git Object Database <code>&gt;=4.0.1, &lt;5</code> <code>4.0.12</code> BSD License GitPython GitPython is a Python library used to interact with Git repositories <code>&gt;=3.1.44</code> <code>3.1.45</code> BSD-3-Clause griffe Signatures for entire Python programs. Extract the structure, the frame, the skeleton of your project, to generate API documentation or find breaking changes in your API. <code>&gt;=1.13</code> <code>1.14.0.1.3.1</code> ISC htmlmin2 An HTML Minifier <code>&gt;=0.1.13</code> <code>0.1.13</code> BSD humanize Python humanize utilities <code>&gt;=4.9</code> <code>4.13.0</code> MIT id A tool for generating OIDC identities <code>1.5.0</code> Apache Software License idna Internationalized Domain Names in Applications (IDNA) <code>&gt;=2.5, &lt;4</code> <code>3.10</code> BSD License iniconfig brain-dead simple config-ini parsing <code>&gt;=1</code> <code>2.1.0</code> MIT jaraco.classes Utility functions for Python class constructs <code>3.4.0</code> MIT License jaraco.context Useful decorators and context managers <code>6.0.1</code> MIT License jaraco.functools Functools like those found in stdlib <code>4.3.0</code> MIT jeepney Low-level, pure Python DBus protocol wrapper. <code>&gt;=0.4.2</code> <code>0.9.0</code> MIT Jinja2 A very fast and expressive template engine. <code>&gt;=3.0</code> <code>3.1.6</code> BSD License jsmin JavaScript minifier. <code>&gt;=3.0.1</code> <code>3.0.1</code> MIT License keyring Store and access your passwords safely. <code>&gt;=21.2.0</code> <code>25.6.0</code> MIT License Markdown Python implementation of John Gruber's Markdown. <code>~=3.2</code> <code>3.9</code> BSD-3-Clause markdown-callouts Markdown extension: a classier syntax for admonitions <code>&gt;=0.4</code> <code>0.4.0</code> MIT markdown-exec Utilities to execute code blocks in Markdown files. <code>&gt;=1.8</code> <code>1.11.0.1.1.1</code> ISC markdown-it-py Python port of markdown-it. Markdown parsing, done right! <code>&gt;=2.2.0</code> <code>3.0.0</code> MIT License markdownify Convert HTML to markdown. <code>&gt;=0.14</code> <code>1.2.0</code> MIT License MarkupSafe Safely add untrusted strings to HTML/XML markup. <code>&gt;=2.0</code> <code>3.0.2</code> BSD License mdformat CommonMark compliant Markdown formatter <code>&gt;=0.7.21</code> <code>0.7.22</code> MIT License mdformat_tables An mdformat plugin for rendering tables. <code>&gt;=1.0</code> <code>1.0.0</code> MIT License mdurl Markdown URL utilities <code>~=0.1</code> <code>0.1.2</code> MIT License mergedeep A deep merge function for \ud83d\udc0d. <code>~=1.3</code> <code>1.3.4</code> MIT License mkdocs Project documentation with Markdown. <code>&gt;=1.6</code> <code>1.6.1</code> BSD-2-Clause mkdocs-autorefs Automatically link across pages in MkDocs. <code>&gt;=1.4</code> <code>1.4.3</code> ISC mkdocs-coverage MkDocs plugin to integrate your coverage HTML report into your site. <code>&gt;=1.0</code> <code>2.0.0</code> ISC mkdocs-get-deps MkDocs extension that lists all dependencies according to a mkdocs.yml file <code>&gt;=0.2.0</code> <code>0.2.0</code> MIT mkdocs-git-revision-date-localized-plugin Mkdocs plugin that enables displaying the localized date of the last git modification of a markdown file. <code>&gt;=1.2</code> <code>1.4.7</code> MIT mkdocs-llmstxt MkDocs plugin to generate an /llms.txt file. <code>&gt;=0.2</code> <code>0.3.1</code> ISC mkdocs-material Documentation that simply works <code>&gt;=9.5</code> <code>9.6.18+insiders.4.53.17</code> MIT mkdocs-material-extensions Extension pack for Python Markdown and MkDocs Material. <code>~=1.3</code> <code>1.3.1</code> MIT mkdocs-minify-plugin An MkDocs plugin to minify HTML, JS or CSS files prior to being written to disk <code>&gt;=0.8</code> <code>0.8.0</code> MIT mkdocs-section-index MkDocs plugin to allow clickable sections that lead to an index page <code>&gt;=0.3</code> <code>0.3.10</code> MIT mkdocstrings Automatic documentation from sources, for MkDocs. <code>&gt;=0.29</code> <code>0.30.0</code> ISC mkdocstrings-python A Python handler for mkdocstrings. <code>&gt;=1.16.2</code> <code>1.18.2.1.12.1</code> ISC more-itertools More routines for operating on iterables, beyond itertools <code>10.8.0</code> MIT mypy Optional static typing for Python <code>&gt;=1.10</code> <code>1.18.2</code> MIT mypy_extensions Type system extensions for programs checked with the mypy type checker. <code>&gt;=1.0.0</code> <code>1.1.0</code> MIT nh3 Python binding to Ammonia HTML sanitizer Rust crate <code>&gt;=0.2.14</code> <code>0.3.0</code> MIT packaging Core utilities for Python packages <code>&gt;=20</code> <code>25.0</code> Apache Software License + BSD License paginate Divides large result sets into pages for easier browsing <code>~=0.5</code> <code>0.5.7</code> MIT pathspec Utility library for gitignore style pattern matching of file paths. <code>&gt;=0.9.0</code> <code>0.12.1</code> Mozilla Public License 2.0 (MPL 2.0) platformdirs A small Python package for determining appropriate platform-specific dirs, e.g. a <code>user data dir</code>. <code>&gt;=4.4</code> <code>4.4.0</code> MIT pluggy plugin and hook calling mechanisms for python <code>&gt;=1.5, &lt;2</code> <code>1.6.0</code> MIT ptyprocess Run a subprocess in a pseudo terminal <code>~=0.6</code> <code>0.7.0</code> ISC License (ISCL) pycparser C parser in Python <code>2.23</code> BSD-3-Clause Pygments Pygments is a syntax highlighting package written in Python. <code>&gt;=2.7.2</code> <code>2.19.2</code> BSD-2-Clause pymdown-extensions Extension pack for Python Markdown. <code>~=10.2</code> <code>10.16.1</code> MIT pyproject_hooks Wrappers to call pyproject.toml-based build backend hooks. <code>1.2.0</code> MIT License pytest pytest: simple powerful testing with Python <code>&gt;=8.2</code> <code>8.4.2</code> MIT pytest-cov Pytest plugin for measuring coverage. <code>&gt;=5.0</code> <code>7.0.0</code> MIT pytest-randomly Pytest plugin to randomly order tests and control random.seed. <code>&gt;=3.15</code> <code>4.0.1</code> MIT pytest-xdist pytest xdist plugin for distributed testing, most importantly across multiple CPUs <code>&gt;=3.6</code> <code>3.8.0</code> MIT python-dateutil Extensions to the standard Python datetime module <code>&gt;=2.8.1</code> <code>2.9.0.post0</code> BSD License + Apache Software License pytz World timezone definitions, modern and historical <code>&gt;=2025.1</code> <code>2025.2</code> MIT PyYAML YAML parser and emitter for Python <code>&gt;=5.1</code> <code>6.0.2</code> MIT pyyaml_env_tag A custom YAML tag for referencing environment variables in YAML files. <code>&gt;=0.1</code> <code>1.1</code> MIT readme_renderer readme_renderer is a library for rendering readme descriptions for Warehouse <code>&gt;=35.0</code> <code>44.0</code> Apache License, Version 2.0 requests Python HTTP for Humans. <code>&gt;=2.20</code> <code>2.32.5</code> Apache-2.0 requests-toolbelt A utility belt for advanced users of python-requests <code>&gt;=0.8.0, !=0.9.0</code> <code>1.0.0</code> Apache 2.0 rfc3986 Validating URI References per RFC 3986 <code>&gt;=1.4.0</code> <code>2.0.0</code> Apache 2.0 rich Render rich text, tables, progress bars, syntax highlighting, markdown and more to the terminal <code>&gt;=12.0.0</code> <code>14.1.0</code> MIT ruff An extremely fast Python linter and code formatter, written in Rust. <code>&gt;=0.4</code> <code>0.13.1</code> MIT License SecretStorage Python bindings to FreeDesktop.org Secret Service API <code>&gt;=3.2</code> <code>3.4.0</code> BSD-3-Clause semver Python helper for Semantic Versioning (https://semver.org) <code>&gt;=3.0</code> <code>3.0.4</code> BSD License six Python 2 and 3 compatibility utilities <code>&gt;=1.5</code> <code>1.17.0</code> MIT smmap A pure Python implementation of a sliding window memory map manager <code>&gt;=3.0.1, &lt;6</code> <code>5.0.2</code> BSD-3-Clause soupsieve A modern CSS selector implementation for Beautiful Soup. <code>&gt;1.2</code> <code>2.8</code> MIT twine Collection of utilities for publishing packages on PyPI <code>&gt;=5.1</code> <code>6.2.0</code> Apache-2.0 type-lens type-lens is a Python template project designed to simplify the setup of a new project. <code>&gt;=0.2.5</code> <code>0.2.5</code> MIT types-Markdown Typing stubs for Markdown <code>&gt;=3.6</code> <code>3.9.0.20250906</code> Apache-2.0 types-PyYAML Typing stubs for PyYAML <code>&gt;=6.0</code> <code>6.0.12.20250915</code> Apache-2.0 typing_extensions Backported and Experimental Type Hints for Python 3.9+ <code>&gt;=4.9</code> <code>4.15.0</code> PSF-2.0 urllib3 HTTP library with thread-safe connection pooling, file post, and more. <code>&gt;=1.26.0</code> <code>2.5.0</code> MIT watchdog Filesystem events monitoring <code>&gt;=2.0</code> <code>6.0.0</code> Apache-2.0 wcwidth Measures the displayed width of unicode strings in a terminal <code>&gt;=0.2.13</code> <code>0.2.13</code> MIT yore Manage legacy code with comments. <code>&gt;=0.3.3</code> <code>0.4.5</code> ISC <p>More credits from the author</p>"},{"location":"license/","title":"License","text":"<pre><code>ISC License\n\nCopyright (c) 2020, Timoth\u00e9e Mazzucotelli\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted, provided that the above\ncopyright notice and this permission notice appear in all copies.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\nWITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\nMERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\nANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\nWHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\nACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\nOR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n</code></pre>"},{"location":"usage/","title":"Usage","text":""},{"location":"usage/#importing-classes","title":"Importing classes","text":"<p>You can directly import the following classes from <code>dependenpy</code>: <code>DSM</code>, <code>Package</code>, <code>Module</code>, <code>Dependency</code>, <code>Matrix</code> and <code>TreeMap</code>.</p> <p>If you need to import other classes, please take a look at the structure of the code.</p> <p>Example:</p> <pre><code>from dependenpy import DSM, Matrix\n</code></pre>"},{"location":"usage/#creation-of-objects","title":"Creation of objects","text":"<p>For basic usage, you only have to instantiate a <code>DSM</code> object, and sometimes <code>Matrix</code> and <code>TreeMap</code>. But if you need to do more complicated stuff, you might also want to build instances of <code>Package</code>, <code>Module</code> or <code>Dependency</code>.</p>"},{"location":"usage/#create-a-dsm","title":"Create a DSM","text":"<p>To create a <code>DSM</code> object, just pass it a list of packages that can be either found on the disk (absolute or relative paths), or in the Python path (like in <code>sys.path</code>).</p> <pre><code>from dependenpy import DSM\n\ndjango = DSM(\"django\")\nflask = DSM(\"flask\")\nboth = DSM(\"django\", \"flask\")\n</code></pre> <p>Three keyword arguments can be given to <code>DSM</code>:</p> <ul> <li><code>build_tree</code>: Boolean</li> <li><code>build_dependencies</code>: Boolean</li> <li><code>enforce_init</code>: Boolean</li> </ul> <p>The three of them defaults to true.</p> <p>Turning <code>build_tree</code> to false will delay the build of the Python package tree (the exploration of files on the file system). You can later call <code>dsm.build_tree()</code> to build the tree.</p> <p>Turning <code>build_dependencies</code> to false will delay the build of the dependencies (the parsing of the source code to determine the inter-dependencies). You can later call <code>dsm.build_dependencies()</code> to build the dependencies. Note that you won't be able to build the dependencies before the tree has been built.</p> <p>Using true for both <code>build_tree</code> and <code>build_dependencies</code> is recommended since it is done pretty quickly, even for big projects like Django.</p> <p>Turning <code>enforce_init</code> to false will make the exploration of sub-directories complete: by default, a sub-directory is not explored if it does not contain an <code>__init__.py</code> file. It makes the building of the tree faster. But in some cases, you might want to still explore the sub-directory even without <code>__init__.py</code>. In that case, use <code>enforce_init=False</code>. Note that depending on the tree, the build might take longer.</p>"},{"location":"usage/#create-a-package","title":"Create a Package","text":"<p>To create a <code>Package</code> object, initialize it with a name and a path. These two arguments are the only one required. Name should be the name of the Python package (the name of the directory), and path should be the path to the directory on the file system.</p> <p>Example:</p> <pre><code>from dependenpy import Package\n\nabsolute_package = Package(\"django\", \"/my/virtualenv/lib/python3.5/site-packages/django\")\nrelative_package = Package(\"program\", \"src/program\")\n</code></pre> <p>Additionally, you can pass 6 more keyword arguments: the same three from <code>DSM</code> (<code>build_tree</code>, <code>build_dependencies</code> and <code>enforce_init</code>), and the three following:</p> <ul> <li><code>dsm</code>: parent DSM (instance of DSM).</li> <li><code>package</code>: parent package (instance of Package).</li> <li><code>limit_to</code>: list of strings to limit the exploration to a subset of   directories.</li> </ul> <p>These three arguments default to <code>None</code>. Both <code>dsm</code> and <code>package</code> arguments are useful to build a tree.</p> <p>Argument <code>limit_to</code> can be used this way:</p> <pre><code>from dependenpy import Package\n\ndjango_auth = Package(\"django\", \"path/to/django\", limit_to=[\"contrib.auth\"])\n</code></pre> <p>Of course, you could also have build a the <code>django_auth</code> Package by directly specify the name and path of the sub-directory, but using limit_to allows you to build the full tree, starting at the root (Django's directory).</p> <pre><code>from dependenpy import Package\n\ndjango_auth = Package(\"auth\", \"path/to/django/contrib/auth\")\n</code></pre>"},{"location":"usage/#create-a-module","title":"Create a Module","text":"<p>To create a <code>Module</code> object, initialize it with a name and a path. These two arguments are the only one required. Name should be the name of the Python module (the file without the <code>.py</code> extension), and path should be the path to the file on the file system.</p> <p>As for <code>Package</code>, <code>dsm</code> and <code>package</code> arguments can be passed when creating a module.</p> <p>Example:</p> <pre><code>from dependenpy import Module\n\ndsm_module = Module(\"dsm\", \"path/to/dependenpy/dsm.py\")\n</code></pre>"},{"location":"usage/#create-a-dependency","title":"Create a Dependency","text":"<p>A dependency is a simple object that require:</p> <ul> <li><code>source</code>: the <code>Module</code> instance importing the item,</li> <li><code>lineno</code>: the line number at which the import occurred,</li> <li><code>target</code>: the <code>Package</code> or <code>Module</code> instance from which the item is imported</li> <li>and an optional <code>what</code> argument which defaults to None: the name of the   imported item.</li> </ul>"},{"location":"usage/#create-a-matrix","title":"Create a Matrix","text":"<p>From an instance of <code>DSM</code> or <code>Package</code> called <code>node</code>:</p> <pre><code>matrix = node.as_matrix(depth=2)\n</code></pre> <p>From a list of nodes (DSMs, packages or modules):</p> <pre><code>matrix = Matrix(*node_list, depth=2)\n</code></pre> <p>An instance of <code>Matrix</code> has a <code>data</code> attribute, which is a two-dimensions array of integers, and a <code>keys</code> attribute which is the list of names, in the same order as rows in data.</p>"},{"location":"usage/#create-a-treemap","title":"Create a TreeMap","text":"<p>From an instance of <code>DSM</code> or <code>Package</code> called <code>node</code>:</p> <pre><code>treemap = node.as_treemap(depth=2)\n</code></pre> <p>From a list of nodes (DSMs, packages or modules):</p> <pre><code>matrix = TreeMap(*node_list, depth=2)\n</code></pre> <p>An instance of <code>TreeMap</code> has a <code>data</code> attribute, which is a two-dimensions array of integers or treemaps, a <code>keys</code> attribute which is the list of names in the same order as rows in data, and a <code>value</code> attribute which is the total number of dependencies in the treemap.</p>"},{"location":"usage/#create-a-graph","title":"Create a Graph","text":"<p>From an instance of <code>DSM</code> or <code>Package</code> called <code>node</code>:</p> <pre><code>graph = node.as_graph(depth=2)\n</code></pre> <p>From a list of nodes (DSMs, packages or modules):</p> <pre><code>graph = Graph(*node_list, depth=2)\n</code></pre> <p>An instance of <code>Graph</code> has a <code>vertices</code> attribute, which is a list of <code>Vertex</code> instances, and a <code>edges</code> attribute which is list of <code>Edge</code> instances. See the documentation of <code>Vertex</code> and <code>Edge</code> for more information.</p>"},{"location":"usage/#accessing-elements","title":"Accessing elements","text":"<p>Accessing elements in a DSM or a Package is very easy. Just like for a dictionary, you can use the <code>[]</code> notation to search for a sub-package or a sub-module. You can also use the <code>get</code> method, which is equivalent to the brackets accessor, but will return <code>None</code> if the element is not found whereas brackets accessor will raise a <code>KeyError</code>.</p> <p>Example:</p> <pre><code>from dependenpy import DSM\n\ndsm = DSM(\"django\")  # full DSM object, containing Django\ndjango = dsm[\"django\"]  # Django Package object\n</code></pre> <p>You can use dots in the element name to go further in just one instruction:</p> <pre><code>django_auth = django[\"contrib.auth\"]\ndjango_forms_models = dsm.get(\"django.forms.models\")\n</code></pre> <p>Of course, accesses can be chained:</p> <pre><code>django_db_models_utils = dsm[\"django\"].get(\"db\")[\"models\"][\"utils\"]\n</code></pre>"},{"location":"usage/#printing-contents","title":"Printing contents","text":"<p>Contents of DSMs, packages, modules, matrices, treemaps and graphs can be printed with their <code>print</code> method. The contents printed are the dependencies. With some exception, each one of them can output contents in three different formats:</p> <ul> <li>text (by default)</li> <li>CSV</li> <li>JSON</li> </ul> <p>(Currently, treemaps are not implemented, and graphs can only be printed in JSON or CSV.)</p> <p>To choose one of these format, just pass the <code>format</code> argument, which accepts values <code>'text'</code>, <code>'csv'</code> and <code>'json'</code>. Please note that these values can be replaced by constants imported from <code>dependenpy.helpers</code> module:</p> <pre><code>from dependenpy import DSM\nfrom dependenpy.helpers import TEXT, CSV, JSON\n\ndsm = DSM(\"django\")\ndsm.print(format=JSON)\n</code></pre> <p>Depending on the chosen format, additional keyword arguments can be passed to the print method:</p> <ul> <li>text format: <code>indent</code>, indentation value (integer)</li> <li>CSV format: <code>header</code>, True or False, to display the headers (columns names)</li> <li>JSON format: every arguments accepted by <code>json.dumps</code>, and in the case   of a <code>Module</code> instance, <code>absolute</code> Boolean to switch between output   of absolute and relative paths.</li> </ul> <p>For <code>DSM</code> and <code>Package</code> instances, shortcuts to print a matrix, a treemap or a graph are available with <code>print_matrix</code>, <code>print_treemap</code> and <code>print_graph</code> methods. These methods will first create the related object and then call the object's own <code>print</code> method.</p>"},{"location":"reference/api/","title":"API reference","text":""},{"location":"reference/api/#dependenpy","title":"dependenpy","text":"<p>Dependenpy package.</p> <p>Show the inter-dependencies between modules of Python packages.</p> <p>With dependenpy you will be able to analyze the internal dependencies in your Python code, i.e. which module needs which other module. You will then be able to build a dependency matrix and use it for other purposes.</p> <p>If you read this message, you probably want to learn about the library and not the command-line tool: please refer to the README.md included in this package to get the link to the official documentation.</p> <p>Modules:</p> <ul> <li> <code>cli</code>           \u2013            <p>Deprecated. Import from <code>dependenpy</code> directly.</p> </li> <li> <code>debug</code>           \u2013            <p>Deprecated. Import from <code>dependenpy</code> directly.</p> </li> <li> <code>dsm</code>           \u2013            <p>Deprecated. Import from <code>dependenpy</code> directly.</p> </li> <li> <code>finder</code>           \u2013            <p>Deprecated. Import from <code>dependenpy</code> directly.</p> </li> <li> <code>helpers</code>           \u2013            <p>Deprecated. Import from <code>dependenpy</code> directly.</p> </li> <li> <code>node</code>           \u2013            <p>Deprecated. Import from <code>dependenpy</code> directly.</p> </li> <li> <code>plugins</code>           \u2013            <p>Deprecated. Import from <code>dependenpy</code> directly.</p> </li> <li> <code>structures</code>           \u2013            <p>Deprecated. Import from <code>dependenpy</code> directly.</p> </li> </ul> <p>Classes:</p> <ul> <li> <code>DSM</code>           \u2013            <p>DSM-capable class.</p> </li> <li> <code>Dependency</code>           \u2013            <p>Dependency class.</p> </li> <li> <code>Edge</code>           \u2013            <p>Edge class. Used in Graph class.</p> </li> <li> <code>Finder</code>           \u2013            <p>Main package finder class.</p> </li> <li> <code>Graph</code>           \u2013            <p>Graph class.</p> </li> <li> <code>InstalledPackageFinder</code>           \u2013            <p>Finder to find installed Python packages using importlib.</p> </li> <li> <code>InternalDependencies</code>           \u2013            <p>Dependenpy provider for Archan.</p> </li> <li> <code>LeafNode</code>           \u2013            <p>Shared code between Package and Module.</p> </li> <li> <code>LocalPackageFinder</code>           \u2013            <p>Finder to find local packages (directories on the disk).</p> </li> <li> <code>Matrix</code>           \u2013            <p>Matrix class.</p> </li> <li> <code>Module</code>           \u2013            <p>Module class.</p> </li> <li> <code>NodeMixin</code>           \u2013            <p>Shared code between DSM, Package and Module.</p> </li> <li> <code>Package</code>           \u2013            <p>Package class.</p> </li> <li> <code>PackageFinder</code>           \u2013            <p>Abstract package finder class.</p> </li> <li> <code>PackageSpec</code>           \u2013            <p>Holder for a package specification (given as argument to DSM).</p> </li> <li> <code>PrintMixin</code>           \u2013            <p>Print mixin class.</p> </li> <li> <code>RootNode</code>           \u2013            <p>Shared code between DSM and Package.</p> </li> <li> <code>TreeMap</code>           \u2013            <p>TreeMap class.</p> </li> <li> <code>Vertex</code>           \u2013            <p>Vertex class. Used in Graph class.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>get_parser</code>             \u2013              <p>Return the CLI argument parser.</p> </li> <li> <code>guess_depth</code>             \u2013              <p>Guess the optimal depth to use for the given list of arguments.</p> </li> <li> <code>main</code>             \u2013              <p>Run the main program.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>CSV</code>           \u2013            <p>CSV format.</p> </li> <li> <code>FORMAT</code>           \u2013            <p>Supported output formats.</p> </li> <li> <code>JSON</code>           \u2013            <p>JSON format.</p> </li> <li> <code>TEXT</code>           \u2013            <p>Plain text format.</p> </li> </ul>"},{"location":"reference/api/#dependenpy.CSV","title":"CSV  <code>module-attribute</code>","text":"<pre><code>CSV = 'csv'\n</code></pre> <p>CSV format.</p> Used by: <ul> <li> <code></code>\u00a0dependenpy <code></code>\u00a0FORMAT </li> </ul>"},{"location":"reference/api/#dependenpy.FORMAT","title":"FORMAT  <code>module-attribute</code>","text":"<pre><code>FORMAT = (CSV, JSON, TEXT)\n</code></pre> <p>Supported output formats.</p>"},{"location":"reference/api/#dependenpy.JSON","title":"JSON  <code>module-attribute</code>","text":"<pre><code>JSON = 'json'\n</code></pre> <p>JSON format.</p> Used by: <ul> <li> <code></code>\u00a0dependenpy <code></code>\u00a0FORMAT </li> </ul>"},{"location":"reference/api/#dependenpy.TEXT","title":"TEXT  <code>module-attribute</code>","text":"<pre><code>TEXT = 'text'\n</code></pre> <p>Plain text format.</p> Used by: <ul> <li> <code></code>\u00a0dependenpy <ul> <li> <code></code>\u00a0FORMAT </li> <li> <code></code>\u00a0DSM <code></code>\u00a0print </li> <li> <code></code>\u00a0Graph <code></code>\u00a0print </li> <li> <code></code>\u00a0Matrix <code></code>\u00a0print </li> <li> <code></code>\u00a0Module <code></code>\u00a0print </li> <li> <code></code>\u00a0Package <code></code>\u00a0print </li> <li> <code></code>\u00a0PrintMixin <code></code>\u00a0print </li> <li> <code></code>\u00a0TreeMap <code></code>\u00a0print </li> </ul> </li> </ul>"},{"location":"reference/api/#dependenpy.DSM","title":"DSM","text":"<pre><code>DSM(\n    *packages: str,\n    build_tree: bool = True,\n    build_dependencies: bool = True,\n    enforce_init: bool = True,\n)\n</code></pre> <p>               Bases: <code>RootNode</code>, <code>NodeMixin</code>, <code>PrintMixin</code></p> <p>DSM-capable class.</p> <p>Technically speaking, a DSM instance is not a real DSM but more a tree representing the Python packages structure. However, it has the necessary methods to build a real DSM in the form of a square matrix, a dictionary or a tree-map.</p> <p>Parameters:</p> <ul> <li> <code>*packages</code>               (<code>str</code>, default:                   <code>()</code> )           \u2013            <p>List of packages to search for.</p> </li> <li> <code>build_tree</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Auto-build the tree or not.</p> </li> <li> <code>build_dependencies</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Auto-build the dependencies or not.</p> </li> <li> <code>enforce_init</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, only treat directories if they contain an <code>__init__.py</code> file.</p> </li> </ul> Used by: <ul> <li> <code></code>\u00a0dependenpy <ul> <li> <code></code>\u00a0Graph </li> <li> <code></code>\u00a0Matrix </li> <li> <code></code>\u00a0Module </li> <li> <code></code>\u00a0Package </li> </ul> </li> </ul> <p>Methods:</p> <ul> <li> <code>__bool__</code>             \u2013              <p>Node as Boolean.</p> </li> <li> <code>__contains__</code>             \u2013              <p>Get result of _contains, cache it and return it.</p> </li> <li> <code>__getitem__</code>             \u2013              <p>Return the corresponding Package or Module object.</p> </li> <li> <code>as_dict</code>             \u2013              <p>Return the dependencies as a dictionary.</p> </li> <li> <code>as_graph</code>             \u2013              <p>Create a graph with self as node, cache it, return it.</p> </li> <li> <code>as_matrix</code>             \u2013              <p>Create a matrix with self as node, cache it, return it.</p> </li> <li> <code>as_treemap</code>             \u2013              <p>Return the dependencies as a TreeMap.</p> </li> <li> <code>build_dependencies</code>             \u2013              <p>Recursively build the dependencies for sub-modules and sub-packages.</p> </li> <li> <code>build_tree</code>             \u2013              <p>Build the Python packages tree.</p> </li> <li> <code>get</code>             \u2013              <p>Get item through <code>__getitem__</code> and cache the result.</p> </li> <li> <code>get_target</code>             \u2013              <p>Get the result of _get_target, cache it and return it.</p> </li> <li> <code>print</code>             \u2013              <p>Print the object in a file or on standard output by default.</p> </li> <li> <code>print_graph</code>             \u2013              <p>Print the graph for self's nodes.</p> </li> <li> <code>print_matrix</code>             \u2013              <p>Print the matrix for self's nodes.</p> </li> <li> <code>print_treemap</code>             \u2013              <p>Print the matrix for self's nodes.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>base_packages</code>               (<code>tuple[str, ...]</code>)           \u2013            <p>Packages initially specified.</p> </li> <li> <code>empty</code>               (<code>bool</code>)           \u2013            <p>Whether the node has neither modules nor packages.</p> </li> <li> <code>enforce_init</code>               (<code>bool</code>)           \u2013            <p>Whether to enforce the presence of <code>__init__.py</code> files.</p> </li> <li> <code>finder</code>               (<code>Finder</code>)           \u2013            <p>Finder instance for locating packages and modules.</p> </li> <li> <code>isdsm</code>               (<code>bool</code>)           \u2013            <p>Inherited from NodeMixin. Always True.</p> </li> <li> <code>ismodule</code>               (<code>bool</code>)           \u2013            <p>Property to check if object is instance of Module.</p> </li> <li> <code>ispackage</code>               (<code>bool</code>)           \u2013            <p>Property to check if object is instance of Package.</p> </li> <li> <code>modules</code>               (<code>list[Module]</code>)           \u2013            <p>List of modules contained in the node.</p> </li> <li> <code>not_found</code>               (<code>list[str]</code>)           \u2013            <p>List of packages that were not found.</p> </li> <li> <code>packages</code>               (<code>list[Package]</code>)           \u2013            <p>List of packages contained in the node.</p> </li> <li> <code>specs</code>               (<code>list[PackageSpec]</code>)           \u2013            <p>List of package specifications found.</p> </li> <li> <code>submodules</code>               (<code>list[Module]</code>)           \u2013            <p>Property to return all sub-modules of the node, recursively.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/dsm.py</code> <pre><code>def __init__(\n    self,\n    *packages: str,\n    build_tree: bool = True,\n    build_dependencies: bool = True,\n    enforce_init: bool = True,\n):\n    \"\"\"Initialization method.\n\n    Parameters:\n        *packages: List of packages to search for.\n        build_tree: Auto-build the tree or not.\n        build_dependencies: Auto-build the dependencies or not.\n        enforce_init: If True, only treat directories if they contain an `__init__.py` file.\n    \"\"\"\n    self.base_packages: tuple[str, ...] = packages\n    \"\"\"Packages initially specified.\"\"\"\n    self.finder: Finder = Finder()\n    \"\"\"Finder instance for locating packages and modules.\"\"\"\n    self.specs: list[PackageSpec] = []\n    \"\"\"List of package specifications found.\"\"\"\n    self.not_found: list[str] = []\n    \"\"\"List of packages that were not found.\"\"\"\n    self.enforce_init: bool = enforce_init\n    \"\"\"Whether to enforce the presence of `__init__.py` files.\"\"\"\n\n    specs = []\n    for package in packages:\n        spec = self.finder.find(package, enforce_init=enforce_init)\n        if spec:\n            specs.append(spec)\n        else:\n            self.not_found.append(package)\n\n    if not specs:\n        print(\"** dependenpy: DSM empty.\", file=sys.stderr)  # noqa: T201\n\n    self.specs = PackageSpec.combine(specs)\n\n    for module in self.not_found:\n        print(f\"** dependenpy: Not found: {module}.\", file=sys.stderr)  # noqa: T201\n\n    super().__init__(build_tree)\n\n    if build_tree and build_dependencies:\n        self.build_dependencies()\n</code></pre>"},{"location":"reference/api/#dependenpy.DSM.base_packages","title":"base_packages  <code>instance-attribute</code>","text":"<pre><code>base_packages: tuple[str, ...] = packages\n</code></pre> <p>Packages initially specified.</p>"},{"location":"reference/api/#dependenpy.DSM.empty","title":"empty  <code>property</code>","text":"<pre><code>empty: bool\n</code></pre> <p>Whether the node has neither modules nor packages.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if empty, False otherwise.</p> </li> </ul>"},{"location":"reference/api/#dependenpy.DSM.enforce_init","title":"enforce_init  <code>instance-attribute</code>","text":"<pre><code>enforce_init: bool = enforce_init\n</code></pre> <p>Whether to enforce the presence of <code>__init__.py</code> files.</p>"},{"location":"reference/api/#dependenpy.DSM.finder","title":"finder  <code>instance-attribute</code>","text":"<pre><code>finder: Finder = Finder()\n</code></pre> <p>Finder instance for locating packages and modules.</p>"},{"location":"reference/api/#dependenpy.DSM.isdsm","title":"isdsm  <code>property</code>","text":"<pre><code>isdsm: bool\n</code></pre> <p>Inherited from NodeMixin. Always True.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Whether this object is a DSM.</p> </li> </ul>"},{"location":"reference/api/#dependenpy.DSM.ismodule","title":"ismodule  <code>property</code>","text":"<pre><code>ismodule: bool\n</code></pre> <p>Property to check if object is instance of Module.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Whether this object is a module.</p> </li> </ul>"},{"location":"reference/api/#dependenpy.DSM.ispackage","title":"ispackage  <code>property</code>","text":"<pre><code>ispackage: bool\n</code></pre> <p>Property to check if object is instance of Package.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Whether this object is a package.</p> </li> </ul>"},{"location":"reference/api/#dependenpy.DSM.modules","title":"modules  <code>instance-attribute</code>","text":"<pre><code>modules: list[Module] = []\n</code></pre> <p>List of modules contained in the node.</p>"},{"location":"reference/api/#dependenpy.DSM.not_found","title":"not_found  <code>instance-attribute</code>","text":"<pre><code>not_found: list[str] = []\n</code></pre> <p>List of packages that were not found.</p>"},{"location":"reference/api/#dependenpy.DSM.packages","title":"packages  <code>instance-attribute</code>","text":"<pre><code>packages: list[Package] = []\n</code></pre> <p>List of packages contained in the node.</p>"},{"location":"reference/api/#dependenpy.DSM.specs","title":"specs  <code>instance-attribute</code>","text":"<pre><code>specs: list[PackageSpec] = combine(specs)\n</code></pre> <p>List of package specifications found.</p>"},{"location":"reference/api/#dependenpy.DSM.submodules","title":"submodules  <code>property</code>","text":"<pre><code>submodules: list[Module]\n</code></pre> <p>Property to return all sub-modules of the node, recursively.</p> <p>Returns:</p> <ul> <li> <code>list[Module]</code>           \u2013            <p>The sub-modules.</p> </li> </ul>"},{"location":"reference/api/#dependenpy.DSM.__bool__","title":"__bool__","text":"<pre><code>__bool__() -&gt; bool\n</code></pre> <p>Node as Boolean.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Result of node.empty.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/node.py</code> <pre><code>def __bool__(self) -&gt; bool:\n    \"\"\"Node as Boolean.\n\n    Returns:\n        Result of node.empty.\n    \"\"\"\n    return bool(self.modules or self.packages)\n</code></pre>"},{"location":"reference/api/#dependenpy.DSM.__contains__","title":"__contains__","text":"<pre><code>__contains__(item: Package | Module) -&gt; bool\n</code></pre> <p>Get result of _contains, cache it and return it.</p> <p>Parameters:</p> <ul> <li> <code>item</code>               (<code>Package | Module</code>)           \u2013            <p>A package or module.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if self contains item, False otherwise.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/node.py</code> <pre><code>def __contains__(self, item: Package | Module) -&gt; bool:\n    \"\"\"Get result of _contains, cache it and return it.\n\n    Parameters:\n        item: A package or module.\n\n    Returns:\n        True if self contains item, False otherwise.\n    \"\"\"\n    if item not in self._contains_cache:\n        self._contains_cache[item] = self._contains(item)\n    return self._contains_cache[item]\n</code></pre>"},{"location":"reference/api/#dependenpy.DSM.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(item: str) -&gt; Package | Module\n</code></pre> <p>Return the corresponding Package or Module object.</p> <p>Parameters:</p> <ul> <li> <code>item</code>               (<code>str</code>)           \u2013            <p>Name of the package/module, dot-separated.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>KeyError</code>             \u2013            <p>When the package or module cannot be found.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Package | Module</code>           \u2013            <p>The corresponding object.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/node.py</code> <pre><code>def __getitem__(self, item: str) -&gt; Package | Module:\n    \"\"\"Return the corresponding Package or Module object.\n\n    Parameters:\n        item: Name of the package/module, dot-separated.\n\n    Raises:\n        KeyError: When the package or module cannot be found.\n\n    Returns:\n        The corresponding object.\n    \"\"\"\n    depth = item.count(\".\") + 1\n    parts = item.split(\".\", 1)\n    for module in self.modules:\n        if parts[0] == module.name and depth == 1:\n            return module\n    for package in self.packages:\n        if parts[0] == package.name:\n            if depth == 1:\n                return package\n            obj = package.get(parts[1])\n            if obj:\n                return obj\n    raise KeyError(item)\n</code></pre>"},{"location":"reference/api/#dependenpy.DSM.as_dict","title":"as_dict","text":"<pre><code>as_dict() -&gt; dict\n</code></pre> <p>Return the dependencies as a dictionary.</p> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>Dictionary of dependencies.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/node.py</code> <pre><code>def as_dict(self) -&gt; dict:\n    \"\"\"Return the dependencies as a dictionary.\n\n    Returns:\n        Dictionary of dependencies.\n    \"\"\"\n    return {\n        \"name\": str(self),\n        \"modules\": [module.as_dict() for module in self.modules],\n        \"packages\": [package.as_dict() for package in self.packages],\n    }\n</code></pre>"},{"location":"reference/api/#dependenpy.DSM.as_graph","title":"as_graph","text":"<pre><code>as_graph(depth: int = 0) -&gt; Graph\n</code></pre> <p>Create a graph with self as node, cache it, return it.</p> <p>Parameters:</p> <ul> <li> <code>depth</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Depth of the graph.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Graph</code>           \u2013            <p>An instance of Graph.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/node.py</code> <pre><code>def as_graph(self, depth: int = 0) -&gt; Graph:\n    \"\"\"Create a graph with self as node, cache it, return it.\n\n    Parameters:\n        depth: Depth of the graph.\n\n    Returns:\n        An instance of Graph.\n    \"\"\"\n    if depth not in self._graph_cache:\n        self._graph_cache[depth] = Graph(self, depth=depth)  # type: ignore[arg-type]\n    return self._graph_cache[depth]\n</code></pre>"},{"location":"reference/api/#dependenpy.DSM.as_matrix","title":"as_matrix","text":"<pre><code>as_matrix(depth: int = 0) -&gt; Matrix\n</code></pre> <p>Create a matrix with self as node, cache it, return it.</p> <p>Parameters:</p> <ul> <li> <code>depth</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Depth of the matrix.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Matrix</code>           \u2013            <p>An instance of Matrix.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/node.py</code> <pre><code>def as_matrix(self, depth: int = 0) -&gt; Matrix:\n    \"\"\"Create a matrix with self as node, cache it, return it.\n\n    Parameters:\n        depth: Depth of the matrix.\n\n    Returns:\n        An instance of Matrix.\n    \"\"\"\n    if depth not in self._matrix_cache:\n        self._matrix_cache[depth] = Matrix(self, depth=depth)  # type: ignore[arg-type]\n    return self._matrix_cache[depth]\n</code></pre>"},{"location":"reference/api/#dependenpy.DSM.as_treemap","title":"as_treemap","text":"<pre><code>as_treemap() -&gt; TreeMap\n</code></pre> <p>Return the dependencies as a TreeMap.</p> <p>Returns:</p> <ul> <li> <code>TreeMap</code>           \u2013            <p>An instance of TreeMap.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/node.py</code> <pre><code>def as_treemap(self) -&gt; TreeMap:\n    \"\"\"Return the dependencies as a TreeMap.\n\n    Returns:\n        An instance of TreeMap.\n    \"\"\"\n    if not self._treemap_cache:\n        self._treemap_cache = TreeMap(self)\n    return self._treemap_cache\n</code></pre>"},{"location":"reference/api/#dependenpy.DSM.build_dependencies","title":"build_dependencies","text":"<pre><code>build_dependencies() -&gt; None\n</code></pre> <p>Recursively build the dependencies for sub-modules and sub-packages.</p> <p>Iterate on node's modules then packages and call their build_dependencies methods.</p> Source code in <code>src/dependenpy/_internal/node.py</code> <pre><code>def build_dependencies(self) -&gt; None:\n    \"\"\"Recursively build the dependencies for sub-modules and sub-packages.\n\n    Iterate on node's modules then packages and call their\n    build_dependencies methods.\n    \"\"\"\n    for module in self.modules:\n        module.build_dependencies()\n    for package in self.packages:\n        package.build_dependencies()\n</code></pre>"},{"location":"reference/api/#dependenpy.DSM.build_tree","title":"build_tree","text":"<pre><code>build_tree() -&gt; None\n</code></pre> <p>Build the Python packages tree.</p> Source code in <code>src/dependenpy/_internal/dsm.py</code> <pre><code>def build_tree(self) -&gt; None:\n    \"\"\"Build the Python packages tree.\"\"\"\n    for spec in self.specs:\n        if spec.ismodule:\n            self.modules.append(Module(spec.name, spec.path, dsm=self))\n        else:\n            self.packages.append(\n                Package(\n                    spec.name,\n                    spec.path,\n                    dsm=self,\n                    limit_to=spec.limit_to,\n                    build_tree=True,\n                    build_dependencies=False,\n                    enforce_init=self.enforce_init,\n                ),\n            )\n</code></pre>"},{"location":"reference/api/#dependenpy.DSM.get","title":"get","text":"<pre><code>get(item: str) -&gt; Package | Module\n</code></pre> <p>Get item through <code>__getitem__</code> and cache the result.</p> <p>Parameters:</p> <ul> <li> <code>item</code>               (<code>str</code>)           \u2013            <p>Name of package or module.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Package | Module</code>           \u2013            <p>The corresponding object.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/node.py</code> <pre><code>def get(self, item: str) -&gt; Package | Module:\n    \"\"\"Get item through `__getitem__` and cache the result.\n\n    Parameters:\n        item: Name of package or module.\n\n    Returns:\n        The corresponding object.\n    \"\"\"\n    if item not in self._item_cache:\n        try:\n            obj = self.__getitem__(item)\n        except KeyError:\n            obj = None\n        self._item_cache[item] = obj\n    return self._item_cache[item]\n</code></pre>"},{"location":"reference/api/#dependenpy.DSM.get_target","title":"get_target","text":"<pre><code>get_target(target: str) -&gt; Package | Module\n</code></pre> <p>Get the result of _get_target, cache it and return it.</p> <p>Parameters:</p> <ul> <li> <code>target</code>               (<code>str</code>)           \u2013            <p>Target to find.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Package | Module</code>           \u2013            <p>Package containing target or corresponding module.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/node.py</code> <pre><code>def get_target(self, target: str) -&gt; Package | Module:\n    \"\"\"Get the result of _get_target, cache it and return it.\n\n    Parameters:\n        target: Target to find.\n\n    Returns:\n        Package containing target or corresponding module.\n    \"\"\"\n    if target not in self._target_cache:\n        self._target_cache[target] = self._get_target(target)\n    return self._target_cache[target]\n</code></pre>"},{"location":"reference/api/#dependenpy.DSM.print","title":"print","text":"<pre><code>print(\n    format: str | None = TEXT,\n    output: IO = stdout,\n    **kwargs: Any,\n) -&gt; None\n</code></pre> <p>Print the object in a file or on standard output by default.</p> <p>Parameters:</p> <ul> <li> <code>format</code>               (<code>str | None</code>, default:                   <code>TEXT</code> )           \u2013            <p>Output format (csv, json or text).</p> </li> <li> <code>output</code>               (<code>IO</code>, default:                   <code>stdout</code> )           \u2013            <p>Descriptor to an opened file (default to standard output).</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional arguments.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/helpers.py</code> <pre><code>def print(self, format: str | None = TEXT, output: IO = sys.stdout, **kwargs: Any) -&gt; None:  # noqa: A002\n    \"\"\"Print the object in a file or on standard output by default.\n\n    Parameters:\n        format: Output format (csv, json or text).\n        output: Descriptor to an opened file (default to standard output).\n        **kwargs: Additional arguments.\n    \"\"\"\n    if format is None:\n        format = TEXT\n\n    if format != TEXT:\n        kwargs.pop(\"zero\", \"\")\n\n    if format == TEXT:\n        print(self._to_text(**kwargs), file=output)\n    elif format == CSV:\n        print(self._to_csv(**kwargs), file=output)\n    elif format == JSON:\n        print(self._to_json(**kwargs), file=output)\n</code></pre>"},{"location":"reference/api/#dependenpy.DSM.print_graph","title":"print_graph","text":"<pre><code>print_graph(\n    format: str | None = None,\n    output: IO = stdout,\n    depth: int = 0,\n    **kwargs: Any,\n) -&gt; None\n</code></pre> <p>Print the graph for self's nodes.</p> <p>Parameters:</p> <ul> <li> <code>format</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Output format (csv, json or text).</p> </li> <li> <code>output</code>               (<code>IO</code>, default:                   <code>stdout</code> )           \u2013            <p>File descriptor on which to write.</p> </li> <li> <code>depth</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Depth of the graph.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments passed to <code>graph.print</code>.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/node.py</code> <pre><code>def print_graph(\n    self,\n    format: str | None = None,  # noqa: A002\n    output: IO = sys.stdout,\n    depth: int = 0,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Print the graph for self's nodes.\n\n    Parameters:\n        format: Output format (csv, json or text).\n        output: File descriptor on which to write.\n        depth: Depth of the graph.\n        **kwargs: Additional keyword arguments passed to `graph.print`.\n    \"\"\"\n    graph = self.as_graph(depth=depth)\n    graph.print(format=format, output=output, **kwargs)\n</code></pre>"},{"location":"reference/api/#dependenpy.DSM.print_matrix","title":"print_matrix","text":"<pre><code>print_matrix(\n    format: str | None = None,\n    output: IO = stdout,\n    depth: int = 0,\n    **kwargs: Any,\n) -&gt; None\n</code></pre> <p>Print the matrix for self's nodes.</p> <p>Parameters:</p> <ul> <li> <code>format</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Output format (csv, json or text).</p> </li> <li> <code>output</code>               (<code>IO</code>, default:                   <code>stdout</code> )           \u2013            <p>File descriptor on which to write.</p> </li> <li> <code>depth</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Depth of the matrix.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments passed to <code>matrix.print</code>.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/node.py</code> <pre><code>def print_matrix(\n    self,\n    format: str | None = None,  # noqa: A002\n    output: IO = sys.stdout,\n    depth: int = 0,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Print the matrix for self's nodes.\n\n    Parameters:\n        format: Output format (csv, json or text).\n        output: File descriptor on which to write.\n        depth: Depth of the matrix.\n        **kwargs: Additional keyword arguments passed to `matrix.print`.\n    \"\"\"\n    matrix = self.as_matrix(depth=depth)\n    matrix.print(format=format, output=output, **kwargs)\n</code></pre>"},{"location":"reference/api/#dependenpy.DSM.print_treemap","title":"print_treemap","text":"<pre><code>print_treemap(\n    format: str | None = None,\n    output: IO = stdout,\n    **kwargs: Any,\n) -&gt; None\n</code></pre> <p>Print the matrix for self's nodes.</p> <p>Parameters:</p> <ul> <li> <code>format</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Output format (csv, json or text).</p> </li> <li> <code>output</code>               (<code>IO</code>, default:                   <code>stdout</code> )           \u2013            <p>File descriptor on which to write.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments passed to <code>treemap.print</code>.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/node.py</code> <pre><code>def print_treemap(self, format: str | None = None, output: IO = sys.stdout, **kwargs: Any) -&gt; None:  # noqa: A002\n    \"\"\"Print the matrix for self's nodes.\n\n    Parameters:\n        format: Output format (csv, json or text).\n        output: File descriptor on which to write.\n        **kwargs: Additional keyword arguments passed to `treemap.print`.\n    \"\"\"\n    treemap = self.as_treemap()\n    treemap.print(format=format, output=output, **kwargs)\n</code></pre>"},{"location":"reference/api/#dependenpy.Dependency","title":"Dependency","text":"<pre><code>Dependency(\n    source: Module,\n    lineno: int,\n    target: str | Module | Package,\n    what: str | None = None,\n)\n</code></pre> <p>Dependency class.</p> <p>Represent a dependency from a module to another.</p> <p>Parameters:</p> <ul> <li> <code>source</code>               (<code>Module</code>)           \u2013            <p>Source Module.</p> </li> <li> <code>lineno</code>               (<code>int</code>)           \u2013            <p>Number of line at which import statement occurs.</p> </li> <li> <code>target</code>               (<code>str | Module | Package</code>)           \u2013            <p>The target node.</p> </li> <li> <code>what</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>What is imported (optional).</p> </li> </ul> Returned by: <ul> <li> <code></code>\u00a0dependenpy <code></code>\u00a0Module <code></code>\u00a0dependencies </li> </ul> <p>Attributes:</p> <ul> <li> <code>external</code>               (<code>bool</code>)           \u2013            <p>Property to tell if the dependency's target is a valid node.</p> </li> <li> <code>lineno</code>           \u2013            <p>Line number of the import statement.</p> </li> <li> <code>source</code>           \u2013            <p>Source module.</p> </li> <li> <code>target</code>           \u2013            <p>Target module or package.</p> </li> <li> <code>what</code>           \u2013            <p>What is imported (optional).</p> </li> </ul> Source code in <code>src/dependenpy/_internal/dsm.py</code> <pre><code>def __init__(self, source: Module, lineno: int, target: str | Module | Package, what: str | None = None) -&gt; None:\n    \"\"\"Initialization method.\n\n    Parameters:\n        source: Source Module.\n        lineno: Number of line at which import statement occurs.\n        target: The target node.\n        what: What is imported (optional).\n    \"\"\"\n    self.source = source\n    \"\"\"Source module.\"\"\"\n    self.lineno = lineno\n    \"\"\"Line number of the import statement.\"\"\"\n    self.target = target\n    \"\"\"Target module or package.\"\"\"\n    self.what = what\n    \"\"\"What is imported (optional).\"\"\"\n</code></pre>"},{"location":"reference/api/#dependenpy.Dependency.external","title":"external  <code>property</code>","text":"<pre><code>external: bool\n</code></pre> <p>Property to tell if the dependency's target is a valid node.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Whether the dependency's target is a valid node.</p> </li> </ul>"},{"location":"reference/api/#dependenpy.Dependency.lineno","title":"lineno  <code>instance-attribute</code>","text":"<pre><code>lineno = lineno\n</code></pre> <p>Line number of the import statement.</p>"},{"location":"reference/api/#dependenpy.Dependency.source","title":"source  <code>instance-attribute</code>","text":"<pre><code>source = source\n</code></pre> <p>Source module.</p>"},{"location":"reference/api/#dependenpy.Dependency.target","title":"target  <code>instance-attribute</code>","text":"<pre><code>target = target\n</code></pre> <p>Target module or package.</p>"},{"location":"reference/api/#dependenpy.Dependency.what","title":"what  <code>instance-attribute</code>","text":"<pre><code>what = what\n</code></pre> <p>What is imported (optional).</p>"},{"location":"reference/api/#dependenpy.Edge","title":"Edge","text":"<pre><code>Edge(\n    vertex_out: Vertex, vertex_in: Vertex, weight: int = 1\n)\n</code></pre> <p>Edge class. Used in Graph class.</p> <p>Parameters:</p> <ul> <li> <code>vertex_out</code>               (<code>Vertex</code>)           \u2013            <p>source vertex (edge going out).</p> </li> <li> <code>vertex_in</code>               (<code>Vertex</code>)           \u2013            <p>target vertex (edge going in).</p> </li> <li> <code>weight</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>weight of the edge.</p> </li> </ul> Returned by: <ul> <li> <code></code>\u00a0dependenpy <code></code>\u00a0Vertex <ul> <li> <code></code>\u00a0edges_in </li> <li> <code></code>\u00a0edges_out </li> <li> <code></code>\u00a0connect_from </li> <li> <code></code>\u00a0connect_to </li> </ul> </li> </ul> <p>Methods:</p> <ul> <li> <code>go_from</code>             \u2013              <p>Tell the edge to go out from this vertex.</p> </li> <li> <code>go_in</code>             \u2013              <p>Tell the edge to go into this vertex.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>vertex_in</code>               (<code>Vertex | None</code>)           \u2013            <p>Incoming vertex.</p> </li> <li> <code>vertex_out</code>               (<code>Vertex | None</code>)           \u2013            <p>Outgoing vertex.</p> </li> <li> <code>weight</code>           \u2013            <p>Weight of the edge.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/structures.py</code> <pre><code>def __init__(self, vertex_out: Vertex, vertex_in: Vertex, weight: int = 1) -&gt; None:\n    \"\"\"Initialization method.\n\n    Parameters:\n        vertex_out (Vertex): source vertex (edge going out).\n        vertex_in (Vertex): target vertex (edge going in).\n        weight (int): weight of the edge.\n    \"\"\"\n    self.vertex_out: Vertex | None = None\n    \"\"\"Outgoing vertex.\"\"\"\n    self.vertex_in: Vertex | None = None\n    \"\"\"Incoming vertex.\"\"\"\n    self.weight = weight\n    \"\"\"Weight of the edge.\"\"\"\n    self.go_from(vertex_out)\n    self.go_in(vertex_in)\n</code></pre>"},{"location":"reference/api/#dependenpy.Edge.vertex_in","title":"vertex_in  <code>instance-attribute</code>","text":"<pre><code>vertex_in: Vertex | None = None\n</code></pre> <p>Incoming vertex.</p>"},{"location":"reference/api/#dependenpy.Edge.vertex_out","title":"vertex_out  <code>instance-attribute</code>","text":"<pre><code>vertex_out: Vertex | None = None\n</code></pre> <p>Outgoing vertex.</p>"},{"location":"reference/api/#dependenpy.Edge.weight","title":"weight  <code>instance-attribute</code>","text":"<pre><code>weight = weight\n</code></pre> <p>Weight of the edge.</p>"},{"location":"reference/api/#dependenpy.Edge.go_from","title":"go_from","text":"<pre><code>go_from(vertex: Vertex) -&gt; None\n</code></pre> <p>Tell the edge to go out from this vertex.</p> <p>Parameters:</p> <ul> <li> <code>vertex</code>               (<code>Vertex</code>)           \u2013            <p>vertex to go from.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/structures.py</code> <pre><code>def go_from(self, vertex: Vertex) -&gt; None:\n    \"\"\"Tell the edge to go out from this vertex.\n\n    Parameters:\n        vertex (Vertex): vertex to go from.\n    \"\"\"\n    if self.vertex_out:\n        self.vertex_out.edges_out.remove(self)\n    self.vertex_out = vertex\n    vertex.edges_out.add(self)\n</code></pre>"},{"location":"reference/api/#dependenpy.Edge.go_in","title":"go_in","text":"<pre><code>go_in(vertex: Vertex) -&gt; None\n</code></pre> <p>Tell the edge to go into this vertex.</p> <p>Parameters:</p> <ul> <li> <code>vertex</code>               (<code>Vertex</code>)           \u2013            <p>vertex to go into.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/structures.py</code> <pre><code>def go_in(self, vertex: Vertex) -&gt; None:\n    \"\"\"Tell the edge to go into this vertex.\n\n    Parameters:\n        vertex (Vertex): vertex to go into.\n    \"\"\"\n    if self.vertex_in:\n        self.vertex_in.edges_in.remove(self)\n    self.vertex_in = vertex\n    vertex.edges_in.add(self)\n</code></pre>"},{"location":"reference/api/#dependenpy.Finder","title":"Finder","text":"<pre><code>Finder(finders: list[type] | None = None)\n</code></pre> <p>Main package finder class.</p> <p>Initialize it with a list of package finder classes (not instances).</p> <p>Parameters:</p> <ul> <li> <code>finders</code>               (<code>list[type] | None</code>, default:                   <code>None</code> )           \u2013            <p>list of package finder classes (not instances) in a specific order. Default: [LocalPackageFinder, InstalledPackageFinder].</p> </li> </ul> Returned by: <ul> <li> <code></code>\u00a0dependenpy <code></code>\u00a0DSM <code></code>\u00a0finder </li> </ul> Used by: <ul> <li> <code></code>\u00a0dependenpy <code></code>\u00a0DSM <code></code>\u00a0finder </li> </ul> <p>Methods:</p> <ul> <li> <code>find</code>             \u2013              <p>Find a package using package finders.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>finders</code>               (<code>list[PackageFinder]</code>)           \u2013            <p>Selected finders.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/finder.py</code> <pre><code>def __init__(self, finders: list[type] | None = None):\n    \"\"\"Initialization method.\n\n    Parameters:\n        finders: list of package finder classes (not instances) in a specific\n            order. Default: [LocalPackageFinder, InstalledPackageFinder].\n    \"\"\"\n    self.finders: list[PackageFinder]\n    \"\"\"Selected finders.\"\"\"\n    if finders is None:\n        finder_instances = [LocalPackageFinder(), InstalledPackageFinder()]\n    else:\n        finder_instances = [finder() for finder in finders]\n    self.finders = finder_instances\n</code></pre>"},{"location":"reference/api/#dependenpy.Finder.finders","title":"finders  <code>instance-attribute</code>","text":"<pre><code>finders: list[PackageFinder] = finder_instances\n</code></pre> <p>Selected finders.</p>"},{"location":"reference/api/#dependenpy.Finder.find","title":"find","text":"<pre><code>find(package: str, **kwargs: Any) -&gt; PackageSpec | None\n</code></pre> <p>Find a package using package finders.</p> <p>Return the first package found.</p> <p>Parameters:</p> <ul> <li> <code>package</code>               (<code>str</code>)           \u2013            <p>package to find.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>additional keyword arguments used by finders.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>PackageSpec | None</code>           \u2013            <p>Package spec or None.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/finder.py</code> <pre><code>def find(self, package: str, **kwargs: Any) -&gt; PackageSpec | None:\n    \"\"\"Find a package using package finders.\n\n    Return the first package found.\n\n    Parameters:\n        package: package to find.\n        **kwargs: additional keyword arguments used by finders.\n\n    Returns:\n        Package spec or None.\n    \"\"\"\n    for finder in self.finders:\n        package_spec = finder.find(package, **kwargs)\n        if package_spec:\n            return package_spec\n    return None\n</code></pre>"},{"location":"reference/api/#dependenpy.Graph","title":"Graph","text":"<pre><code>Graph(*nodes: DSM | Package | Module, depth: int = 0)\n</code></pre> <p>               Bases: <code>PrintMixin</code></p> <p>Graph class.</p> <p>A class to build a graph given a list of nodes. After instantiation, it has two attributes: vertices, the set of nodes, and edges, the set of edges.</p> <p>An intermediary matrix is built to ease the creation of the graph.</p> <p>Parameters:</p> <ul> <li> <code>*nodes</code>               (<code>list of DSM/Package/Module</code>, default:                   <code>()</code> )           \u2013            <p>the nodes on which to build the graph.</p> </li> <li> <code>depth</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>the depth of the intermediary matrix. See the documentation for Matrix class.</p> </li> </ul> Returned by: <ul> <li> <code></code>\u00a0dependenpy <ul> <li> <code></code>\u00a0DSM <code></code>\u00a0as_graph </li> <li> <code></code>\u00a0Package <code></code>\u00a0as_graph </li> <li> <code></code>\u00a0RootNode <code></code>\u00a0as_graph </li> </ul> </li> </ul> <p>Methods:</p> <ul> <li> <code>print</code>             \u2013              <p>Print the object in a file or on standard output by default.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>edges</code>           \u2013            <p>Set of edges in the graph.</p> </li> <li> <code>vertices</code>           \u2013            <p>Set of vertices in the graph.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/structures.py</code> <pre><code>def __init__(self, *nodes: DSM | Package | Module, depth: int = 0) -&gt; None:\n    \"\"\"Initialization method.\n\n    An intermediary matrix is built to ease the creation of the graph.\n\n    Parameters:\n        *nodes (list of DSM/Package/Module):\n            the nodes on which to build the graph.\n        depth (int): the depth of the intermediary matrix. See\n            the documentation for Matrix class.\n    \"\"\"\n    self.edges = set()\n    \"\"\"Set of edges in the graph.\"\"\"\n    vertices = []\n    matrix = Matrix(*nodes, depth=depth)\n    for key in matrix.keys:\n        vertices.append(Vertex(key))\n    for line_index, line in enumerate(matrix.data):\n        for col_index, cell in enumerate(line):\n            if cell &gt; 0:\n                self.edges.add(Edge(vertices[line_index], vertices[col_index], weight=cell))\n    self.vertices = set(vertices)\n    \"\"\"Set of vertices in the graph.\"\"\"\n</code></pre>"},{"location":"reference/api/#dependenpy.Graph.edges","title":"edges  <code>instance-attribute</code>","text":"<pre><code>edges = set()\n</code></pre> <p>Set of edges in the graph.</p>"},{"location":"reference/api/#dependenpy.Graph.vertices","title":"vertices  <code>instance-attribute</code>","text":"<pre><code>vertices = set(vertices)\n</code></pre> <p>Set of vertices in the graph.</p>"},{"location":"reference/api/#dependenpy.Graph.print","title":"print","text":"<pre><code>print(\n    format: str | None = TEXT,\n    output: IO = stdout,\n    **kwargs: Any,\n) -&gt; None\n</code></pre> <p>Print the object in a file or on standard output by default.</p> <p>Parameters:</p> <ul> <li> <code>format</code>               (<code>str | None</code>, default:                   <code>TEXT</code> )           \u2013            <p>Output format (csv, json or text).</p> </li> <li> <code>output</code>               (<code>IO</code>, default:                   <code>stdout</code> )           \u2013            <p>Descriptor to an opened file (default to standard output).</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional arguments.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/helpers.py</code> <pre><code>def print(self, format: str | None = TEXT, output: IO = sys.stdout, **kwargs: Any) -&gt; None:  # noqa: A002\n    \"\"\"Print the object in a file or on standard output by default.\n\n    Parameters:\n        format: Output format (csv, json or text).\n        output: Descriptor to an opened file (default to standard output).\n        **kwargs: Additional arguments.\n    \"\"\"\n    if format is None:\n        format = TEXT\n\n    if format != TEXT:\n        kwargs.pop(\"zero\", \"\")\n\n    if format == TEXT:\n        print(self._to_text(**kwargs), file=output)\n    elif format == CSV:\n        print(self._to_csv(**kwargs), file=output)\n    elif format == JSON:\n        print(self._to_json(**kwargs), file=output)\n</code></pre>"},{"location":"reference/api/#dependenpy.InstalledPackageFinder","title":"InstalledPackageFinder","text":"<p>               Bases: <code>PackageFinder</code></p> <p>Finder to find installed Python packages using importlib.</p> <p>Methods:</p> <ul> <li> <code>find</code>             \u2013              <p>Find method.</p> </li> </ul>"},{"location":"reference/api/#dependenpy.InstalledPackageFinder.find","title":"find","text":"<pre><code>find(package: str, **kwargs: Any) -&gt; PackageSpec | None\n</code></pre> <p>Find method.</p> <p>Parameters:</p> <ul> <li> <code>package</code>               (<code>str</code>)           \u2013            <p>package to find.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>additional keyword arguments.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>PackageSpec | None</code>           \u2013            <p>Package spec or None.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/finder.py</code> <pre><code>def find(self, package: str, **kwargs: Any) -&gt; PackageSpec | None:  # noqa: ARG002\n    \"\"\"Find method.\n\n    Parameters:\n        package: package to find.\n        **kwargs: additional keyword arguments.\n\n    Returns:\n        Package spec or None.\n    \"\"\"\n    spec = find_spec(package)\n    if spec is None:\n        return None\n    if \".\" in package:\n        package, rest = package.split(\".\", 1)\n        limit = [rest]\n        spec = find_spec(package)\n    else:\n        limit = []\n    if spec is not None:\n        if spec.submodule_search_locations:\n            path = spec.submodule_search_locations[0]\n        elif spec.origin and spec.origin != \"built-in\":\n            path = spec.origin\n        else:\n            return None\n        return PackageSpec(spec.name, path, limit)\n    return None\n</code></pre>"},{"location":"reference/api/#dependenpy.InternalDependencies","title":"InternalDependencies","text":"<p>               Bases: <code>Provider</code></p> <p>Dependenpy provider for Archan.</p> <p>Methods:</p> <ul> <li> <code>get_data</code>             \u2013              <p>Provide matrix data for internal dependencies in a set of packages.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>argument_list</code>           \u2013            <p>List of arguments for the provider.</p> </li> <li> <code>description</code>           \u2013            <p>Description of the provider.</p> </li> <li> <code>identifier</code>           \u2013            <p>Identifier of the provider.</p> </li> <li> <code>name</code>           \u2013            <p>Name of the provider.</p> </li> </ul>"},{"location":"reference/api/#dependenpy.InternalDependencies.argument_list","title":"argument_list  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>argument_list = (\n    Argument(\n        \"packages\",\n        list,\n        \"The list of packages to check for.\",\n    ),\n    Argument(\n        \"enforce_init\",\n        bool,\n        default=True,\n        description=\"Whether to assert presence of __init__.py files in directories.\",\n    ),\n    Argument(\n        \"depth\", int, \"The depth of the matrix to generate.\"\n    ),\n)\n</code></pre> <p>List of arguments for the provider.</p>"},{"location":"reference/api/#dependenpy.InternalDependencies.description","title":"description  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>description = \"Provide matrix data about internal dependencies in a set of packages.\"\n</code></pre> <p>Description of the provider.</p>"},{"location":"reference/api/#dependenpy.InternalDependencies.identifier","title":"identifier  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>identifier = 'dependenpy.InternalDependencies'\n</code></pre> <p>Identifier of the provider.</p>"},{"location":"reference/api/#dependenpy.InternalDependencies.name","title":"name  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>name = 'Internal Dependencies'\n</code></pre> <p>Name of the provider.</p>"},{"location":"reference/api/#dependenpy.InternalDependencies.get_data","title":"get_data","text":"<pre><code>get_data(\n    packages: list[str],\n    enforce_init: bool = True,\n    depth: int | None = None,\n) -&gt; DSM\n</code></pre> <p>Provide matrix data for internal dependencies in a set of packages.</p> <p>Parameters:</p> <ul> <li> <code>packages</code>               (<code>list[str]</code>)           \u2013            <p>The list of packages to check for.</p> </li> <li> <code>enforce_init</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to assert presence of init.py files in directories.</p> </li> <li> <code>depth</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The depth of the matrix to generate.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DSM</code>           \u2013            <p>Instance of archan DSM.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/plugins.py</code> <pre><code>def get_data(\n    self,\n    packages: list[str],\n    enforce_init: bool = True,  # noqa: FBT001,FBT002\n    depth: int | None = None,\n) -&gt; archan.DSM:\n    \"\"\"Provide matrix data for internal dependencies in a set of packages.\n\n    Parameters:\n        packages: The list of packages to check for.\n        enforce_init: Whether to assert presence of __init__.py files in directories.\n        depth: The depth of the matrix to generate.\n\n    Returns:\n        Instance of archan DSM.\n    \"\"\"\n    dsm = DependenpyDSM(*packages, enforce_init=enforce_init)\n    if depth is None:\n        depth = guess_depth(packages)\n    matrix = dsm.as_matrix(depth=depth)\n    return archan.DesignStructureMatrix(data=matrix.data, entities=matrix.keys)\n</code></pre>"},{"location":"reference/api/#dependenpy.LeafNode","title":"LeafNode","text":"<pre><code>LeafNode()\n</code></pre> <p>Shared code between Package and Module.</p> Subclassed by: <ul> <li> <code></code>\u00a0dependenpy <ul> <li> <code></code>\u00a0Module </li> <li> <code></code>\u00a0Package </li> </ul> </li> </ul> <p>Methods:</p> <ul> <li> <code>absolute_name</code>             \u2013              <p>Return the absolute name of the node.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>depth</code>               (<code>int</code>)           \u2013            <p>Property to tell the depth of the node in the tree.</p> </li> <li> <code>root</code>               (<code>Package</code>)           \u2013            <p>Property to return the root of this node.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/node.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialization method.\"\"\"\n    self._depth_cache = None\n</code></pre>"},{"location":"reference/api/#dependenpy.LeafNode.depth","title":"depth  <code>property</code>","text":"<pre><code>depth: int\n</code></pre> <p>Property to tell the depth of the node in the tree.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The node's depth in the tree.</p> </li> </ul>"},{"location":"reference/api/#dependenpy.LeafNode.root","title":"root  <code>property</code>","text":"<pre><code>root: Package\n</code></pre> <p>Property to return the root of this node.</p> <p>Returns:</p> <ul> <li> <code>Package</code> (              <code>Package</code> )          \u2013            <p>this node's root package.</p> </li> </ul>"},{"location":"reference/api/#dependenpy.LeafNode.absolute_name","title":"absolute_name","text":"<pre><code>absolute_name(depth: int = 0) -&gt; str\n</code></pre> <p>Return the absolute name of the node.</p> <p>Concatenate names from root to self within depth.</p> <p>Parameters:</p> <ul> <li> <code>depth</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Maximum depth to go to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Absolute name of the node (until given depth is reached).</p> </li> </ul> Source code in <code>src/dependenpy/_internal/node.py</code> <pre><code>def absolute_name(self, depth: int = 0) -&gt; str:\n    \"\"\"Return the absolute name of the node.\n\n    Concatenate names from root to self within depth.\n\n    Parameters:\n        depth: Maximum depth to go to.\n\n    Returns:\n        Absolute name of the node (until given depth is reached).\n    \"\"\"\n    node: Package\n    node, node_depth = self, self.depth  # type: ignore[assignment]\n    if depth &lt; 1:\n        depth = node_depth\n    while node_depth &gt; depth and node.package is not None:\n        node = node.package\n        node_depth -= 1\n    names = []\n    while node is not None:\n        names.append(node.name)\n        node = node.package  # type: ignore[assignment]\n    return \".\".join(reversed(names))\n</code></pre>"},{"location":"reference/api/#dependenpy.LocalPackageFinder","title":"LocalPackageFinder","text":"<p>               Bases: <code>PackageFinder</code></p> <p>Finder to find local packages (directories on the disk).</p> <p>Methods:</p> <ul> <li> <code>find</code>             \u2013              <p>Find method.</p> </li> </ul>"},{"location":"reference/api/#dependenpy.LocalPackageFinder.find","title":"find","text":"<pre><code>find(package: str, **kwargs: Any) -&gt; PackageSpec | None\n</code></pre> <p>Find method.</p> <p>Parameters:</p> <ul> <li> <code>package</code>               (<code>str</code>)           \u2013            <p>Package to find.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>PackageSpec | None</code>           \u2013            <p>Package spec or None.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/finder.py</code> <pre><code>def find(self, package: str, **kwargs: Any) -&gt; PackageSpec | None:\n    \"\"\"Find method.\n\n    Parameters:\n        package: Package to find.\n        **kwargs: Additional keyword arguments.\n\n    Returns:\n        Package spec or None.\n    \"\"\"\n    if not exists(package):\n        return None\n    name, path = None, None\n    enforce_init = kwargs.pop(\"enforce_init\", True)\n    if isdir(package):\n        if isfile(join(package, \"__init__.py\")) or not enforce_init:\n            name, path = basename(package), package\n    elif isfile(package) and package.endswith(\".py\"):\n        name, path = splitext(basename(package))[0], package\n    if name and path:\n        return PackageSpec(name, path)\n    return None\n</code></pre>"},{"location":"reference/api/#dependenpy.Matrix","title":"Matrix","text":"<pre><code>Matrix(*nodes: DSM | Package | Module, depth: int = 0)\n</code></pre> <p>               Bases: <code>PrintMixin</code></p> <p>Matrix class.</p> <p>A class to build a matrix given a list of nodes. After instantiation, it has two attributes: data, a 2-dimensions array, and keys, the names of the entities in the corresponding order.</p> <p>Parameters:</p> <ul> <li> <code>*nodes</code>               (<code>DSM | Package | Module</code>, default:                   <code>()</code> )           \u2013            <p>The nodes on which to build the matrix.</p> </li> <li> <code>depth</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The depth of the matrix. This depth is always absolute, meaning that building a matrix with a sub-package \"A.B.C\" and a depth of 1 will return a matrix of size 1, containing A only. To see the matrix for the sub-modules and sub-packages in C, you will have to give depth=4.</p> </li> </ul> Returned by: <ul> <li> <code></code>\u00a0dependenpy <ul> <li> <code></code>\u00a0DSM <code></code>\u00a0as_matrix </li> <li> <code></code>\u00a0Matrix <code></code>\u00a0cast </li> <li> <code></code>\u00a0Package <code></code>\u00a0as_matrix </li> <li> <code></code>\u00a0RootNode <code></code>\u00a0as_matrix </li> </ul> </li> </ul> <p>Methods:</p> <ul> <li> <code>cast</code>             \u2013              <p>Cast a set of keys and an array to a Matrix object.</p> </li> <li> <code>print</code>             \u2013              <p>Print the object in a file or on standard output by default.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>data</code>           \u2013            <p>The data of the matrix.</p> </li> <li> <code>keys</code>           \u2013            <p>The keys of the matrix.</p> </li> <li> <code>size</code>           \u2013            <p>The size of the matrix.</p> </li> <li> <code>total</code>               (<code>int</code>)           \u2013            <p>Return the total number of dependencies within this matrix.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/structures.py</code> <pre><code>def __init__(self, *nodes: DSM | Package | Module, depth: int = 0):\n    \"\"\"Initialization method.\n\n    Parameters:\n        *nodes: The nodes on which to build the matrix.\n        depth: The depth of the matrix. This depth is always\n            absolute, meaning that building a matrix with a sub-package\n            \"A.B.C\" and a depth of 1 will return a matrix of size 1,\n            containing A only. To see the matrix for the sub-modules and\n            sub-packages in C, you will have to give depth=4.\n    \"\"\"\n    modules: list[Module] = []\n    for node in nodes:\n        if node.ismodule:\n            modules.append(node)  # type: ignore[arg-type]\n        elif node.ispackage or node.isdsm:\n            modules.extend(node.submodules)  # type: ignore[union-attr]\n\n    if depth &lt; 1:\n        keys = modules\n    else:\n        keys = []\n        for module in modules:\n            if module.depth &lt;= depth:\n                keys.append(module)\n                continue\n            package = module.package\n            while package.depth &gt; depth and package.package and package not in nodes:  # type: ignore[union-attr]\n                package = package.package  # type: ignore[union-attr]\n            if package not in keys:\n                keys.append(package)  # type: ignore[arg-type]\n\n    size = len(keys)\n    data = [[0] * size for _ in range(size)]\n    keys = sorted(keys, key=lambda key: key.absolute_name())\n\n    if depth &lt; 1:\n        for index, key in enumerate(keys):\n            key.index = index  # type: ignore[attr-defined]\n        for index, key in enumerate(keys):\n            for dep in key.dependencies:\n                if dep.external:\n                    continue\n                if dep.target.ismodule and dep.target in keys:  # type: ignore[union-attr]\n                    data[index][dep.target.index] += 1  # type: ignore[index,union-attr]\n                elif dep.target.ispackage:  # type: ignore[union-attr]\n                    init = dep.target.get(\"__init__\")  # type: ignore[union-attr]\n                    if init is not None and init in keys:\n                        data[index][init.index] += 1  # type: ignore[union-attr]\n    else:\n        for row, row_key in enumerate(keys):\n            for col, col_key in enumerate(keys):\n                data[row][col] = row_key.cardinal(to=col_key)\n\n    self.size = size\n    \"\"\"The size of the matrix.\"\"\"\n    self.keys = [key.absolute_name() for key in keys]\n    \"\"\"The keys of the matrix.\"\"\"\n    self.data = data\n    \"\"\"The data of the matrix.\"\"\"\n</code></pre>"},{"location":"reference/api/#dependenpy.Matrix.data","title":"data  <code>instance-attribute</code>","text":"<pre><code>data = data\n</code></pre> <p>The data of the matrix.</p>"},{"location":"reference/api/#dependenpy.Matrix.keys","title":"keys  <code>instance-attribute</code>","text":"<pre><code>keys = [(absolute_name()) for key in keys]\n</code></pre> <p>The keys of the matrix.</p>"},{"location":"reference/api/#dependenpy.Matrix.size","title":"size  <code>instance-attribute</code>","text":"<pre><code>size = size\n</code></pre> <p>The size of the matrix.</p>"},{"location":"reference/api/#dependenpy.Matrix.total","title":"total  <code>property</code>","text":"<pre><code>total: int\n</code></pre> <p>Return the total number of dependencies within this matrix.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The total number of dependencies.</p> </li> </ul>"},{"location":"reference/api/#dependenpy.Matrix.cast","title":"cast  <code>staticmethod</code>","text":"<pre><code>cast(keys: list[str], data: list[list[int]]) -&gt; Matrix\n</code></pre> <p>Cast a set of keys and an array to a Matrix object.</p> <p>Parameters:</p> <ul> <li> <code>keys</code>               (<code>list[str]</code>)           \u2013            <p>The matrix keys.</p> </li> <li> <code>data</code>               (<code>list[list[int]]</code>)           \u2013            <p>The matrix data.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Matrix</code>           \u2013            <p>A new matrix.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/structures.py</code> <pre><code>@staticmethod\ndef cast(keys: list[str], data: list[list[int]]) -&gt; Matrix:\n    \"\"\"Cast a set of keys and an array to a Matrix object.\n\n    Arguments:\n        keys: The matrix keys.\n        data: The matrix data.\n\n    Returns:\n        A new matrix.\n    \"\"\"\n    matrix = Matrix()\n    matrix.keys = copy.deepcopy(keys)\n    matrix.data = copy.deepcopy(data)\n    return matrix\n</code></pre>"},{"location":"reference/api/#dependenpy.Matrix.print","title":"print","text":"<pre><code>print(\n    format: str | None = TEXT,\n    output: IO = stdout,\n    **kwargs: Any,\n) -&gt; None\n</code></pre> <p>Print the object in a file or on standard output by default.</p> <p>Parameters:</p> <ul> <li> <code>format</code>               (<code>str | None</code>, default:                   <code>TEXT</code> )           \u2013            <p>Output format (csv, json or text).</p> </li> <li> <code>output</code>               (<code>IO</code>, default:                   <code>stdout</code> )           \u2013            <p>Descriptor to an opened file (default to standard output).</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional arguments.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/helpers.py</code> <pre><code>def print(self, format: str | None = TEXT, output: IO = sys.stdout, **kwargs: Any) -&gt; None:  # noqa: A002\n    \"\"\"Print the object in a file or on standard output by default.\n\n    Parameters:\n        format: Output format (csv, json or text).\n        output: Descriptor to an opened file (default to standard output).\n        **kwargs: Additional arguments.\n    \"\"\"\n    if format is None:\n        format = TEXT\n\n    if format != TEXT:\n        kwargs.pop(\"zero\", \"\")\n\n    if format == TEXT:\n        print(self._to_text(**kwargs), file=output)\n    elif format == CSV:\n        print(self._to_csv(**kwargs), file=output)\n    elif format == JSON:\n        print(self._to_json(**kwargs), file=output)\n</code></pre>"},{"location":"reference/api/#dependenpy.Module","title":"Module","text":"<pre><code>Module(\n    name: str,\n    path: str,\n    dsm: DSM | None = None,\n    package: Package | None = None,\n)\n</code></pre> <p>               Bases: <code>LeafNode</code>, <code>NodeMixin</code>, <code>PrintMixin</code></p> <p>Module class.</p> <p>This class represents a Python module (a Python file).</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Name of the module.</p> </li> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>Path to the module.</p> </li> <li> <code>dsm</code>               (<code>DSM | None</code>, default:                   <code>None</code> )           \u2013            <p>Parent DSM.</p> </li> <li> <code>package</code>               (<code>Package | None</code>, default:                   <code>None</code> )           \u2013            <p>Parent Package.</p> </li> </ul> Returned by: <ul> <li> <code></code>\u00a0dependenpy <ul> <li> <code></code>\u00a0DSM <ul> <li> <code></code>\u00a0modules </li> <li> <code></code>\u00a0submodules </li> <li> <code></code>\u00a0__getitem__ </li> <li> <code></code>\u00a0get </li> <li> <code></code>\u00a0get_target </li> </ul> </li> <li> <code></code>\u00a0Package <ul> <li> <code></code>\u00a0modules </li> <li> <code></code>\u00a0submodules </li> <li> <code></code>\u00a0__getitem__ </li> <li> <code></code>\u00a0get </li> <li> <code></code>\u00a0get_target </li> </ul> </li> <li> <code></code>\u00a0RootNode <ul> <li> <code></code>\u00a0modules </li> <li> <code></code>\u00a0submodules </li> <li> <code></code>\u00a0__getitem__ </li> <li> <code></code>\u00a0get </li> <li> <code></code>\u00a0get_target </li> </ul> </li> </ul> </li> </ul> Used by: <ul> <li> <code></code>\u00a0dependenpy <ul> <li> <code></code>\u00a0DSM <code></code>\u00a0__contains__ </li> <li> <code></code>\u00a0Dependency </li> <li> <code></code>\u00a0Graph </li> <li> <code></code>\u00a0Matrix </li> <li> <code></code>\u00a0Module <ul> <li> <code></code>\u00a0__contains__ </li> <li> <code></code>\u00a0cardinal </li> </ul> </li> <li> <code></code>\u00a0Package <ul> <li> <code></code>\u00a0__contains__ </li> <li> <code></code>\u00a0cardinal </li> </ul> </li> <li> <code></code>\u00a0RootNode <code></code>\u00a0__contains__ </li> </ul> </li> </ul> <p>Methods:</p> <ul> <li> <code>__contains__</code>             \u2013              <p>Whether given item is contained inside this module.</p> </li> <li> <code>absolute_name</code>             \u2013              <p>Return the absolute name of the node.</p> </li> <li> <code>as_dict</code>             \u2013              <p>Return the dependencies as a dictionary.</p> </li> <li> <code>build_dependencies</code>             \u2013              <p>Build the dependencies for this module.</p> </li> <li> <code>cardinal</code>             \u2013              <p>Return the number of dependencies of this module to the given node.</p> </li> <li> <code>get_imports</code>             \u2013              <p>Return all the import statements given an AST body (AST nodes).</p> </li> <li> <code>parse_code</code>             \u2013              <p>Read the source code and return all the import statements.</p> </li> <li> <code>print</code>             \u2013              <p>Print the object in a file or on standard output by default.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>RECURSIVE_NODES</code>           \u2013            <p>Nodes that can be recursive.</p> </li> <li> <code>dependencies</code>               (<code>list[Dependency]</code>)           \u2013            <p>List of dependencies.</p> </li> <li> <code>depth</code>               (<code>int</code>)           \u2013            <p>Property to tell the depth of the node in the tree.</p> </li> <li> <code>dsm</code>           \u2013            <p>Parent DSM.</p> </li> <li> <code>isdsm</code>               (<code>bool</code>)           \u2013            <p>Property to check if object is instance of DSM.</p> </li> <li> <code>ismodule</code>               (<code>bool</code>)           \u2013            <p>Inherited from NodeMixin. Always True.</p> </li> <li> <code>ispackage</code>               (<code>bool</code>)           \u2013            <p>Property to check if object is instance of Package.</p> </li> <li> <code>name</code>           \u2013            <p>Name of the module.</p> </li> <li> <code>package</code>           \u2013            <p>Package to which the module belongs.</p> </li> <li> <code>path</code>           \u2013            <p>Path to the module.</p> </li> <li> <code>root</code>               (<code>Package</code>)           \u2013            <p>Property to return the root of this node.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/dsm.py</code> <pre><code>def __init__(self, name: str, path: str, dsm: DSM | None = None, package: Package | None = None) -&gt; None:\n    \"\"\"Initialization method.\n\n    Parameters:\n        name: Name of the module.\n        path: Path to the module.\n        dsm: Parent DSM.\n        package: Parent Package.\n    \"\"\"\n    super().__init__()\n    self.name = name\n    \"\"\"Name of the module.\"\"\"\n    self.path = path\n    \"\"\"Path to the module.\"\"\"\n    self.package = package\n    \"\"\"Package to which the module belongs.\"\"\"\n    self.dsm = dsm\n    \"\"\"Parent DSM.\"\"\"\n    self.dependencies: list[Dependency] = []\n    \"\"\"List of dependencies.\"\"\"\n</code></pre>"},{"location":"reference/api/#dependenpy.Module.RECURSIVE_NODES","title":"RECURSIVE_NODES  <code>class-attribute</code> <code>instance-attribute</code>","text":"<pre><code>RECURSIVE_NODES = (\n    ClassDef,\n    FunctionDef,\n    If,\n    IfExp,\n    Try,\n    With,\n    ExceptHandler,\n)\n</code></pre> <p>Nodes that can be recursive.</p>"},{"location":"reference/api/#dependenpy.Module.dependencies","title":"dependencies  <code>instance-attribute</code>","text":"<pre><code>dependencies: list[Dependency] = []\n</code></pre> <p>List of dependencies.</p>"},{"location":"reference/api/#dependenpy.Module.depth","title":"depth  <code>property</code>","text":"<pre><code>depth: int\n</code></pre> <p>Property to tell the depth of the node in the tree.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The node's depth in the tree.</p> </li> </ul>"},{"location":"reference/api/#dependenpy.Module.dsm","title":"dsm  <code>instance-attribute</code>","text":"<pre><code>dsm = dsm\n</code></pre> <p>Parent DSM.</p>"},{"location":"reference/api/#dependenpy.Module.isdsm","title":"isdsm  <code>property</code>","text":"<pre><code>isdsm: bool\n</code></pre> <p>Property to check if object is instance of DSM.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Whether this object is a DSM.</p> </li> </ul>"},{"location":"reference/api/#dependenpy.Module.ismodule","title":"ismodule  <code>property</code>","text":"<pre><code>ismodule: bool\n</code></pre> <p>Inherited from NodeMixin. Always True.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Whether this object is a module.</p> </li> </ul>"},{"location":"reference/api/#dependenpy.Module.ispackage","title":"ispackage  <code>property</code>","text":"<pre><code>ispackage: bool\n</code></pre> <p>Property to check if object is instance of Package.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Whether this object is a package.</p> </li> </ul>"},{"location":"reference/api/#dependenpy.Module.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name = name\n</code></pre> <p>Name of the module.</p>"},{"location":"reference/api/#dependenpy.Module.package","title":"package  <code>instance-attribute</code>","text":"<pre><code>package = package\n</code></pre> <p>Package to which the module belongs.</p>"},{"location":"reference/api/#dependenpy.Module.path","title":"path  <code>instance-attribute</code>","text":"<pre><code>path = path\n</code></pre> <p>Path to the module.</p>"},{"location":"reference/api/#dependenpy.Module.root","title":"root  <code>property</code>","text":"<pre><code>root: Package\n</code></pre> <p>Property to return the root of this node.</p> <p>Returns:</p> <ul> <li> <code>Package</code> (              <code>Package</code> )          \u2013            <p>this node's root package.</p> </li> </ul>"},{"location":"reference/api/#dependenpy.Module.__contains__","title":"__contains__","text":"<pre><code>__contains__(item: Package | Module) -&gt; bool\n</code></pre> <p>Whether given item is contained inside this module.</p> <p>Parameters:</p> <ul> <li> <code>item</code>               (<code>Package / Module</code>)           \u2013            <p>a package or module.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if self is item or item is self's package and self if an <code>__init__</code> module.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/dsm.py</code> <pre><code>def __contains__(self, item: Package | Module) -&gt; bool:\n    \"\"\"Whether given item is contained inside this module.\n\n    Parameters:\n        item (Package/Module): a package or module.\n\n    Returns:\n        True if self is item or item is self's package and\n            self if an `__init__` module.\n    \"\"\"\n    if self is item:\n        return True\n    return self.package is item and self.name == \"__init__\"\n</code></pre>"},{"location":"reference/api/#dependenpy.Module.absolute_name","title":"absolute_name","text":"<pre><code>absolute_name(depth: int = 0) -&gt; str\n</code></pre> <p>Return the absolute name of the node.</p> <p>Concatenate names from root to self within depth.</p> <p>Parameters:</p> <ul> <li> <code>depth</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Maximum depth to go to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Absolute name of the node (until given depth is reached).</p> </li> </ul> Source code in <code>src/dependenpy/_internal/node.py</code> <pre><code>def absolute_name(self, depth: int = 0) -&gt; str:\n    \"\"\"Return the absolute name of the node.\n\n    Concatenate names from root to self within depth.\n\n    Parameters:\n        depth: Maximum depth to go to.\n\n    Returns:\n        Absolute name of the node (until given depth is reached).\n    \"\"\"\n    node: Package\n    node, node_depth = self, self.depth  # type: ignore[assignment]\n    if depth &lt; 1:\n        depth = node_depth\n    while node_depth &gt; depth and node.package is not None:\n        node = node.package\n        node_depth -= 1\n    names = []\n    while node is not None:\n        names.append(node.name)\n        node = node.package  # type: ignore[assignment]\n    return \".\".join(reversed(names))\n</code></pre>"},{"location":"reference/api/#dependenpy.Module.as_dict","title":"as_dict","text":"<pre><code>as_dict(absolute: bool = False) -&gt; dict\n</code></pre> <p>Return the dependencies as a dictionary.</p> <p>Parameters:</p> <ul> <li> <code>absolute</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to use the absolute name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>Dictionary of dependencies.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/dsm.py</code> <pre><code>def as_dict(self, absolute: bool = False) -&gt; dict:  # noqa: FBT001,FBT002\n    \"\"\"Return the dependencies as a dictionary.\n\n    Arguments:\n        absolute: Whether to use the absolute name.\n\n    Returns:\n        Dictionary of dependencies.\n    \"\"\"\n    return {\n        \"name\": self.absolute_name() if absolute else self.name,\n        \"path\": self.path,\n        \"dependencies\": [\n            {\n                # 'source': d.source.absolute_name(),  # redundant\n                \"target\": dep.target if dep.external else dep.target.absolute_name(),  # type: ignore[union-attr]\n                \"lineno\": dep.lineno,\n                \"what\": dep.what,\n                \"external\": dep.external,\n            }\n            for dep in self.dependencies\n        ],\n    }\n</code></pre>"},{"location":"reference/api/#dependenpy.Module.build_dependencies","title":"build_dependencies","text":"<pre><code>build_dependencies() -&gt; None\n</code></pre> <p>Build the dependencies for this module.</p> <p>Parse the code with ast, find all the import statements, convert them into Dependency objects.</p> Source code in <code>src/dependenpy/_internal/dsm.py</code> <pre><code>def build_dependencies(self) -&gt; None:\n    \"\"\"Build the dependencies for this module.\n\n    Parse the code with ast, find all the import statements, convert\n    them into Dependency objects.\n    \"\"\"\n    highest = self.dsm or self.root\n    for import_ in self.parse_code():\n        target = highest.get_target(import_[\"target\"])\n        if target:\n            what = import_[\"target\"].split(\".\")[-1]\n            if what != target.name:\n                import_[\"what\"] = what\n            import_[\"target\"] = target\n        self.dependencies.append(Dependency(source=self, **import_))\n</code></pre>"},{"location":"reference/api/#dependenpy.Module.cardinal","title":"cardinal","text":"<pre><code>cardinal(to: Package | Module) -&gt; int\n</code></pre> <p>Return the number of dependencies of this module to the given node.</p> <p>Parameters:</p> <ul> <li> <code>to</code>               (<code>Package | Module</code>)           \u2013            <p>The target node.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Number of dependencies.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/dsm.py</code> <pre><code>def cardinal(self, to: Package | Module) -&gt; int:\n    \"\"\"Return the number of dependencies of this module to the given node.\n\n    Parameters:\n        to: The target node.\n\n    Returns:\n        Number of dependencies.\n    \"\"\"\n    return len([dep for dep in self.dependencies if not dep.external and dep.target in to])  # type: ignore[operator]\n</code></pre>"},{"location":"reference/api/#dependenpy.Module.get_imports","title":"get_imports","text":"<pre><code>get_imports(ast_body: Sequence[AST]) -&gt; list[dict]\n</code></pre> <p>Return all the import statements given an AST body (AST nodes).</p> <p>Returns:</p> <ul> <li> <code>list[dict]</code>           \u2013            <p>The import statements.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/dsm.py</code> <pre><code>def get_imports(self, ast_body: Sequence[ast.AST]) -&gt; list[dict]:\n    \"\"\"Return all the import statements given an AST body (AST nodes).\n\n    Parameters:\n        The body to filter.\n\n    Returns:\n        The import statements.\n    \"\"\"\n    imports: list[dict] = []\n    for node in ast_body:\n        if isinstance(node, ast.Import):\n            imports.extend({\"target\": name.name, \"lineno\": node.lineno} for name in node.names)\n        elif isinstance(node, ast.ImportFrom):\n            for name in node.names:\n                abs_name = self.absolute_name(self.depth - node.level) + \".\" if node.level &gt; 0 else \"\"\n                node_module = node.module + \".\" if node.module else \"\"\n                name = abs_name + node_module + name.name  # type: ignore[assignment]  # noqa: PLW2901\n                imports.append({\"target\": name, \"lineno\": node.lineno})\n        elif isinstance(node, Module.RECURSIVE_NODES):\n            imports.extend(self.get_imports(node.body))  # type: ignore[arg-type]\n            if isinstance(node, ast.Try):\n                imports.extend(self.get_imports(node.finalbody))\n    return imports\n</code></pre>"},{"location":"reference/api/#dependenpy.Module.parse_code","title":"parse_code","text":"<pre><code>parse_code() -&gt; list[dict]\n</code></pre> <p>Read the source code and return all the import statements.</p> <p>Returns:</p> <ul> <li> <code>list[dict]</code>           \u2013            <p>The import statements.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/dsm.py</code> <pre><code>def parse_code(self) -&gt; list[dict]:\n    \"\"\"Read the source code and return all the import statements.\n\n    Returns:\n        The import statements.\n    \"\"\"\n    code = Path(self.path).read_text(encoding=\"utf-8\")\n    try:\n        body = ast.parse(code).body\n    except SyntaxError:\n        code = code.encode(\"utf-8\")  # type: ignore[assignment]\n        try:\n            body = ast.parse(code).body\n        except SyntaxError:\n            return []\n    return self.get_imports(body)\n</code></pre>"},{"location":"reference/api/#dependenpy.Module.print","title":"print","text":"<pre><code>print(\n    format: str | None = TEXT,\n    output: IO = stdout,\n    **kwargs: Any,\n) -&gt; None\n</code></pre> <p>Print the object in a file or on standard output by default.</p> <p>Parameters:</p> <ul> <li> <code>format</code>               (<code>str | None</code>, default:                   <code>TEXT</code> )           \u2013            <p>Output format (csv, json or text).</p> </li> <li> <code>output</code>               (<code>IO</code>, default:                   <code>stdout</code> )           \u2013            <p>Descriptor to an opened file (default to standard output).</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional arguments.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/helpers.py</code> <pre><code>def print(self, format: str | None = TEXT, output: IO = sys.stdout, **kwargs: Any) -&gt; None:  # noqa: A002\n    \"\"\"Print the object in a file or on standard output by default.\n\n    Parameters:\n        format: Output format (csv, json or text).\n        output: Descriptor to an opened file (default to standard output).\n        **kwargs: Additional arguments.\n    \"\"\"\n    if format is None:\n        format = TEXT\n\n    if format != TEXT:\n        kwargs.pop(\"zero\", \"\")\n\n    if format == TEXT:\n        print(self._to_text(**kwargs), file=output)\n    elif format == CSV:\n        print(self._to_csv(**kwargs), file=output)\n    elif format == JSON:\n        print(self._to_json(**kwargs), file=output)\n</code></pre>"},{"location":"reference/api/#dependenpy.NodeMixin","title":"NodeMixin","text":"<p>Shared code between DSM, Package and Module.</p> Subclassed by: <ul> <li> \u00a0dependenpy <ul> <li> \u00a0DSM </li> <li> \u00a0Module </li> <li> \u00a0Package </li> </ul> </li> </ul> <p>Attributes:</p> <ul> <li> <code>isdsm</code>               (<code>bool</code>)           \u2013            <p>Property to check if object is instance of DSM.</p> </li> <li> <code>ismodule</code>               (<code>bool</code>)           \u2013            <p>Property to check if object is instance of Module.</p> </li> <li> <code>ispackage</code>               (<code>bool</code>)           \u2013            <p>Property to check if object is instance of Package.</p> </li> </ul>"},{"location":"reference/api/#dependenpy.NodeMixin.isdsm","title":"isdsm  <code>property</code>","text":"<pre><code>isdsm: bool\n</code></pre> <p>Property to check if object is instance of DSM.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Whether this object is a DSM.</p> </li> </ul>"},{"location":"reference/api/#dependenpy.NodeMixin.ismodule","title":"ismodule  <code>property</code>","text":"<pre><code>ismodule: bool\n</code></pre> <p>Property to check if object is instance of Module.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Whether this object is a module.</p> </li> </ul>"},{"location":"reference/api/#dependenpy.NodeMixin.ispackage","title":"ispackage  <code>property</code>","text":"<pre><code>ispackage: bool\n</code></pre> <p>Property to check if object is instance of Package.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Whether this object is a package.</p> </li> </ul>"},{"location":"reference/api/#dependenpy.Package","title":"Package","text":"<pre><code>Package(\n    name: str,\n    path: str,\n    dsm: DSM | None = None,\n    package: Package | None = None,\n    limit_to: list[str] | None = None,\n    build_tree: bool = True,\n    build_dependencies: bool = True,\n    enforce_init: bool = True,\n)\n</code></pre> <p>               Bases: <code>RootNode</code>, <code>LeafNode</code>, <code>NodeMixin</code>, <code>PrintMixin</code></p> <p>Package class.</p> <p>This class represent Python packages as nodes in a tree.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Name of the package.</p> </li> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>Path to the package.</p> </li> <li> <code>dsm</code>               (<code>DSM | None</code>, default:                   <code>None</code> )           \u2013            <p>Parent DSM.</p> </li> <li> <code>package</code>               (<code>Package | None</code>, default:                   <code>None</code> )           \u2013            <p>Parent package.</p> </li> <li> <code>limit_to</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of string to limit the recursive tree-building to what is specified.</p> </li> <li> <code>build_tree</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Auto-build the tree or not.</p> </li> <li> <code>build_dependencies</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Auto-build the dependencies or not.</p> </li> <li> <code>enforce_init</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, only treat directories if they contain an <code>__init__.py</code> file.</p> </li> </ul> Returned by: <ul> <li> <code></code>\u00a0dependenpy <ul> <li> <code></code>\u00a0DSM <ul> <li> <code></code>\u00a0packages </li> <li> <code></code>\u00a0__getitem__ </li> <li> <code></code>\u00a0get </li> <li> <code></code>\u00a0get_target </li> </ul> </li> <li> <code></code>\u00a0LeafNode <code></code>\u00a0root </li> <li> <code></code>\u00a0Module <code></code>\u00a0root </li> <li> <code></code>\u00a0Package <ul> <li> <code></code>\u00a0packages </li> <li> <code></code>\u00a0root </li> <li> <code></code>\u00a0__getitem__ </li> <li> <code></code>\u00a0get </li> <li> <code></code>\u00a0get_target </li> </ul> </li> <li> <code></code>\u00a0RootNode <ul> <li> <code></code>\u00a0packages </li> <li> <code></code>\u00a0__getitem__ </li> <li> <code></code>\u00a0get </li> <li> <code></code>\u00a0get_target </li> </ul> </li> </ul> </li> </ul> Used by: <ul> <li> <code></code>\u00a0dependenpy <ul> <li> <code></code>\u00a0DSM <code></code>\u00a0__contains__ </li> <li> <code></code>\u00a0Dependency </li> <li> <code></code>\u00a0Graph </li> <li> <code></code>\u00a0Matrix </li> <li> <code></code>\u00a0Module <code></code>\u00a0cardinal </li> <li> <code></code>\u00a0Package <code></code>\u00a0__contains__ </li> <li> <code></code>\u00a0RootNode <code></code>\u00a0__contains__ </li> </ul> </li> </ul> <p>Methods:</p> <ul> <li> <code>__bool__</code>             \u2013              <p>Node as Boolean.</p> </li> <li> <code>__contains__</code>             \u2013              <p>Get result of _contains, cache it and return it.</p> </li> <li> <code>__getitem__</code>             \u2013              <p>Return the corresponding Package or Module object.</p> </li> <li> <code>absolute_name</code>             \u2013              <p>Return the absolute name of the node.</p> </li> <li> <code>as_dict</code>             \u2013              <p>Return the dependencies as a dictionary.</p> </li> <li> <code>as_graph</code>             \u2013              <p>Create a graph with self as node, cache it, return it.</p> </li> <li> <code>as_matrix</code>             \u2013              <p>Create a matrix with self as node, cache it, return it.</p> </li> <li> <code>as_treemap</code>             \u2013              <p>Return the dependencies as a TreeMap.</p> </li> <li> <code>build_dependencies</code>             \u2013              <p>Recursively build the dependencies for sub-modules and sub-packages.</p> </li> <li> <code>build_tree</code>             \u2013              <p>Build the tree for this package.</p> </li> <li> <code>cardinal</code>             \u2013              <p>Return the number of dependencies of this package to the given node.</p> </li> <li> <code>get</code>             \u2013              <p>Get item through <code>__getitem__</code> and cache the result.</p> </li> <li> <code>get_target</code>             \u2013              <p>Get the result of _get_target, cache it and return it.</p> </li> <li> <code>print</code>             \u2013              <p>Print the object in a file or on standard output by default.</p> </li> <li> <code>print_graph</code>             \u2013              <p>Print the graph for self's nodes.</p> </li> <li> <code>print_matrix</code>             \u2013              <p>Print the matrix for self's nodes.</p> </li> <li> <code>print_treemap</code>             \u2013              <p>Print the matrix for self's nodes.</p> </li> <li> <code>split_limits_heads</code>             \u2013              <p>Return first parts of dot-separated strings, and rest of strings.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>depth</code>               (<code>int</code>)           \u2013            <p>Property to tell the depth of the node in the tree.</p> </li> <li> <code>dsm</code>           \u2013            <p>Parent DSM.</p> </li> <li> <code>empty</code>               (<code>bool</code>)           \u2013            <p>Whether the node has neither modules nor packages.</p> </li> <li> <code>enforce_init</code>           \u2013            <p>Whether to enforce the presence of <code>__init__.py</code> files.</p> </li> <li> <code>isdsm</code>               (<code>bool</code>)           \u2013            <p>Property to check if object is instance of DSM.</p> </li> <li> <code>ismodule</code>               (<code>bool</code>)           \u2013            <p>Property to check if object is instance of Module.</p> </li> <li> <code>ispackage</code>               (<code>bool</code>)           \u2013            <p>Inherited from NodeMixin. Always True.</p> </li> <li> <code>isroot</code>               (<code>bool</code>)           \u2013            <p>Property to tell if this node is a root node.</p> </li> <li> <code>issubpackage</code>               (<code>bool</code>)           \u2013            <p>Property to tell if this node is a sub-package.</p> </li> <li> <code>limit_to</code>           \u2013            <p>List of strings to limit the recursive tree-building.</p> </li> <li> <code>modules</code>               (<code>list[Module]</code>)           \u2013            <p>List of modules contained in the node.</p> </li> <li> <code>name</code>           \u2013            <p>Name of the package.</p> </li> <li> <code>package</code>           \u2013            <p>Parent package.</p> </li> <li> <code>packages</code>               (<code>list[Package]</code>)           \u2013            <p>List of packages contained in the node.</p> </li> <li> <code>path</code>           \u2013            <p>Path to the package.</p> </li> <li> <code>root</code>               (<code>Package</code>)           \u2013            <p>Property to return the root of this node.</p> </li> <li> <code>submodules</code>               (<code>list[Module]</code>)           \u2013            <p>Property to return all sub-modules of the node, recursively.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/dsm.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    path: str,\n    dsm: DSM | None = None,\n    package: Package | None = None,\n    limit_to: list[str] | None = None,\n    build_tree: bool = True,  # noqa: FBT001,FBT002\n    build_dependencies: bool = True,  # noqa: FBT001,FBT002\n    enforce_init: bool = True,  # noqa: FBT001,FBT002\n):\n    \"\"\"Initialization method.\n\n    Parameters:\n        name: Name of the package.\n        path: Path to the package.\n        dsm: Parent DSM.\n        package: Parent package.\n        limit_to: List of string to limit the recursive tree-building to what is specified.\n        build_tree: Auto-build the tree or not.\n        build_dependencies: Auto-build the dependencies or not.\n        enforce_init: If True, only treat directories if they contain an `__init__.py` file.\n    \"\"\"\n    self.name = name\n    \"\"\"Name of the package.\"\"\"\n    self.path = path\n    \"\"\"Path to the package.\"\"\"\n    self.package = package\n    \"\"\"Parent package.\"\"\"\n    self.dsm = dsm\n    \"\"\"Parent DSM.\"\"\"\n    self.limit_to = limit_to or []\n    \"\"\"List of strings to limit the recursive tree-building.\"\"\"\n    self.enforce_init = enforce_init\n    \"\"\"Whether to enforce the presence of `__init__.py` files.\"\"\"\n\n    RootNode.__init__(self, build_tree)\n    LeafNode.__init__(self)\n\n    if build_tree and build_dependencies:\n        self.build_dependencies()\n</code></pre>"},{"location":"reference/api/#dependenpy.Package.depth","title":"depth  <code>property</code>","text":"<pre><code>depth: int\n</code></pre> <p>Property to tell the depth of the node in the tree.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The node's depth in the tree.</p> </li> </ul>"},{"location":"reference/api/#dependenpy.Package.dsm","title":"dsm  <code>instance-attribute</code>","text":"<pre><code>dsm = dsm\n</code></pre> <p>Parent DSM.</p>"},{"location":"reference/api/#dependenpy.Package.empty","title":"empty  <code>property</code>","text":"<pre><code>empty: bool\n</code></pre> <p>Whether the node has neither modules nor packages.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if empty, False otherwise.</p> </li> </ul>"},{"location":"reference/api/#dependenpy.Package.enforce_init","title":"enforce_init  <code>instance-attribute</code>","text":"<pre><code>enforce_init = enforce_init\n</code></pre> <p>Whether to enforce the presence of <code>__init__.py</code> files.</p>"},{"location":"reference/api/#dependenpy.Package.isdsm","title":"isdsm  <code>property</code>","text":"<pre><code>isdsm: bool\n</code></pre> <p>Property to check if object is instance of DSM.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Whether this object is a DSM.</p> </li> </ul>"},{"location":"reference/api/#dependenpy.Package.ismodule","title":"ismodule  <code>property</code>","text":"<pre><code>ismodule: bool\n</code></pre> <p>Property to check if object is instance of Module.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Whether this object is a module.</p> </li> </ul>"},{"location":"reference/api/#dependenpy.Package.ispackage","title":"ispackage  <code>property</code>","text":"<pre><code>ispackage: bool\n</code></pre> <p>Inherited from NodeMixin. Always True.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Whether this object is a package.</p> </li> </ul>"},{"location":"reference/api/#dependenpy.Package.isroot","title":"isroot  <code>property</code>","text":"<pre><code>isroot: bool\n</code></pre> <p>Property to tell if this node is a root node.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>This package has no parent.</p> </li> </ul>"},{"location":"reference/api/#dependenpy.Package.issubpackage","title":"issubpackage  <code>property</code>","text":"<pre><code>issubpackage: bool\n</code></pre> <p>Property to tell if this node is a sub-package.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>This package has a parent.</p> </li> </ul>"},{"location":"reference/api/#dependenpy.Package.limit_to","title":"limit_to  <code>instance-attribute</code>","text":"<pre><code>limit_to = limit_to or []\n</code></pre> <p>List of strings to limit the recursive tree-building.</p>"},{"location":"reference/api/#dependenpy.Package.modules","title":"modules  <code>instance-attribute</code>","text":"<pre><code>modules: list[Module] = []\n</code></pre> <p>List of modules contained in the node.</p>"},{"location":"reference/api/#dependenpy.Package.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name = name\n</code></pre> <p>Name of the package.</p>"},{"location":"reference/api/#dependenpy.Package.package","title":"package  <code>instance-attribute</code>","text":"<pre><code>package = package\n</code></pre> <p>Parent package.</p>"},{"location":"reference/api/#dependenpy.Package.packages","title":"packages  <code>instance-attribute</code>","text":"<pre><code>packages: list[Package] = []\n</code></pre> <p>List of packages contained in the node.</p>"},{"location":"reference/api/#dependenpy.Package.path","title":"path  <code>instance-attribute</code>","text":"<pre><code>path = path\n</code></pre> <p>Path to the package.</p>"},{"location":"reference/api/#dependenpy.Package.root","title":"root  <code>property</code>","text":"<pre><code>root: Package\n</code></pre> <p>Property to return the root of this node.</p> <p>Returns:</p> <ul> <li> <code>Package</code> (              <code>Package</code> )          \u2013            <p>this node's root package.</p> </li> </ul>"},{"location":"reference/api/#dependenpy.Package.submodules","title":"submodules  <code>property</code>","text":"<pre><code>submodules: list[Module]\n</code></pre> <p>Property to return all sub-modules of the node, recursively.</p> <p>Returns:</p> <ul> <li> <code>list[Module]</code>           \u2013            <p>The sub-modules.</p> </li> </ul>"},{"location":"reference/api/#dependenpy.Package.__bool__","title":"__bool__","text":"<pre><code>__bool__() -&gt; bool\n</code></pre> <p>Node as Boolean.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Result of node.empty.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/node.py</code> <pre><code>def __bool__(self) -&gt; bool:\n    \"\"\"Node as Boolean.\n\n    Returns:\n        Result of node.empty.\n    \"\"\"\n    return bool(self.modules or self.packages)\n</code></pre>"},{"location":"reference/api/#dependenpy.Package.__contains__","title":"__contains__","text":"<pre><code>__contains__(item: Package | Module) -&gt; bool\n</code></pre> <p>Get result of _contains, cache it and return it.</p> <p>Parameters:</p> <ul> <li> <code>item</code>               (<code>Package | Module</code>)           \u2013            <p>A package or module.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if self contains item, False otherwise.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/node.py</code> <pre><code>def __contains__(self, item: Package | Module) -&gt; bool:\n    \"\"\"Get result of _contains, cache it and return it.\n\n    Parameters:\n        item: A package or module.\n\n    Returns:\n        True if self contains item, False otherwise.\n    \"\"\"\n    if item not in self._contains_cache:\n        self._contains_cache[item] = self._contains(item)\n    return self._contains_cache[item]\n</code></pre>"},{"location":"reference/api/#dependenpy.Package.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(item: str) -&gt; Package | Module\n</code></pre> <p>Return the corresponding Package or Module object.</p> <p>Parameters:</p> <ul> <li> <code>item</code>               (<code>str</code>)           \u2013            <p>Name of the package/module, dot-separated.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>KeyError</code>             \u2013            <p>When the package or module cannot be found.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Package | Module</code>           \u2013            <p>The corresponding object.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/node.py</code> <pre><code>def __getitem__(self, item: str) -&gt; Package | Module:\n    \"\"\"Return the corresponding Package or Module object.\n\n    Parameters:\n        item: Name of the package/module, dot-separated.\n\n    Raises:\n        KeyError: When the package or module cannot be found.\n\n    Returns:\n        The corresponding object.\n    \"\"\"\n    depth = item.count(\".\") + 1\n    parts = item.split(\".\", 1)\n    for module in self.modules:\n        if parts[0] == module.name and depth == 1:\n            return module\n    for package in self.packages:\n        if parts[0] == package.name:\n            if depth == 1:\n                return package\n            obj = package.get(parts[1])\n            if obj:\n                return obj\n    raise KeyError(item)\n</code></pre>"},{"location":"reference/api/#dependenpy.Package.absolute_name","title":"absolute_name","text":"<pre><code>absolute_name(depth: int = 0) -&gt; str\n</code></pre> <p>Return the absolute name of the node.</p> <p>Concatenate names from root to self within depth.</p> <p>Parameters:</p> <ul> <li> <code>depth</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Maximum depth to go to.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Absolute name of the node (until given depth is reached).</p> </li> </ul> Source code in <code>src/dependenpy/_internal/node.py</code> <pre><code>def absolute_name(self, depth: int = 0) -&gt; str:\n    \"\"\"Return the absolute name of the node.\n\n    Concatenate names from root to self within depth.\n\n    Parameters:\n        depth: Maximum depth to go to.\n\n    Returns:\n        Absolute name of the node (until given depth is reached).\n    \"\"\"\n    node: Package\n    node, node_depth = self, self.depth  # type: ignore[assignment]\n    if depth &lt; 1:\n        depth = node_depth\n    while node_depth &gt; depth and node.package is not None:\n        node = node.package\n        node_depth -= 1\n    names = []\n    while node is not None:\n        names.append(node.name)\n        node = node.package  # type: ignore[assignment]\n    return \".\".join(reversed(names))\n</code></pre>"},{"location":"reference/api/#dependenpy.Package.as_dict","title":"as_dict","text":"<pre><code>as_dict() -&gt; dict\n</code></pre> <p>Return the dependencies as a dictionary.</p> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>Dictionary of dependencies.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/node.py</code> <pre><code>def as_dict(self) -&gt; dict:\n    \"\"\"Return the dependencies as a dictionary.\n\n    Returns:\n        Dictionary of dependencies.\n    \"\"\"\n    return {\n        \"name\": str(self),\n        \"modules\": [module.as_dict() for module in self.modules],\n        \"packages\": [package.as_dict() for package in self.packages],\n    }\n</code></pre>"},{"location":"reference/api/#dependenpy.Package.as_graph","title":"as_graph","text":"<pre><code>as_graph(depth: int = 0) -&gt; Graph\n</code></pre> <p>Create a graph with self as node, cache it, return it.</p> <p>Parameters:</p> <ul> <li> <code>depth</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Depth of the graph.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Graph</code>           \u2013            <p>An instance of Graph.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/node.py</code> <pre><code>def as_graph(self, depth: int = 0) -&gt; Graph:\n    \"\"\"Create a graph with self as node, cache it, return it.\n\n    Parameters:\n        depth: Depth of the graph.\n\n    Returns:\n        An instance of Graph.\n    \"\"\"\n    if depth not in self._graph_cache:\n        self._graph_cache[depth] = Graph(self, depth=depth)  # type: ignore[arg-type]\n    return self._graph_cache[depth]\n</code></pre>"},{"location":"reference/api/#dependenpy.Package.as_matrix","title":"as_matrix","text":"<pre><code>as_matrix(depth: int = 0) -&gt; Matrix\n</code></pre> <p>Create a matrix with self as node, cache it, return it.</p> <p>Parameters:</p> <ul> <li> <code>depth</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Depth of the matrix.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Matrix</code>           \u2013            <p>An instance of Matrix.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/node.py</code> <pre><code>def as_matrix(self, depth: int = 0) -&gt; Matrix:\n    \"\"\"Create a matrix with self as node, cache it, return it.\n\n    Parameters:\n        depth: Depth of the matrix.\n\n    Returns:\n        An instance of Matrix.\n    \"\"\"\n    if depth not in self._matrix_cache:\n        self._matrix_cache[depth] = Matrix(self, depth=depth)  # type: ignore[arg-type]\n    return self._matrix_cache[depth]\n</code></pre>"},{"location":"reference/api/#dependenpy.Package.as_treemap","title":"as_treemap","text":"<pre><code>as_treemap() -&gt; TreeMap\n</code></pre> <p>Return the dependencies as a TreeMap.</p> <p>Returns:</p> <ul> <li> <code>TreeMap</code>           \u2013            <p>An instance of TreeMap.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/node.py</code> <pre><code>def as_treemap(self) -&gt; TreeMap:\n    \"\"\"Return the dependencies as a TreeMap.\n\n    Returns:\n        An instance of TreeMap.\n    \"\"\"\n    if not self._treemap_cache:\n        self._treemap_cache = TreeMap(self)\n    return self._treemap_cache\n</code></pre>"},{"location":"reference/api/#dependenpy.Package.build_dependencies","title":"build_dependencies","text":"<pre><code>build_dependencies() -&gt; None\n</code></pre> <p>Recursively build the dependencies for sub-modules and sub-packages.</p> <p>Iterate on node's modules then packages and call their build_dependencies methods.</p> Source code in <code>src/dependenpy/_internal/node.py</code> <pre><code>def build_dependencies(self) -&gt; None:\n    \"\"\"Recursively build the dependencies for sub-modules and sub-packages.\n\n    Iterate on node's modules then packages and call their\n    build_dependencies methods.\n    \"\"\"\n    for module in self.modules:\n        module.build_dependencies()\n    for package in self.packages:\n        package.build_dependencies()\n</code></pre>"},{"location":"reference/api/#dependenpy.Package.build_tree","title":"build_tree","text":"<pre><code>build_tree() -&gt; None\n</code></pre> <p>Build the tree for this package.</p> Source code in <code>src/dependenpy/_internal/dsm.py</code> <pre><code>def build_tree(self) -&gt; None:\n    \"\"\"Build the tree for this package.\"\"\"\n    for module in listdir(self.path):\n        abs_m = join(self.path, module)\n        if isfile(abs_m) and module.endswith(\".py\"):\n            name = splitext(module)[0]\n            if not self.limit_to or name in self.limit_to:\n                self.modules.append(Module(name, abs_m, self.dsm, self))\n        elif isdir(abs_m) and (isfile(join(abs_m, \"__init__.py\")) or not self.enforce_init):\n            heads, new_limit_to = self.split_limits_heads()\n            if not heads or module in heads:\n                self.packages.append(\n                    Package(\n                        module,\n                        abs_m,\n                        self.dsm,\n                        self,\n                        new_limit_to,\n                        build_tree=True,\n                        build_dependencies=False,\n                        enforce_init=self.enforce_init,\n                    ),\n                )\n</code></pre>"},{"location":"reference/api/#dependenpy.Package.cardinal","title":"cardinal","text":"<pre><code>cardinal(to: Package | Module) -&gt; int\n</code></pre> <p>Return the number of dependencies of this package to the given node.</p> <p>Parameters:</p> <ul> <li> <code>to</code>               (<code>Package | Module</code>)           \u2013            <p>Target node.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Number of dependencies.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/dsm.py</code> <pre><code>def cardinal(self, to: Package | Module) -&gt; int:\n    \"\"\"Return the number of dependencies of this package to the given node.\n\n    Parameters:\n        to: Target node.\n\n    Returns:\n        Number of dependencies.\n    \"\"\"\n    return sum(module.cardinal(to) for module in self.submodules)\n</code></pre>"},{"location":"reference/api/#dependenpy.Package.get","title":"get","text":"<pre><code>get(item: str) -&gt; Package | Module\n</code></pre> <p>Get item through <code>__getitem__</code> and cache the result.</p> <p>Parameters:</p> <ul> <li> <code>item</code>               (<code>str</code>)           \u2013            <p>Name of package or module.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Package | Module</code>           \u2013            <p>The corresponding object.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/node.py</code> <pre><code>def get(self, item: str) -&gt; Package | Module:\n    \"\"\"Get item through `__getitem__` and cache the result.\n\n    Parameters:\n        item: Name of package or module.\n\n    Returns:\n        The corresponding object.\n    \"\"\"\n    if item not in self._item_cache:\n        try:\n            obj = self.__getitem__(item)\n        except KeyError:\n            obj = None\n        self._item_cache[item] = obj\n    return self._item_cache[item]\n</code></pre>"},{"location":"reference/api/#dependenpy.Package.get_target","title":"get_target","text":"<pre><code>get_target(target: str) -&gt; Package | Module\n</code></pre> <p>Get the result of _get_target, cache it and return it.</p> <p>Parameters:</p> <ul> <li> <code>target</code>               (<code>str</code>)           \u2013            <p>Target to find.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Package | Module</code>           \u2013            <p>Package containing target or corresponding module.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/node.py</code> <pre><code>def get_target(self, target: str) -&gt; Package | Module:\n    \"\"\"Get the result of _get_target, cache it and return it.\n\n    Parameters:\n        target: Target to find.\n\n    Returns:\n        Package containing target or corresponding module.\n    \"\"\"\n    if target not in self._target_cache:\n        self._target_cache[target] = self._get_target(target)\n    return self._target_cache[target]\n</code></pre>"},{"location":"reference/api/#dependenpy.Package.print","title":"print","text":"<pre><code>print(\n    format: str | None = TEXT,\n    output: IO = stdout,\n    **kwargs: Any,\n) -&gt; None\n</code></pre> <p>Print the object in a file or on standard output by default.</p> <p>Parameters:</p> <ul> <li> <code>format</code>               (<code>str | None</code>, default:                   <code>TEXT</code> )           \u2013            <p>Output format (csv, json or text).</p> </li> <li> <code>output</code>               (<code>IO</code>, default:                   <code>stdout</code> )           \u2013            <p>Descriptor to an opened file (default to standard output).</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional arguments.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/helpers.py</code> <pre><code>def print(self, format: str | None = TEXT, output: IO = sys.stdout, **kwargs: Any) -&gt; None:  # noqa: A002\n    \"\"\"Print the object in a file or on standard output by default.\n\n    Parameters:\n        format: Output format (csv, json or text).\n        output: Descriptor to an opened file (default to standard output).\n        **kwargs: Additional arguments.\n    \"\"\"\n    if format is None:\n        format = TEXT\n\n    if format != TEXT:\n        kwargs.pop(\"zero\", \"\")\n\n    if format == TEXT:\n        print(self._to_text(**kwargs), file=output)\n    elif format == CSV:\n        print(self._to_csv(**kwargs), file=output)\n    elif format == JSON:\n        print(self._to_json(**kwargs), file=output)\n</code></pre>"},{"location":"reference/api/#dependenpy.Package.print_graph","title":"print_graph","text":"<pre><code>print_graph(\n    format: str | None = None,\n    output: IO = stdout,\n    depth: int = 0,\n    **kwargs: Any,\n) -&gt; None\n</code></pre> <p>Print the graph for self's nodes.</p> <p>Parameters:</p> <ul> <li> <code>format</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Output format (csv, json or text).</p> </li> <li> <code>output</code>               (<code>IO</code>, default:                   <code>stdout</code> )           \u2013            <p>File descriptor on which to write.</p> </li> <li> <code>depth</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Depth of the graph.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments passed to <code>graph.print</code>.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/node.py</code> <pre><code>def print_graph(\n    self,\n    format: str | None = None,  # noqa: A002\n    output: IO = sys.stdout,\n    depth: int = 0,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Print the graph for self's nodes.\n\n    Parameters:\n        format: Output format (csv, json or text).\n        output: File descriptor on which to write.\n        depth: Depth of the graph.\n        **kwargs: Additional keyword arguments passed to `graph.print`.\n    \"\"\"\n    graph = self.as_graph(depth=depth)\n    graph.print(format=format, output=output, **kwargs)\n</code></pre>"},{"location":"reference/api/#dependenpy.Package.print_matrix","title":"print_matrix","text":"<pre><code>print_matrix(\n    format: str | None = None,\n    output: IO = stdout,\n    depth: int = 0,\n    **kwargs: Any,\n) -&gt; None\n</code></pre> <p>Print the matrix for self's nodes.</p> <p>Parameters:</p> <ul> <li> <code>format</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Output format (csv, json or text).</p> </li> <li> <code>output</code>               (<code>IO</code>, default:                   <code>stdout</code> )           \u2013            <p>File descriptor on which to write.</p> </li> <li> <code>depth</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Depth of the matrix.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments passed to <code>matrix.print</code>.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/node.py</code> <pre><code>def print_matrix(\n    self,\n    format: str | None = None,  # noqa: A002\n    output: IO = sys.stdout,\n    depth: int = 0,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Print the matrix for self's nodes.\n\n    Parameters:\n        format: Output format (csv, json or text).\n        output: File descriptor on which to write.\n        depth: Depth of the matrix.\n        **kwargs: Additional keyword arguments passed to `matrix.print`.\n    \"\"\"\n    matrix = self.as_matrix(depth=depth)\n    matrix.print(format=format, output=output, **kwargs)\n</code></pre>"},{"location":"reference/api/#dependenpy.Package.print_treemap","title":"print_treemap","text":"<pre><code>print_treemap(\n    format: str | None = None,\n    output: IO = stdout,\n    **kwargs: Any,\n) -&gt; None\n</code></pre> <p>Print the matrix for self's nodes.</p> <p>Parameters:</p> <ul> <li> <code>format</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Output format (csv, json or text).</p> </li> <li> <code>output</code>               (<code>IO</code>, default:                   <code>stdout</code> )           \u2013            <p>File descriptor on which to write.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments passed to <code>treemap.print</code>.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/node.py</code> <pre><code>def print_treemap(self, format: str | None = None, output: IO = sys.stdout, **kwargs: Any) -&gt; None:  # noqa: A002\n    \"\"\"Print the matrix for self's nodes.\n\n    Parameters:\n        format: Output format (csv, json or text).\n        output: File descriptor on which to write.\n        **kwargs: Additional keyword arguments passed to `treemap.print`.\n    \"\"\"\n    treemap = self.as_treemap()\n    treemap.print(format=format, output=output, **kwargs)\n</code></pre>"},{"location":"reference/api/#dependenpy.Package.split_limits_heads","title":"split_limits_heads","text":"<pre><code>split_limits_heads() -&gt; tuple[list[str], list[str]]\n</code></pre> <p>Return first parts of dot-separated strings, and rest of strings.</p> <p>Returns:</p> <ul> <li> <code>tuple[list[str], list[str]]</code>           \u2013            <p>The heads and rest of the strings.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/dsm.py</code> <pre><code>def split_limits_heads(self) -&gt; tuple[list[str], list[str]]:\n    \"\"\"Return first parts of dot-separated strings, and rest of strings.\n\n    Returns:\n        The heads and rest of the strings.\n    \"\"\"\n    heads = []\n    new_limit_to = []\n    for limit in self.limit_to:\n        if \".\" in limit:\n            name, limit = limit.split(\".\", 1)  # noqa: PLW2901\n            heads.append(name)\n            new_limit_to.append(limit)\n        else:\n            heads.append(limit)\n    return heads, new_limit_to\n</code></pre>"},{"location":"reference/api/#dependenpy.PackageFinder","title":"PackageFinder","text":"<p>Abstract package finder class.</p> Returned by: <ul> <li> \u00a0dependenpy \u00a0Finder \u00a0finders </li> </ul> Subclassed by: <ul> <li> \u00a0dependenpy <ul> <li> \u00a0InstalledPackageFinder </li> <li> \u00a0LocalPackageFinder </li> </ul> </li> </ul> <p>Methods:</p> <ul> <li> <code>find</code>             \u2013              <p>Find method.</p> </li> </ul>"},{"location":"reference/api/#dependenpy.PackageFinder.find","title":"find","text":"<pre><code>find(package: str, **kwargs: Any) -&gt; PackageSpec | None\n</code></pre> <p>Find method.</p> <p>Parameters:</p> <ul> <li> <code>package</code>               (<code>str</code>)           \u2013            <p>Package to find.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>PackageSpec | None</code>           \u2013            <p>Package spec or None.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/finder.py</code> <pre><code>def find(self, package: str, **kwargs: Any) -&gt; PackageSpec | None:\n    \"\"\"Find method.\n\n    Parameters:\n        package: Package to find.\n        **kwargs: Additional keyword arguments.\n\n    Returns:\n        Package spec or None.\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/api/#dependenpy.PackageSpec","title":"PackageSpec","text":"<pre><code>PackageSpec(\n    name: str, path: str, limit_to: list[str] | None = None\n)\n</code></pre> <p>Holder for a package specification (given as argument to DSM).</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Name of the package.</p> </li> <li> <code>path</code>               (<code>str</code>)           \u2013            <p>Path to the package.</p> </li> <li> <code>limit_to</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Limitations.</p> </li> </ul> Returned by: <ul> <li> <code></code>\u00a0dependenpy <ul> <li> <code></code>\u00a0DSM <code></code>\u00a0specs </li> <li> <code></code>\u00a0Finder <code></code>\u00a0find </li> <li> <code></code>\u00a0InstalledPackageFinder <code></code>\u00a0find </li> <li> <code></code>\u00a0LocalPackageFinder <code></code>\u00a0find </li> <li> <code></code>\u00a0PackageFinder <code></code>\u00a0find </li> <li> <code></code>\u00a0PackageSpec <code></code>\u00a0combine </li> </ul> </li> </ul> Used by: <ul> <li> <code></code>\u00a0dependenpy <code></code>\u00a0PackageSpec <ul> <li> <code></code>\u00a0add </li> <li> <code></code>\u00a0combine </li> </ul> </li> </ul> <p>Methods:</p> <ul> <li> <code>__hash__</code>             \u2013              <p>Hash method.</p> </li> <li> <code>add</code>             \u2013              <p>Add limitations of given spec to self's.</p> </li> <li> <code>combine</code>             \u2013              <p>Combine package specifications' limitations.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>ismodule</code>               (<code>bool</code>)           \u2013            <p>Property to tell if the package is in fact a module (a file).</p> </li> <li> <code>limit_to</code>           \u2013            <p>List of limitations.</p> </li> <li> <code>name</code>           \u2013            <p>Name of the package.</p> </li> <li> <code>path</code>           \u2013            <p>Path to the package.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/finder.py</code> <pre><code>def __init__(self, name: str, path: str, limit_to: list[str] | None = None) -&gt; None:\n    \"\"\"Initialization method.\n\n    Parameters:\n        name: Name of the package.\n        path: Path to the package.\n        limit_to: Limitations.\n    \"\"\"\n    self.name = name\n    \"\"\"Name of the package.\"\"\"\n    self.path = path\n    \"\"\"Path to the package.\"\"\"\n    self.limit_to = limit_to or []\n    \"\"\"List of limitations.\"\"\"\n</code></pre>"},{"location":"reference/api/#dependenpy.PackageSpec.ismodule","title":"ismodule  <code>property</code>","text":"<pre><code>ismodule: bool\n</code></pre> <p>Property to tell if the package is in fact a module (a file).</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Whether this package is in fact a module.</p> </li> </ul>"},{"location":"reference/api/#dependenpy.PackageSpec.limit_to","title":"limit_to  <code>instance-attribute</code>","text":"<pre><code>limit_to = limit_to or []\n</code></pre> <p>List of limitations.</p>"},{"location":"reference/api/#dependenpy.PackageSpec.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name = name\n</code></pre> <p>Name of the package.</p>"},{"location":"reference/api/#dependenpy.PackageSpec.path","title":"path  <code>instance-attribute</code>","text":"<pre><code>path = path\n</code></pre> <p>Path to the package.</p>"},{"location":"reference/api/#dependenpy.PackageSpec.__hash__","title":"__hash__","text":"<pre><code>__hash__()\n</code></pre> <p>Hash method.</p> <p>The hash is computed based on the package name and path.</p> Source code in <code>src/dependenpy/_internal/finder.py</code> <pre><code>def __hash__(self):\n    \"\"\"Hash method.\n\n    The hash is computed based on the package name and path.\n    \"\"\"\n    return hash((self.name, self.path))\n</code></pre>"},{"location":"reference/api/#dependenpy.PackageSpec.add","title":"add","text":"<pre><code>add(spec: PackageSpec) -&gt; None\n</code></pre> <p>Add limitations of given spec to self's.</p> <p>Parameters:</p> <ul> <li> <code>spec</code>               (<code>PackageSpec</code>)           \u2013            <p>Another spec.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/finder.py</code> <pre><code>def add(self, spec: PackageSpec) -&gt; None:\n    \"\"\"Add limitations of given spec to self's.\n\n    Parameters:\n        spec: Another spec.\n    \"\"\"\n    for limit in spec.limit_to:\n        if limit not in self.limit_to:\n            self.limit_to.append(limit)\n</code></pre>"},{"location":"reference/api/#dependenpy.PackageSpec.combine","title":"combine  <code>staticmethod</code>","text":"<pre><code>combine(specs: list[PackageSpec]) -&gt; list[PackageSpec]\n</code></pre> <p>Combine package specifications' limitations.</p> <p>Parameters:</p> <ul> <li> <code>specs</code>               (<code>list[PackageSpec]</code>)           \u2013            <p>The package specifications.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[PackageSpec]</code>           \u2013            <p>The new, merged list of PackageSpec.</p> </li> </ul> Used by: <ul> <li> <code></code>\u00a0dependenpy <code></code>\u00a0DSM <code></code>\u00a0specs </li> </ul> Source code in <code>src/dependenpy/_internal/finder.py</code> <pre><code>@staticmethod\ndef combine(specs: list[PackageSpec]) -&gt; list[PackageSpec]:\n    \"\"\"Combine package specifications' limitations.\n\n    Parameters:\n        specs: The package specifications.\n\n    Returns:\n        The new, merged list of PackageSpec.\n    \"\"\"\n    new_specs: dict[PackageSpec, PackageSpec] = {}\n    for spec in specs:\n        if new_specs.get(spec) is None:\n            new_specs[spec] = spec\n        else:\n            new_specs[spec].add(spec)\n    return list(new_specs.values())\n</code></pre>"},{"location":"reference/api/#dependenpy.PrintMixin","title":"PrintMixin","text":"<p>Print mixin class.</p> Subclassed by: <ul> <li> \u00a0dependenpy <ul> <li> \u00a0DSM </li> <li> \u00a0Graph </li> <li> \u00a0Matrix </li> <li> \u00a0Module </li> <li> \u00a0Package </li> <li> \u00a0TreeMap </li> </ul> </li> </ul> <p>Methods:</p> <ul> <li> <code>print</code>             \u2013              <p>Print the object in a file or on standard output by default.</p> </li> </ul>"},{"location":"reference/api/#dependenpy.PrintMixin.print","title":"print","text":"<pre><code>print(\n    format: str | None = TEXT,\n    output: IO = stdout,\n    **kwargs: Any,\n) -&gt; None\n</code></pre> <p>Print the object in a file or on standard output by default.</p> <p>Parameters:</p> <ul> <li> <code>format</code>               (<code>str | None</code>, default:                   <code>TEXT</code> )           \u2013            <p>Output format (csv, json or text).</p> </li> <li> <code>output</code>               (<code>IO</code>, default:                   <code>stdout</code> )           \u2013            <p>Descriptor to an opened file (default to standard output).</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional arguments.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/helpers.py</code> <pre><code>def print(self, format: str | None = TEXT, output: IO = sys.stdout, **kwargs: Any) -&gt; None:  # noqa: A002\n    \"\"\"Print the object in a file or on standard output by default.\n\n    Parameters:\n        format: Output format (csv, json or text).\n        output: Descriptor to an opened file (default to standard output).\n        **kwargs: Additional arguments.\n    \"\"\"\n    if format is None:\n        format = TEXT\n\n    if format != TEXT:\n        kwargs.pop(\"zero\", \"\")\n\n    if format == TEXT:\n        print(self._to_text(**kwargs), file=output)\n    elif format == CSV:\n        print(self._to_csv(**kwargs), file=output)\n    elif format == JSON:\n        print(self._to_json(**kwargs), file=output)\n</code></pre>"},{"location":"reference/api/#dependenpy.RootNode","title":"RootNode","text":"<pre><code>RootNode(build_tree: bool = True)\n</code></pre> <p>Shared code between DSM and Package.</p> <p>Parameters:</p> <ul> <li> <code>build_tree</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to immediately build the tree or not.</p> </li> </ul> Subclassed by: <ul> <li> <code></code>\u00a0dependenpy <ul> <li> <code></code>\u00a0DSM </li> <li> <code></code>\u00a0Package </li> </ul> </li> </ul> <p>Methods:</p> <ul> <li> <code>__bool__</code>             \u2013              <p>Node as Boolean.</p> </li> <li> <code>__contains__</code>             \u2013              <p>Get result of _contains, cache it and return it.</p> </li> <li> <code>__getitem__</code>             \u2013              <p>Return the corresponding Package or Module object.</p> </li> <li> <code>as_dict</code>             \u2013              <p>Return the dependencies as a dictionary.</p> </li> <li> <code>as_graph</code>             \u2013              <p>Create a graph with self as node, cache it, return it.</p> </li> <li> <code>as_matrix</code>             \u2013              <p>Create a matrix with self as node, cache it, return it.</p> </li> <li> <code>as_treemap</code>             \u2013              <p>Return the dependencies as a TreeMap.</p> </li> <li> <code>build_dependencies</code>             \u2013              <p>Recursively build the dependencies for sub-modules and sub-packages.</p> </li> <li> <code>build_tree</code>             \u2013              <p>To be overridden.</p> </li> <li> <code>get</code>             \u2013              <p>Get item through <code>__getitem__</code> and cache the result.</p> </li> <li> <code>get_target</code>             \u2013              <p>Get the result of _get_target, cache it and return it.</p> </li> <li> <code>print_graph</code>             \u2013              <p>Print the graph for self's nodes.</p> </li> <li> <code>print_matrix</code>             \u2013              <p>Print the matrix for self's nodes.</p> </li> <li> <code>print_treemap</code>             \u2013              <p>Print the matrix for self's nodes.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>empty</code>               (<code>bool</code>)           \u2013            <p>Whether the node has neither modules nor packages.</p> </li> <li> <code>modules</code>               (<code>list[Module]</code>)           \u2013            <p>List of modules contained in the node.</p> </li> <li> <code>packages</code>               (<code>list[Package]</code>)           \u2013            <p>List of packages contained in the node.</p> </li> <li> <code>submodules</code>               (<code>list[Module]</code>)           \u2013            <p>Property to return all sub-modules of the node, recursively.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/node.py</code> <pre><code>def __init__(self, build_tree: bool = True):  # noqa: FBT001,FBT002\n    \"\"\"Initialization method.\n\n    Parameters:\n        build_tree: Whether to immediately build the tree or not.\n    \"\"\"\n    self._target_cache: dict[str, Any] = {}\n    self._item_cache: dict[str, Any] = {}\n    self._contains_cache: dict[Package | Module, bool] = {}\n    self._matrix_cache: dict[int, Matrix] = {}\n    self._graph_cache: dict[int, Graph] = {}\n    self._treemap_cache = TreeMap()\n    self.modules: list[Module] = []\n    \"\"\"List of modules contained in the node.\"\"\"\n    self.packages: list[Package] = []\n    \"\"\"List of packages contained in the node.\"\"\"\n\n    if build_tree:\n        self.build_tree()\n</code></pre>"},{"location":"reference/api/#dependenpy.RootNode.empty","title":"empty  <code>property</code>","text":"<pre><code>empty: bool\n</code></pre> <p>Whether the node has neither modules nor packages.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if empty, False otherwise.</p> </li> </ul>"},{"location":"reference/api/#dependenpy.RootNode.modules","title":"modules  <code>instance-attribute</code>","text":"<pre><code>modules: list[Module] = []\n</code></pre> <p>List of modules contained in the node.</p>"},{"location":"reference/api/#dependenpy.RootNode.packages","title":"packages  <code>instance-attribute</code>","text":"<pre><code>packages: list[Package] = []\n</code></pre> <p>List of packages contained in the node.</p>"},{"location":"reference/api/#dependenpy.RootNode.submodules","title":"submodules  <code>property</code>","text":"<pre><code>submodules: list[Module]\n</code></pre> <p>Property to return all sub-modules of the node, recursively.</p> <p>Returns:</p> <ul> <li> <code>list[Module]</code>           \u2013            <p>The sub-modules.</p> </li> </ul>"},{"location":"reference/api/#dependenpy.RootNode.__bool__","title":"__bool__","text":"<pre><code>__bool__() -&gt; bool\n</code></pre> <p>Node as Boolean.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Result of node.empty.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/node.py</code> <pre><code>def __bool__(self) -&gt; bool:\n    \"\"\"Node as Boolean.\n\n    Returns:\n        Result of node.empty.\n    \"\"\"\n    return bool(self.modules or self.packages)\n</code></pre>"},{"location":"reference/api/#dependenpy.RootNode.__contains__","title":"__contains__","text":"<pre><code>__contains__(item: Package | Module) -&gt; bool\n</code></pre> <p>Get result of _contains, cache it and return it.</p> <p>Parameters:</p> <ul> <li> <code>item</code>               (<code>Package | Module</code>)           \u2013            <p>A package or module.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if self contains item, False otherwise.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/node.py</code> <pre><code>def __contains__(self, item: Package | Module) -&gt; bool:\n    \"\"\"Get result of _contains, cache it and return it.\n\n    Parameters:\n        item: A package or module.\n\n    Returns:\n        True if self contains item, False otherwise.\n    \"\"\"\n    if item not in self._contains_cache:\n        self._contains_cache[item] = self._contains(item)\n    return self._contains_cache[item]\n</code></pre>"},{"location":"reference/api/#dependenpy.RootNode.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(item: str) -&gt; Package | Module\n</code></pre> <p>Return the corresponding Package or Module object.</p> <p>Parameters:</p> <ul> <li> <code>item</code>               (<code>str</code>)           \u2013            <p>Name of the package/module, dot-separated.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>KeyError</code>             \u2013            <p>When the package or module cannot be found.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Package | Module</code>           \u2013            <p>The corresponding object.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/node.py</code> <pre><code>def __getitem__(self, item: str) -&gt; Package | Module:\n    \"\"\"Return the corresponding Package or Module object.\n\n    Parameters:\n        item: Name of the package/module, dot-separated.\n\n    Raises:\n        KeyError: When the package or module cannot be found.\n\n    Returns:\n        The corresponding object.\n    \"\"\"\n    depth = item.count(\".\") + 1\n    parts = item.split(\".\", 1)\n    for module in self.modules:\n        if parts[0] == module.name and depth == 1:\n            return module\n    for package in self.packages:\n        if parts[0] == package.name:\n            if depth == 1:\n                return package\n            obj = package.get(parts[1])\n            if obj:\n                return obj\n    raise KeyError(item)\n</code></pre>"},{"location":"reference/api/#dependenpy.RootNode.as_dict","title":"as_dict","text":"<pre><code>as_dict() -&gt; dict\n</code></pre> <p>Return the dependencies as a dictionary.</p> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>Dictionary of dependencies.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/node.py</code> <pre><code>def as_dict(self) -&gt; dict:\n    \"\"\"Return the dependencies as a dictionary.\n\n    Returns:\n        Dictionary of dependencies.\n    \"\"\"\n    return {\n        \"name\": str(self),\n        \"modules\": [module.as_dict() for module in self.modules],\n        \"packages\": [package.as_dict() for package in self.packages],\n    }\n</code></pre>"},{"location":"reference/api/#dependenpy.RootNode.as_graph","title":"as_graph","text":"<pre><code>as_graph(depth: int = 0) -&gt; Graph\n</code></pre> <p>Create a graph with self as node, cache it, return it.</p> <p>Parameters:</p> <ul> <li> <code>depth</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Depth of the graph.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Graph</code>           \u2013            <p>An instance of Graph.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/node.py</code> <pre><code>def as_graph(self, depth: int = 0) -&gt; Graph:\n    \"\"\"Create a graph with self as node, cache it, return it.\n\n    Parameters:\n        depth: Depth of the graph.\n\n    Returns:\n        An instance of Graph.\n    \"\"\"\n    if depth not in self._graph_cache:\n        self._graph_cache[depth] = Graph(self, depth=depth)  # type: ignore[arg-type]\n    return self._graph_cache[depth]\n</code></pre>"},{"location":"reference/api/#dependenpy.RootNode.as_matrix","title":"as_matrix","text":"<pre><code>as_matrix(depth: int = 0) -&gt; Matrix\n</code></pre> <p>Create a matrix with self as node, cache it, return it.</p> <p>Parameters:</p> <ul> <li> <code>depth</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Depth of the matrix.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Matrix</code>           \u2013            <p>An instance of Matrix.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/node.py</code> <pre><code>def as_matrix(self, depth: int = 0) -&gt; Matrix:\n    \"\"\"Create a matrix with self as node, cache it, return it.\n\n    Parameters:\n        depth: Depth of the matrix.\n\n    Returns:\n        An instance of Matrix.\n    \"\"\"\n    if depth not in self._matrix_cache:\n        self._matrix_cache[depth] = Matrix(self, depth=depth)  # type: ignore[arg-type]\n    return self._matrix_cache[depth]\n</code></pre>"},{"location":"reference/api/#dependenpy.RootNode.as_treemap","title":"as_treemap","text":"<pre><code>as_treemap() -&gt; TreeMap\n</code></pre> <p>Return the dependencies as a TreeMap.</p> <p>Returns:</p> <ul> <li> <code>TreeMap</code>           \u2013            <p>An instance of TreeMap.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/node.py</code> <pre><code>def as_treemap(self) -&gt; TreeMap:\n    \"\"\"Return the dependencies as a TreeMap.\n\n    Returns:\n        An instance of TreeMap.\n    \"\"\"\n    if not self._treemap_cache:\n        self._treemap_cache = TreeMap(self)\n    return self._treemap_cache\n</code></pre>"},{"location":"reference/api/#dependenpy.RootNode.build_dependencies","title":"build_dependencies","text":"<pre><code>build_dependencies() -&gt; None\n</code></pre> <p>Recursively build the dependencies for sub-modules and sub-packages.</p> <p>Iterate on node's modules then packages and call their build_dependencies methods.</p> Source code in <code>src/dependenpy/_internal/node.py</code> <pre><code>def build_dependencies(self) -&gt; None:\n    \"\"\"Recursively build the dependencies for sub-modules and sub-packages.\n\n    Iterate on node's modules then packages and call their\n    build_dependencies methods.\n    \"\"\"\n    for module in self.modules:\n        module.build_dependencies()\n    for package in self.packages:\n        package.build_dependencies()\n</code></pre>"},{"location":"reference/api/#dependenpy.RootNode.build_tree","title":"build_tree","text":"<pre><code>build_tree() -&gt; None\n</code></pre> <p>To be overridden.</p> Source code in <code>src/dependenpy/_internal/node.py</code> <pre><code>def build_tree(self) -&gt; None:\n    \"\"\"To be overridden.\"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/api/#dependenpy.RootNode.get","title":"get","text":"<pre><code>get(item: str) -&gt; Package | Module\n</code></pre> <p>Get item through <code>__getitem__</code> and cache the result.</p> <p>Parameters:</p> <ul> <li> <code>item</code>               (<code>str</code>)           \u2013            <p>Name of package or module.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Package | Module</code>           \u2013            <p>The corresponding object.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/node.py</code> <pre><code>def get(self, item: str) -&gt; Package | Module:\n    \"\"\"Get item through `__getitem__` and cache the result.\n\n    Parameters:\n        item: Name of package or module.\n\n    Returns:\n        The corresponding object.\n    \"\"\"\n    if item not in self._item_cache:\n        try:\n            obj = self.__getitem__(item)\n        except KeyError:\n            obj = None\n        self._item_cache[item] = obj\n    return self._item_cache[item]\n</code></pre>"},{"location":"reference/api/#dependenpy.RootNode.get_target","title":"get_target","text":"<pre><code>get_target(target: str) -&gt; Package | Module\n</code></pre> <p>Get the result of _get_target, cache it and return it.</p> <p>Parameters:</p> <ul> <li> <code>target</code>               (<code>str</code>)           \u2013            <p>Target to find.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Package | Module</code>           \u2013            <p>Package containing target or corresponding module.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/node.py</code> <pre><code>def get_target(self, target: str) -&gt; Package | Module:\n    \"\"\"Get the result of _get_target, cache it and return it.\n\n    Parameters:\n        target: Target to find.\n\n    Returns:\n        Package containing target or corresponding module.\n    \"\"\"\n    if target not in self._target_cache:\n        self._target_cache[target] = self._get_target(target)\n    return self._target_cache[target]\n</code></pre>"},{"location":"reference/api/#dependenpy.RootNode.print_graph","title":"print_graph","text":"<pre><code>print_graph(\n    format: str | None = None,\n    output: IO = stdout,\n    depth: int = 0,\n    **kwargs: Any,\n) -&gt; None\n</code></pre> <p>Print the graph for self's nodes.</p> <p>Parameters:</p> <ul> <li> <code>format</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Output format (csv, json or text).</p> </li> <li> <code>output</code>               (<code>IO</code>, default:                   <code>stdout</code> )           \u2013            <p>File descriptor on which to write.</p> </li> <li> <code>depth</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Depth of the graph.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments passed to <code>graph.print</code>.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/node.py</code> <pre><code>def print_graph(\n    self,\n    format: str | None = None,  # noqa: A002\n    output: IO = sys.stdout,\n    depth: int = 0,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Print the graph for self's nodes.\n\n    Parameters:\n        format: Output format (csv, json or text).\n        output: File descriptor on which to write.\n        depth: Depth of the graph.\n        **kwargs: Additional keyword arguments passed to `graph.print`.\n    \"\"\"\n    graph = self.as_graph(depth=depth)\n    graph.print(format=format, output=output, **kwargs)\n</code></pre>"},{"location":"reference/api/#dependenpy.RootNode.print_matrix","title":"print_matrix","text":"<pre><code>print_matrix(\n    format: str | None = None,\n    output: IO = stdout,\n    depth: int = 0,\n    **kwargs: Any,\n) -&gt; None\n</code></pre> <p>Print the matrix for self's nodes.</p> <p>Parameters:</p> <ul> <li> <code>format</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Output format (csv, json or text).</p> </li> <li> <code>output</code>               (<code>IO</code>, default:                   <code>stdout</code> )           \u2013            <p>File descriptor on which to write.</p> </li> <li> <code>depth</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Depth of the matrix.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments passed to <code>matrix.print</code>.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/node.py</code> <pre><code>def print_matrix(\n    self,\n    format: str | None = None,  # noqa: A002\n    output: IO = sys.stdout,\n    depth: int = 0,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Print the matrix for self's nodes.\n\n    Parameters:\n        format: Output format (csv, json or text).\n        output: File descriptor on which to write.\n        depth: Depth of the matrix.\n        **kwargs: Additional keyword arguments passed to `matrix.print`.\n    \"\"\"\n    matrix = self.as_matrix(depth=depth)\n    matrix.print(format=format, output=output, **kwargs)\n</code></pre>"},{"location":"reference/api/#dependenpy.RootNode.print_treemap","title":"print_treemap","text":"<pre><code>print_treemap(\n    format: str | None = None,\n    output: IO = stdout,\n    **kwargs: Any,\n) -&gt; None\n</code></pre> <p>Print the matrix for self's nodes.</p> <p>Parameters:</p> <ul> <li> <code>format</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Output format (csv, json or text).</p> </li> <li> <code>output</code>               (<code>IO</code>, default:                   <code>stdout</code> )           \u2013            <p>File descriptor on which to write.</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional keyword arguments passed to <code>treemap.print</code>.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/node.py</code> <pre><code>def print_treemap(self, format: str | None = None, output: IO = sys.stdout, **kwargs: Any) -&gt; None:  # noqa: A002\n    \"\"\"Print the matrix for self's nodes.\n\n    Parameters:\n        format: Output format (csv, json or text).\n        output: File descriptor on which to write.\n        **kwargs: Additional keyword arguments passed to `treemap.print`.\n    \"\"\"\n    treemap = self.as_treemap()\n    treemap.print(format=format, output=output, **kwargs)\n</code></pre>"},{"location":"reference/api/#dependenpy.TreeMap","title":"TreeMap","text":"<pre><code>TreeMap(*nodes: Any, value: int = -1)\n</code></pre> <p>               Bases: <code>PrintMixin</code></p> <p>TreeMap class.</p> <p>Parameters:</p> <ul> <li> <code>*nodes</code>               (<code>Any</code>, default:                   <code>()</code> )           \u2013            <p>the nodes from which to build the treemap.</p> </li> <li> <code>value</code>               (<code>int</code>, default:                   <code>-1</code> )           \u2013            <p>the value of the current area.</p> </li> </ul> Returned by: <ul> <li> <code></code>\u00a0dependenpy <ul> <li> <code></code>\u00a0DSM <code></code>\u00a0as_treemap </li> <li> <code></code>\u00a0Package <code></code>\u00a0as_treemap </li> <li> <code></code>\u00a0RootNode <code></code>\u00a0as_treemap </li> </ul> </li> </ul> <p>Methods:</p> <ul> <li> <code>print</code>             \u2013              <p>Print the object in a file or on standard output by default.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>value</code>           \u2013            <p>The value of the current area.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/structures.py</code> <pre><code>def __init__(self, *nodes: Any, value: int = -1):  # noqa: ARG002\n    \"\"\"Initialization method.\n\n    Arguments:\n        *nodes: the nodes from which to build the treemap.\n        value: the value of the current area.\n    \"\"\"\n    # if nodes:\n    #     matrix_lower_level = Matrix(*nodes, depth=2)\n    #     matrix_current_level = Matrix(*nodes, depth=1)\n    #     if value == -1:\n    #         value = sum(c for row in matrix_current_level.data for c in row)\n    #     splits = [0]\n    #     key_comp = matrix_lower_level.keys[0].split('.')[0]\n    #     i = 1\n    #     for key in matrix_lower_level.keys[1:]:\n    #         key = key.split('.')[0]\n    #         if key != key_comp:\n    #             splits.append(i)\n    #             key_comp = key\n    #         i += 1\n    #     splits.append(i)\n    #\n    #     self.data = []\n    #     for i in range(len(splits) - 1):\n    #         self.data.append([])\n    #         rows = matrix_lower_level.data[splits[i]:splits[i+1]]\n    #         for j in range(len(splits) - 1):\n    #             self.data[i].append([row[splits[j]:splits[j+1]] for row in rows])\n\n    self.value = value\n    \"\"\"The value of the current area.\"\"\"\n</code></pre>"},{"location":"reference/api/#dependenpy.TreeMap.value","title":"value  <code>instance-attribute</code>","text":"<pre><code>value = value\n</code></pre> <p>The value of the current area.</p>"},{"location":"reference/api/#dependenpy.TreeMap.print","title":"print","text":"<pre><code>print(\n    format: str | None = TEXT,\n    output: IO = stdout,\n    **kwargs: Any,\n) -&gt; None\n</code></pre> <p>Print the object in a file or on standard output by default.</p> <p>Parameters:</p> <ul> <li> <code>format</code>               (<code>str | None</code>, default:                   <code>TEXT</code> )           \u2013            <p>Output format (csv, json or text).</p> </li> <li> <code>output</code>               (<code>IO</code>, default:                   <code>stdout</code> )           \u2013            <p>Descriptor to an opened file (default to standard output).</p> </li> <li> <code>**kwargs</code>               (<code>Any</code>, default:                   <code>{}</code> )           \u2013            <p>Additional arguments.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/helpers.py</code> <pre><code>def print(self, format: str | None = TEXT, output: IO = sys.stdout, **kwargs: Any) -&gt; None:  # noqa: A002\n    \"\"\"Print the object in a file or on standard output by default.\n\n    Parameters:\n        format: Output format (csv, json or text).\n        output: Descriptor to an opened file (default to standard output).\n        **kwargs: Additional arguments.\n    \"\"\"\n    if format is None:\n        format = TEXT\n\n    if format != TEXT:\n        kwargs.pop(\"zero\", \"\")\n\n    if format == TEXT:\n        print(self._to_text(**kwargs), file=output)\n    elif format == CSV:\n        print(self._to_csv(**kwargs), file=output)\n    elif format == JSON:\n        print(self._to_json(**kwargs), file=output)\n</code></pre>"},{"location":"reference/api/#dependenpy.Vertex","title":"Vertex","text":"<pre><code>Vertex(name: str)\n</code></pre> <p>Vertex class. Used in Graph class.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>name of the vertex.</p> </li> </ul> Returned by: <ul> <li> <code></code>\u00a0dependenpy <code></code>\u00a0Edge <ul> <li> <code></code>\u00a0vertex_in </li> <li> <code></code>\u00a0vertex_out </li> </ul> </li> </ul> Used by: <ul> <li> <code></code>\u00a0dependenpy <ul> <li> <code></code>\u00a0Edge <ul> <li> <code></code>\u00a0go_from </li> <li> <code></code>\u00a0go_in </li> </ul> </li> <li> <code></code>\u00a0Vertex <ul> <li> <code></code>\u00a0connect_from </li> <li> <code></code>\u00a0connect_to </li> </ul> </li> </ul> </li> </ul> <p>Methods:</p> <ul> <li> <code>connect_from</code>             \u2013              <p>Connect another vertex to this one.</p> </li> <li> <code>connect_to</code>             \u2013              <p>Connect this vertex to another one.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>edges_in</code>               (<code>set[Edge]</code>)           \u2013            <p>Incoming edges.</p> </li> <li> <code>edges_out</code>               (<code>set[Edge]</code>)           \u2013            <p>Outgoing edges.</p> </li> <li> <code>name</code>           \u2013            <p>Name of the vertex.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/structures.py</code> <pre><code>def __init__(self, name: str) -&gt; None:\n    \"\"\"Initialization method.\n\n    Parameters:\n        name (str): name of the vertex.\n    \"\"\"\n    self.name = name\n    \"\"\"Name of the vertex.\"\"\"\n    self.edges_in: set[Edge] = set()\n    \"\"\"Incoming edges.\"\"\"\n    self.edges_out: set[Edge] = set()\n    \"\"\"Outgoing edges.\"\"\"\n</code></pre>"},{"location":"reference/api/#dependenpy.Vertex.edges_in","title":"edges_in  <code>instance-attribute</code>","text":"<pre><code>edges_in: set[Edge] = set()\n</code></pre> <p>Incoming edges.</p>"},{"location":"reference/api/#dependenpy.Vertex.edges_out","title":"edges_out  <code>instance-attribute</code>","text":"<pre><code>edges_out: set[Edge] = set()\n</code></pre> <p>Outgoing edges.</p>"},{"location":"reference/api/#dependenpy.Vertex.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name = name\n</code></pre> <p>Name of the vertex.</p>"},{"location":"reference/api/#dependenpy.Vertex.connect_from","title":"connect_from","text":"<pre><code>connect_from(vertex: Vertex, weight: int = 1) -&gt; Edge\n</code></pre> <p>Connect another vertex to this one.</p> <p>Parameters:</p> <ul> <li> <code>vertex</code>               (<code>Vertex</code>)           \u2013            <p>Vertex to connect from.</p> </li> <li> <code>weight</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Weight of the edge.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Edge</code>           \u2013            <p>The newly created edge.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/structures.py</code> <pre><code>def connect_from(self, vertex: Vertex, weight: int = 1) -&gt; Edge:\n    \"\"\"Connect another vertex to this one.\n\n    Parameters:\n        vertex: Vertex to connect from.\n        weight: Weight of the edge.\n\n    Returns:\n        The newly created edge.\n    \"\"\"\n    for edge in self.edges_in:\n        if vertex == edge.vertex_out:\n            return edge\n    return Edge(vertex, self, weight)\n</code></pre>"},{"location":"reference/api/#dependenpy.Vertex.connect_to","title":"connect_to","text":"<pre><code>connect_to(vertex: Vertex, weight: int = 1) -&gt; Edge\n</code></pre> <p>Connect this vertex to another one.</p> <p>Parameters:</p> <ul> <li> <code>vertex</code>               (<code>Vertex</code>)           \u2013            <p>Vertex to connect to.</p> </li> <li> <code>weight</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Weight of the edge.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Edge</code>           \u2013            <p>The newly created edge.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/structures.py</code> <pre><code>def connect_to(self, vertex: Vertex, weight: int = 1) -&gt; Edge:\n    \"\"\"Connect this vertex to another one.\n\n    Parameters:\n        vertex: Vertex to connect to.\n        weight: Weight of the edge.\n\n    Returns:\n        The newly created edge.\n    \"\"\"\n    for edge in self.edges_out:\n        if vertex == edge.vertex_in:\n            return edge\n    return Edge(self, vertex, weight)\n</code></pre>"},{"location":"reference/api/#dependenpy.get_parser","title":"get_parser","text":"<pre><code>get_parser() -&gt; ArgumentParser\n</code></pre> <p>Return the CLI argument parser.</p> <p>Returns:</p> <ul> <li> <code>ArgumentParser</code>           \u2013            <p>An argparse parser.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/cli.py</code> <pre><code>def get_parser() -&gt; argparse.ArgumentParser:\n    \"\"\"Return the CLI argument parser.\n\n    Returns:\n        An argparse parser.\n    \"\"\"\n    parser = argparse.ArgumentParser(\n        prog=\"dependenpy\",\n        add_help=False,\n        description=\"Command line tool for dependenpy Python package.\",\n    )\n    mxg = parser.add_mutually_exclusive_group(required=False)\n\n    parser.add_argument(\n        \"packages\",\n        metavar=\"PACKAGES\",\n        nargs=argparse.ONE_OR_MORE,\n        help=\"The package list. Can be a comma-separated list. Each package \"\n        \"must be either a valid path or a package in PYTHONPATH.\",\n    )\n    parser.add_argument(\n        \"-d\",\n        \"--depth\",\n        default=None,\n        type=int,\n        dest=\"depth\",\n        help=\"Specify matrix or graph depth. Default: best guess.\",\n    )\n    parser.add_argument(\n        \"-f\",\n        \"--format\",\n        choices=FORMAT,\n        default=\"text\",\n        dest=\"format\",\n        help=\"Output format. Default: text.\",\n    )\n    mxg.add_argument(\n        \"-g\",\n        \"--show-graph\",\n        action=\"store_true\",\n        dest=\"graph\",\n        default=False,\n        help=\"Show the graph (no text format). Default: false.\",\n    )\n    parser.add_argument(\n        \"-G\",\n        \"--greedy\",\n        action=\"store_true\",\n        dest=\"greedy\",\n        default=False,\n        help=\"Explore subdirectories even if they do not contain an \"\n        \"__init__.py file. Can make execution slower. Default: false.\",\n    )\n    parser.add_argument(\n        \"-h\",\n        \"--help\",\n        action=\"help\",\n        default=argparse.SUPPRESS,\n        help=\"Show this help message and exit.\",\n    )\n    parser.add_argument(\n        \"-i\",\n        \"--indent\",\n        default=None,\n        type=int,\n        dest=\"indent\",\n        help=\"Specify output indentation. CSV will never be indented. \"\n        \"Text will always have new-lines. JSON can be minified with \"\n        \"a negative value. Default: best guess.\",\n    )\n    mxg.add_argument(\n        \"-l\",\n        \"--show-dependencies-list\",\n        action=\"store_true\",\n        dest=\"dependencies\",\n        default=False,\n        help=\"Show the dependencies list. Default: false.\",\n    )\n    mxg.add_argument(\n        \"-m\",\n        \"--show-matrix\",\n        action=\"store_true\",\n        dest=\"matrix\",\n        default=False,\n        help=\"Show the matrix. Default: true unless -g, -l or -t.\",\n    )\n    parser.add_argument(\n        \"-o\",\n        \"--output\",\n        action=\"store\",\n        dest=\"output\",\n        default=sys.stdout,\n        help=\"Output to given file. Default: stdout.\",\n    )\n    mxg.add_argument(\n        \"-t\",\n        \"--show-treemap\",\n        action=\"store_true\",\n        dest=\"treemap\",\n        default=False,\n        help=\"Show the treemap (work in progress). Default: false.\",\n    )\n    parser.add_argument(\n        \"-v\",\n        \"--version\",\n        action=\"version\",\n        version=f\"dependenpy {debug._get_version()}\",\n        help=\"Show the current version of the program and exit.\",\n    )\n    parser.add_argument(\n        \"-z\",\n        \"--zero\",\n        dest=\"zero\",\n        default=\"0\",\n        help=\"Character to use for cells with value=0 (text matrix display only).\",\n    )\n\n    parser.add_argument(\"--debug-info\", action=_DebugInfo, help=\"Print debug information.\")\n    return parser\n</code></pre>"},{"location":"reference/api/#dependenpy.guess_depth","title":"guess_depth","text":"<pre><code>guess_depth(packages: Sequence[str]) -&gt; int\n</code></pre> <p>Guess the optimal depth to use for the given list of arguments.</p> <p>Parameters:</p> <ul> <li> <code>packages</code>               (<code>Sequence[str]</code>)           \u2013            <p>List of packages.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>Guessed depth to use.</p> </li> </ul> Source code in <code>src/dependenpy/_internal/helpers.py</code> <pre><code>def guess_depth(packages: Sequence[str]) -&gt; int:\n    \"\"\"Guess the optimal depth to use for the given list of arguments.\n\n    Parameters:\n        packages: List of packages.\n\n    Returns:\n        Guessed depth to use.\n    \"\"\"\n    if len(packages) == 1:\n        return packages[0].count(\".\") + 2\n    return min(package.count(\".\") for package in packages) + 1\n</code></pre>"},{"location":"reference/api/#dependenpy.main","title":"main","text":"<pre><code>main(args: list[str] | None = None) -&gt; int\n</code></pre> <p>Run the main program.</p> <p>This function is executed when you type <code>dependenpy</code> or <code>python -m dependenpy</code>.</p> <p>Parameters:</p> <ul> <li> <code>args</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Arguments passed from the command line.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>An exit code. 0 (OK), 1 (dsm empty) or 2 (error).</p> </li> </ul> Source code in <code>src/dependenpy/_internal/cli.py</code> <pre><code>def main(args: list[str] | None = None) -&gt; int:\n    \"\"\"Run the main program.\n\n    This function is executed when you type `dependenpy` or `python -m dependenpy`.\n\n    Parameters:\n        args: Arguments passed from the command line.\n\n    Returns:\n        An exit code. 0 (OK), 1 (dsm empty) or 2 (error).\n    \"\"\"\n    parser = get_parser()\n    opts = parser.parse_args(args=args)\n    if not (opts.matrix or opts.dependencies or opts.treemap or opts.graph):\n        opts.matrix = True\n\n    dsm = DSM(*_get_packages(opts), build_tree=True, build_dependencies=True, enforce_init=not opts.greedy)\n    if dsm.empty:\n        return 1\n\n    # init colorama\n    init()\n\n    try:\n        _run(opts, dsm)\n    except BrokenPipeError:\n        # avoid traceback\n        return 2\n\n    return 0\n</code></pre>"},{"location":"coverage/","title":"Coverage report","text":""}]}